
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Algorithms for the analysis of node dynamics &#8212; IDTxl 1.5.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/pyramid.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Network comparison" href="idtxl_network_comparison.html" />
    <link rel="prev" title="Algorithms for network inference" href="idtxl_network_inference.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="idtxl_network_comparison.html" title="Network comparison"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="idtxl_network_inference.html" title="Algorithms for network inference"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">IDTxl 1.5.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Algorithms for the analysis of node dynamics</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="algorithms-for-the-analysis-of-node-dynamics">
<h1>Algorithms for the analysis of node dynamics<a class="headerlink" href="#algorithms-for-the-analysis-of-node-dynamics" title="Permalink to this headline">¶</a></h1>
<section id="active-information-storage-ais">
<h2>Active Information Storage (AIS)<a class="headerlink" href="#active-information-storage-ais" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.active_information_storage.</span></span><span class="sig-name descname"><span class="pre">ActiveInformationStorage</span></span><a class="reference internal" href="_modules/idtxl/active_information_storage.html#ActiveInformationStorage"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate active information storage in individual processes.</p>
<p>Estimate active information storage (AIS) in individual processes of the
network. To perform AIS estimation call analyse_network() on the whole
network or a set of nodes or call analyse_single_process() to estimate
AIS for a single process. See docstrings of the two functions for more
information.</p>
<p>References:</p>
<ul class="simple">
<li><p>Lizier, J. T., Prokopenko, M., &amp; Zomaya, A. Y. (2012). Local measures of
information storage in complex distributed computation. Inform Sci, 208,
39–54. <a class="reference external" href="http://doi.org/10.1016/j.ins.2012.04.016">http://doi.org/10.1016/j.ins.2012.04.016</a></p></li>
<li><p>Wibral, M., Lizier, J. T., Vögler, S., Priesemann, V., &amp; Galuske, R.
(2014). Local active information storage as a tool to understand
distributed neural information processing. Front Neuroinf, 8, 1.
<a class="reference external" href="http://doi.org/10.3389/fninf.2014.00001">http://doi.org/10.3389/fninf.2014.00001</a></p></li>
<li><p>Faes, L., Nollo, G., &amp; Porta, A. (2011). Information-based detection
of nonlinear Granger causality in multivariate processes via a
nonuniform embedding technique. Phys Rev E, 83, 1–15.
<a class="reference external" href="http://doi.org/10.1103/PhysRevE.83.051112">http://doi.org/10.1103/PhysRevE.83.051112</a></p></li>
</ul>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>process_set<span class="classifier">list</span></dt><dd><p>list with indices of analyzed processes</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>analysis settings</p>
</dd>
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current value in AIS estimation, (idx process,
idx sample)</p>
</dd>
<dt>selected_vars_full<span class="classifier">list of tuples</span></dt><dd><p>samples in the past state, (idx process, idx sample)</p>
</dd>
<dt>ais<span class="classifier">float</span></dt><dd><p>raw AIS value</p>
</dd>
<dt>sign<span class="classifier">bool</span></dt><dd><p>true if AIS is significant</p>
</dd>
<dt>pvalue: float</dt><dd><p>p-value of AIS</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">analyse_network</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/active_information_storage.html#ActiveInformationStorage.analyse_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate active information storage for multiple network processes.</p>
<p>Estimate active information storage for all or a subset of processes in
the network.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a detailed description of the algorithm and settings see
documentation of the analyse_single_process() method and
references in the class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span> <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;tau&#39;</span><span class="p">:</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">processes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">ActiveInformationStorage</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                           <span class="n">processes</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, settings
can further contain</p>
<ul class="simple">
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>fdr_correction : bool [optional] - correct results on the
network level, see documentation of stats.ais_fdr() for
details (default=True)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>processes<span class="classifier">list of int | ‘all’</span></dt><dd><p>index of processes (default=’all’);
if ‘all’, AIS is estimated for all processes;
if list of int, AIS is estimated for processes specified in the
list.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsSingleProcessAnalysis instance</dt><dd><p>results of network AIS estimation, see documentation of
ResultsSingleProcessAnalysis()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">analyse_single_process</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/active_information_storage.html#ActiveInformationStorage.analyse_single_process"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate active information storage for a single process.</p>
<p>Estimate active information storage for one process in the network.
Uses non-uniform embedding found through information maximisation. This
is done in three steps (see Lizier and Faes for details):</p>
<ol class="arabic simple">
<li><p>Find all relevant samples in the processes’ own past, by
iteratively adding candidate samples that have significant
conditional mutual information (CMI) with the current value
(conditional on all samples that were added previously)</p></li>
<li><p>Prune the final conditional set by testing the CMI between each
sample in the final set and the current value, conditional on all
other samples in the final set</p></li>
<li><p>Calculate AIS using the final set of candidates as the past state
(calculate MI between samples in the past and the current value);
test for statistical significance using a permutation test</p></li>
</ol>
<dl class="simple">
<dt>Note:</dt><dd><p>For a further description of the algorithm see references in the
class docstring.</p>
</dd>
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimator use and statistics:</p>
<ul class="simple">
<li><p>cmi_estimator : str - estimator to be used for CMI and MI
calculation (for estimator settings see the documentation in
the estimators_* modules)</p></li>
<li><p>max_lag : int - maximum temporal search depth for candidates
in the processes’ past in samples</p></li>
<li><p>tau : int [optional] - spacing between candidates in the
sources’ past in samples (default=1)</p></li>
<li><p>n_perm_* : int [optional] - number of permutations, where *
can be ‘max_stat’, ‘min_stat’, ‘mi’ (default=500)</p></li>
<li><p>alpha_* : float [optional] - critical alpha level for
statistical significance, where * can be ‘max_stat’,
‘min_stat’, ‘mi’ (default=0.05)</p></li>
<li><p>add_conditionals : list of tuples | str [optional] - force
the estimator to add these conditionals when estimating TE;
can either be a list of variables, where each variable is
described as (idx process, lag wrt to current value) or can
be a string: ‘faes’ for Faes-Method (see references)</p></li>
<li><p>permute_in_time : bool [optional] - force surrogate creation
by shuffling realisations in time instead of shuffling
replications; see documentation of Data.permute_samples() for
further settings (default=False)</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>write_ckp : bool [optional] - enable checkpointing, writes
analysis state to disk every time a variable is selected;
resume crashed analysis using
network_analysis.resume_checkpoint() (default=False)</p></li>
<li><p>filename_ckp : str [optional] - checkpoint file name (without
extension) (default=’./idtxl_checkpoint’)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>process<span class="classifier">int</span></dt><dd><p>index of process</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsSingleProcessAnalysis instance</dt><dd><p>results of AIS estimation, see documentation of
ResultsSingleProcessAnalysis()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="multivariate-partial-information-decomposition-pid">
<h2>Multivariate Partial Information Decomposition (PID)<a class="headerlink" href="#multivariate-partial-information-decomposition-pid" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.multivariate_pid.</span></span><span class="sig-name descname"><span class="pre">MultivariatePID</span></span><a class="reference internal" href="_modules/idtxl/multivariate_pid.html#MultivariatePID"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Perform partial information decomposition for individual processes.</p>
<p>Perform partial information decomposition (PID) for multiple source
processes (up to 4 sources) and a target process in the network.
Estimate unique, shared, and synergistic information in the multiple
sources about the target. Call analyse_network() on the whole network
or a set of nodes or call analyse_single_target() to estimate PID for
a single process. See docstrings of the two functions for more information.</p>
<p>References:</p>
<ul class="simple">
<li><p>Williams, P. L., &amp; Beer, R. D. (2010). Nonnegative Decomposition of
Multivariate Information, 1–14. Retrieved from
<a class="reference external" href="http://arxiv.org/abs/1004.2515">http://arxiv.org/abs/1004.2515</a></p></li>
<li><p>Makkeh, A. &amp; Gutknecht, A. &amp; Wibral, M. (2020). A Differentiable measure
for shared information. 1- 27 Retrieved from
<a class="reference external" href="http://arxiv.org/abs/2002.03356">http://arxiv.org/abs/2002.03356</a></p></li>
</ul>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sources<span class="classifier">array type</span></dt><dd><p>multiple of indices of source processes</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>analysis settings</p>
</dd>
<dt>results<span class="classifier">dict</span></dt><dd><p>estimated PID</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">analyse_network</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_pid.html#MultivariatePID.analyse_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate partial information decomposition for network nodes.</p>
<p>Estimate, for multiple nodes (target processes), the partial
information decomposition (PID) for multiple source processes
(up to 4 sources) and each of these target processes
in the network.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a detailed description of the algorithm and settings see
documentation of the analyse_single_target() method and
references in the class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alph</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">target1</span><span class="p">,</span> <span class="n">s3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span><span class="p">,</span> <span class="n">target</span><span class="p">)),</span> <span class="s1">&#39;ps&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normalise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;lags_pid&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">]],</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;verbose&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;pid_estimator&#39;</span><span class="p">:</span> <span class="s1">&#39;SxPID&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">targets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pid_analysis</span> <span class="o">=</span> <span class="n">MultivariatePID</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">pid_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                       <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, can
contain</p>
<ul class="simple">
<li><p>lags_pid : list of lists of ints [optional] - lags in samples
between sources and target
(default=[[1, 1, …, 1], [1, 1, …, 1], …])</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>targets<span class="classifier">list of int</span></dt><dd><p>index of target processes</p>
</dd>
<dt>sources<span class="classifier">list of lists</span></dt><dd><p>indices of the multiple source processes for each target, e.g.,
[[0, 1, 2], [1, 0, 3]], all must lists be of the same lenght and
list of lists must have the same length as targets</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsMultivariatePID instance</dt><dd><p>results of network inference, see documentation of
ResultsMultivariatePID()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">analyse_single_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_pid.html#MultivariatePID.analyse_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate partial information decomposition for a network node.</p>
<p>Estimate partial information decomposition (PID) for multiple source
processes (up to 4 sources) and a target process in the network.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a description of the algorithm and the method see references in
the class and estimator docstrings.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alph</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">target1</span><span class="p">,</span> <span class="n">s3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span><span class="p">,</span> <span class="n">target</span><span class="p">)),</span> <span class="s1">&#39;ps&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normalise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;verbose&#39;</span> <span class="p">:</span> <span class="n">false</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;pid_estimator&#39;</span><span class="p">:</span> <span class="s1">&#39;SxPID&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;lags_pid&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pid_analysis</span> <span class="o">=</span> <span class="n">MultivariatePID</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">pid_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">settings</span><span class="o">=</span><span class="n">settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>Args: settings : dict parameters for estimator use and statistics:</p>
<blockquote>
<div><blockquote>
<div><ul class="simple">
<li><p>pid_estimator : str - estimator to be used for PID estimation
(for estimator settings see the documentation in the
estimators_pid modules)</p></li>
<li><p>lags_pid : list of ints [optional] - lags in samples between
sources and target (default=[1, 1, …, 1])</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target processes</p>
</dd>
<dt>sources<span class="classifier">list of ints</span></dt><dd><p>indices of the multiple source processes for the target</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns: ResultsMultivariatePID instance results of</dt><dd><p>network inference, see documentation of
ResultsPID()</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="bivariate-partial-information-decomposition-pid">
<h2>Bivariate Partial Information Decomposition (PID)<a class="headerlink" href="#bivariate-partial-information-decomposition-pid" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.bivariate_pid.</span></span><span class="sig-name descname"><span class="pre">BivariatePID</span></span><a class="reference internal" href="_modules/idtxl/bivariate_pid.html#BivariatePID"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Perform partial information decomposition for individual processes.</p>
<p>Perform partial information decomposition (PID) for two source processes
and one target process in the network. Estimate unique, shared, and
synergistic information in the two sources about the target. Call
analyse_network() on the whole network or a set of nodes or call
analyse_single_target() to estimate PID for a single process. See
docstrings of the two functions for more information.</p>
<p>References:</p>
<ul class="simple">
<li><p>Williams, P. L., &amp; Beer, R. D. (2010). Nonnegative Decomposition of
Multivariate Information, 1–14. Retrieved from
<a class="reference external" href="http://arxiv.org/abs/1004.2515">http://arxiv.org/abs/1004.2515</a></p></li>
<li><p>Bertschinger, N., Rauh, J., Olbrich, E., Jost, J., &amp; Ay, N. (2014).
Quantifying Unique Information. Entropy, 16(4), 2161–2183.
<a class="reference external" href="http://doi.org/10.3390/e16042161">http://doi.org/10.3390/e16042161</a></p></li>
</ul>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sources<span class="classifier">array type</span></dt><dd><p>pair of indices of source processes</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>analysis settings</p>
</dd>
<dt>results<span class="classifier">dict</span></dt><dd><p>estimated PID</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">analyse_network</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/bivariate_pid.html#BivariatePID.analyse_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate partial information decomposition for network nodes.</p>
<p>Estimate partial information decomposition (PID) for multiple nodes in
the network.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a detailed description of the algorithm and settings see
documentation of the analyse_single_target() method and
references in the class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alph</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)),</span> <span class="s1">&#39;ps&#39;</span><span class="p">,</span> <span class="n">normalise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;lags_pid&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_s1&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_s2&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_t&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_unsuc_swaps_row_parm&#39;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;num_reps&#39;</span><span class="p">:</span> <span class="mi">63</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_iters&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;pid_estimator&#39;</span><span class="p">:</span> <span class="s1">&#39;SydneyPID&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">targets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pid_analysis</span> <span class="o">=</span> <span class="n">BivariatePID</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">pid_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                       <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, can
contain</p>
<ul class="simple">
<li><p>lags_pid : list of lists of ints [optional] - lags in samples
between sources and target (default=[[1, 1], [1, 1] …])</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>targets<span class="classifier">list of int</span></dt><dd><p>index of target processes</p>
</dd>
<dt>sources<span class="classifier">list of lists</span></dt><dd><p>indices of the two source processes for each target, e.g.,
[[0, 2], [1, 0]], must have the same length as targets</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsPID instance</dt><dd><p>results of network inference, see documentation of
ResultsPID()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">analyse_single_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/bivariate_pid.html#BivariatePID.analyse_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate partial information decomposition for a network node.</p>
<p>Estimate partial information decomposition (PID) for a target node in
the network.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a description of the algorithm and the method see references in
the class and estimator docstrings.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alph</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)),</span> <span class="s1">&#39;ps&#39;</span><span class="p">,</span> <span class="n">normalise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_s1&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_s2&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_t&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_unsuc_swaps_row_parm&#39;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;num_reps&#39;</span><span class="p">:</span> <span class="mi">63</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_iters&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;pid_calc_name&#39;</span><span class="p">:</span> <span class="s1">&#39;SydneyPID&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;lags_pid&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pid_analysis</span> <span class="o">=</span> <span class="n">BivariatePID</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">pid_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">settings</span><span class="o">=</span><span class="n">settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>Args: settings : dict parameters for estimator use and statistics:</p>
<blockquote>
<div><blockquote>
<div><ul class="simple">
<li><p>pid_estimator : str - estimator to be used for PID estimation
(for estimator settings see the documentation in the
estimators_pid modules)</p></li>
<li><p>lags_pid : list of ints [optional] - lags in samples between
sources and target (default=[1, 1])</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target processes</p>
</dd>
<dt>sources<span class="classifier">list of ints</span></dt><dd><p>indices of the two source processes for the target</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns: ResultsPID instance results of</dt><dd><p>network inference, see documentation of
ResultsPID()</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="history-dependence-estimator-for-neural-spiking-data">
<h2>History-dependence estimator for neural spiking data<a class="headerlink" href="#history-dependence-estimator-for-neural-spiking-data" title="Permalink to this headline">¶</a></h2>
<section id="embedding-optimization">
<h3>Embedding optimization<a class="headerlink" href="#embedding-optimization" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.embedding_optimization_ais_Rudelt.</span></span><span class="sig-name descname"><span class="pre">OptimizationRudelt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Optimization of embedding parameters of spike times using the history dependence estimators</p>
<p>References:</p>
<blockquote>
<div><dl class="simple">
<dt>[1]: L. Rudelt, D. G. Marx, M. Wibral, V. Priesemann: Embedding</dt><dd><p>optimization reveals long-lasting history dependence in
neural spiking activity, 2021, PLOS Computational Biology, 17(6)</p>
</dd>
</dl>
<p>[2]: <a class="reference external" href="https://github.com/Priesemann-Group/hdestimator">https://github.com/Priesemann-Group/hdestimator</a></p>
</div></blockquote>
<p>implemented in idtxl by Michael Lindner, Göttingen 2021</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><ul class="simple">
<li><dl class="simple">
<dt>estimation_method<span class="classifier">string</span></dt><dd><p>The method to be used to estimate the history dependence ‘bbc’ or ‘shuffling’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>embedding_step_size<span class="classifier">float</span></dt><dd><p>Step size delta t (in seconds) with which the window is slid through the data.
(default: 0.005)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>embedding_number_of_bins_set<span class="classifier">list of integer values</span></dt><dd><p>Set of values for d, the number of bins in the embedding.
(default: [1, 2, 3, 4, 5])</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>embedding_past_range_set<span class="classifier">list of floating-point values</span></dt><dd><p>Set of values for T, the past range (in seconds) to be used for embeddings.
(default: [0.005, 0.00561, 0.00629, 0.00706, 0.00792, 0.00889,
0.00998, 0.01119, 0.01256, 0.01409, 0.01581, 0.01774, 0.01991,
0.02233, 0.02506, 0.02812, 0.03155, 0.0354, 0.03972, 0.04456,
0.05, 0.0561, 0.06295, 0.07063, 0.07924, 0.08891, 0.09976,
0.11194, 0.12559, 0.14092, 0.15811, 0.17741, 0.19905, 0.22334,
0.25059, 0.28117, 0.31548, 0.35397, 0.39716, 0.44563, 0.5,
0.56101, 0.62946, 0.70627, 0.79245, 0.88914, 0.99763, 1.11936,
1.25594, 1.40919, 1.58114, 1.77407, 1.99054, 2.23342, 2.50594,
2.81171, 3.15479, 3.53973, 3.97164, 4.45625, 5.0])</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>embedding_scaling_exponent_set<span class="classifier">dict</span></dt><dd><p>Set of values for kappa, the scaling exponent for the bins in the embedding.
Should be a python-dictionary with the three entries ‘number_of_scalings’, ‘min_first_bin_size’ and
‘min_step_for_scaling’.
defaults: {‘number_of_scalings’: 10, ‘min_first_bin_size’: 0.005, ‘min_step_for_scaling’: 0.01})</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>bbc_tolerance<span class="classifier">float</span></dt><dd><p>The tolerance for the Bayesian Bias Criterion. Influences which embeddings are
discarded from the analysis.
(default: 0.05)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>return_averaged_R<span class="classifier">bool</span></dt><dd><p>Return R_tot as the average over R(T) for T in [T_D, T_max], instead of R_tot = R(T_D).
If set to True, the setting for number_of_bootstraps_R_tot (see below) is ignored and set to 0
and CI bounds are not calculated.
(default: True)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>timescale_minimum_past_range<span class="classifier">float</span></dt><dd><p>Minimum past range T_0 (in seconds) to take into consideration for the estimation of the
information timescale tau_R.
(default: 0.01)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>number_of_bootstraps_R_max<span class="classifier">int</span></dt><dd><p>The number of bootstrap re-shuffles that should be used to determine the optimal
embedding. (Bootstrap the estimates of R_max to determine R_tot.)
These are computed during the ‘history-dependence’ task because they are essential
to obtain R_tot.
(default: 250)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>number_of_bootstraps_R_tot<span class="classifier">int</span></dt><dd><p>The number of bootstrap re-shuffles that should be used to estimate the confidence
interval of the optimal embedding. (Bootstrap the estimates of R_tot = R(T_D) to
obtain a confidence interval for R_tot.).
These are computed during the ‘confidence-intervals’ task.
The setting return_averaged_R (see above) needs to be set to False for this setting
to take effect.
(default: 250)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>number_of_bootstraps_nonessential<span class="classifier">int</span></dt><dd><p>The number of bootstrap re-shuffles that should be used to estimate the confidence
intervals for embeddings other than the optimal one. (Bootstrap the estimates of
R(T) for all other T.)
(These are not necessary for the main analysis and therefore default to 0.)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>symbol_block_length<span class="classifier">int</span></dt><dd><p>The number of symbols that should be drawn in each block for bootstrap resampling
If it is set to None (recommended), the length is automatically chosen, based
on heuristics
(default: None)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>bootstrap_CI_use_sd<span class="classifier">bool</span></dt><dd><p>Most of the time we observed normally-distributed bootstrap replications,
so it is sufficient (and more efficient) to compute confidence intervals
based on the standard deviation
(default: True)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>bootstrap_CI_percentile_lo<span class="classifier">float</span></dt><dd><p>The lower percentile for the confidence interval.
This has no effect if bootstrap_CI_use_sd is set to True
(default: 2.5)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>bootstrap_CI_percentile_hi<span class="classifier">float</span></dt><dd><p>The upper percentiles for the confidence interval.
This has no effect if bootstrap_CI_use_sd is set to True
(default: 97.5)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>analyse_auto_MI<span class="classifier">bool</span></dt><dd><p>perform calculation of auto mutual information of the spike train
(default: True)
If set to True:</p>
<ul>
<li><dl class="simple">
<dt>auto_MI_bin_size_set<span class="classifier">list of floating-point values</span></dt><dd><p>Set of values for the sizes of the bins (in seconds).
(default: [0.005, 0.01, 0.025, 0.05, 0.25, 0.5])</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>auto_MI_max_delay<span class="classifier">int</span></dt><dd><p>The maximum delay (in seconds) between the past bin and the response.
(default: 5)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>visualization<span class="classifier">bool</span></dt><dd><p>create .eps output image showing the optimization values and graphs for
the history dependence and the auto mutual information
(default: False)
if set to True:</p>
<ul>
<li><dl class="simple">
<dt>output_path<span class="classifier">String</span></dt><dd><p>Path where the .eps images should be saved</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output_prefix<span class="classifier">String</span></dt><dd><p>Prefix of the output images
e.g. &lt;output_prefix&gt;_process0.eps</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>debug: bool</dt><dd><p>show values while calculating
(default: False)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">analyse_auto_MI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spike_times</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.analyse_auto_MI"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Get the auto MI for the spike times.  If it is available from file, load
it, else compute it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">check_inputs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.check_inputs"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Check input settings for completeness</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">compute_CIs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'R_max'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol_block_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.compute_CIs"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute bootstrap replications of the history dependence estimate
which can be used to obtain confidence intervals.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">data_spiketime object</span></dt><dd><p>Input data</p>
</dd>
<dt>target_R<span class="classifier">String</span></dt><dd><p>One of ‘R_max’, ‘R_tot’ or ‘nonessential’.
If set to R_max, replications of R are produced for the T at which
R is maximised.
If set to R_tot, replications of R are produced for T = T_D (cf
get_temporal_depth_T_D).
If set to nonessential, replications of R are produced for each T
(one embedding per T, cf get_embeddings_that_maximise_R).  These
are not otherwise used in the analysis and are probably only useful
if the resulting plot is visually inspected, so in most cases it can
be set to zero.</p>
</dd>
<dt>symbol_block_length<span class="classifier">int</span></dt><dd><p>The number of symbols that should be drawn in each block for bootstrap resampling
If it is set to None (recommended), the length is automatically chosen, based
on heuristics</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_auto_MI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spike_times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_delays</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_auto_MI"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the auto mutual information in the neuron’s activity, a
measure closely related to history dependence.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_bootstrap_history_dependence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">embedding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bootstraps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol_block_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_bootstrap_history_dependence"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>For a given embedding, return bootstrap replications for R.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_embeddings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">embedding_past_range_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">embedding_number_of_bins_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">embedding_scaling_exponent_set</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_embeddings"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Get all combinations of parameters T, d, k, based on the
sets of selected parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_embeddings_that_maximise_R</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bbc_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dependent_var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'T'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_as_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_embeddings_that_maximise_R"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>For each T (or d), get the embedding for which R is maximised.</p>
<p>For the bbc estimator, here the bbc_tolerance is applied, ie
get the unbiased embeddings that maximise R.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_history_dependence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_history_dependence"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate the history dependence for each embedding to all given processes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_information_timescale_tau_R</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_information_timescale_tau_R"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Get the information timescale tau_R, a characteristic
timescale of history dependence similar to an autocorrelation
time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_past_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_bin_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling_k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_past_range"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Get the past range T of the embedding, based on the parameters d, tau_1 and k.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_set_of_scalings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">past_range_T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_scalings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_first_bin_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_step_for_scaling</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_set_of_scalings"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Get scaling exponents such that the uniform embedding as well as
the embedding for which the first bin has a length of
min_first_bin_size (in seconds), as well as linearly spaced
scaling factors in between, such that in total
number_of_scalings scalings are obtained.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_temporal_depth_T_D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">get_R_thresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_temporal_depth_T_D"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Get the temporal depth T_D, the past range for the
‘optimal’ embedding parameters.</p>
<p>Given the maximal history dependence R at each past range T,
(cf get_embeddings_that_maximise_R), first find the smallest T at
which R is maximised (cf get_max_R_T).  If bootstrap replications
for this R are available, get the smallest T at which this R minus
one standard deviation of the bootstrap estimates is attained.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">optimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.optimize"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Optimize the embedding parameters of spike time data using the Rudelt history dependence estimator.</p>
<p>References:</p>
<blockquote>
<div><dl class="simple">
<dt>[1]: L. Rudelt, D. G. Marx, M. Wibral, V. Priesemann: Embedding</dt><dd><p>optimization reveals long-lasting history dependence in
neural spiking activity, 2021, PLOS Computational Biology, 17(6)</p>
</dd>
</dl>
<p>[2]: <a class="reference external" href="https://github.com/Priesemann-Group/hdestimator">https://github.com/Priesemann-Group/hdestimator</a></p>
</div></blockquote>
<p>implemented in idtxl by Michael Lindner, Göttingen 2021</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">Data_spiketime instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>processes<span class="classifier">list of int</span></dt><dd><p>index of processes;
spike times are optimized all processes specified in the list separately.</p>
</dd>
</dl>
</dd>
<dt>Returns: # ——————————————————————————————————– TODO</dt><dd><dl class="simple">
<dt>ResultsSingleProcessRudelt instance</dt><dd><p>results of Rudelt optimization, see documentation of
ResultsSingleProcessRudelt()</p>
</dd>
<dt>if visulization in settings was set True (see class OptimizationRudelt):</dt><dd><dl class="simple">
<dt>.eps images are created for each optimized process containing:</dt><dd><ul class="simple">
<li><p>optimized values for the process</p></li>
<li><p>graph for the history dependence</p></li>
<li><p>graph for auto mutual information (if calculated)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">optimize_single_run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.optimize_single_run"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>optimizes a single realisation of spike time data given the process number</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">Data_spiketime instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>process<span class="classifier">int</span></dt><dd><p>index of process;</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl>
<dt>DotDict</dt><dd><p>with the following keys</p>
<dl class="simple">
<dt>Process<span class="classifier">int</span></dt><dd><p>Process that was optimized</p>
</dd>
<dt>estimation_method<span class="classifier">String</span></dt><dd><p>Estimation method that was used for optimization</p>
</dd>
<dt>T_D<span class="classifier">float</span></dt><dd><p>Estimated optimal value for the temporal depth TD</p>
</dd>
<dt>tau_R :</dt><dd><p>Information timescale tau_R, a characteristic timescale of history
dependence similar to an autocorrelation time.</p>
</dd>
<dt>R_tot<span class="classifier">float</span></dt><dd><p>Estimated value for the total history dependence Rtot,</p>
</dd>
<dt>AIS_tot<span class="classifier">float</span></dt><dd><p>Estimated value for the total active information storage</p>
</dd>
<dt>opt_number_of_bins_d<span class="classifier">int</span></dt><dd><p>Number of bins d for the embedding that yields (R̂tot ,T̂D)</p>
</dd>
<dt>opt_scaling_k<span class="classifier">int</span></dt><dd><p>Scaling exponent κ for the embedding that yields (R̂tot , T̂D)</p>
</dd>
<dt>opt_first_bin_size<span class="classifier">int</span></dt><dd><p>Size of the first bin τ1 for the embedding that yields (R̂tot , T̂D ),</p>
</dd>
<dt>history_dependence<span class="classifier">array with floating-point values</span></dt><dd><p>Estimated history dependence for each embedding</p>
</dd>
<dt>firing_rate<span class="classifier">float</span></dt><dd><p>Firing rate of the neuron/ spike train</p>
</dd>
<dt>recording_length<span class="classifier">float</span></dt><dd><p>Length of the recording (in seconds)</p>
</dd>
<dt>H_spiking<span class="classifier">float</span></dt><dd><p>Entropy of the spike times</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>if analyse_auto_MI was set to True additionally:</dt><dd><dl class="simple">
<dt>auto_MI<span class="classifier">dict</span></dt><dd><p>numpy array of MI values for each delay</p>
</dd>
<dt>auto_MI_delays<span class="classifier">list of int</span></dt><dd><p>list of delays depending on the given auto_MI_bin_sizes and auto_MI_max_delay</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">remove_subresults_single_process</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.remove_subresults_single_process"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>delete results from self from single process</p>
</dd></dl>

</dd></dl>

</section>
<section id="estimators">
<h3>Estimators<a class="headerlink" href="#estimators" title="Permalink to this headline">¶</a></h3>
<p>Provide HDE estimators.</p>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_Rudelt.</span></span><span class="sig-name descname"><span class="pre">RudeltAbstractEstimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Abstract class for implementation of nsb and plugin estimators from Rudelt.</p>
<p>Abstract class for implementation of nsb and plugin estimators, child classes
implement estimators for mutual information (MI) .</p>
<p>References:</p>
<blockquote>
<div><dl class="simple">
<dt>[1]: L. Rudelt, D. G. Marx, M. Wibral, V. Priesemann: Embedding</dt><dd><p>optimization reveals long-lasting history dependence in
neural spiking activity, 2021, PLOS Computational Biology, 17(6)</p>
</dd>
</dl>
<p>[2]: <a class="reference external" href="https://github.com/Priesemann-Group/hdestimator">https://github.com/Priesemann-Group/hdestimator</a></p>
</div></blockquote>
<p>implemented in idtxl by Michael Lindner, Göttingen 2021</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><ul class="simple">
<li><dl class="simple">
<dt>embedding_step_size<span class="classifier">float [optional]</span></dt><dd><p>Step size delta t (in seconds) with which the window is slid through the data
(default = 0.005).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>normalise<span class="classifier">bool [optional]</span></dt><dd><p>rebase spike times to zero
(default=True)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>return_averaged_R<span class="classifier">bool [optional]</span></dt><dd><p>If set to True, compute R̂tot as the average over R̂(T ) for T ∈ [T̂D, Tmax ] instead of
R̂tot = R(T̂D ). If set to True, the setting for number_of_bootstraps_R_tot is ignored and
set to 0
(default=True)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_median_number_of_spikes_per_bin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw_symbols</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.get_median_number_of_spikes_per_bin"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Given raw symbols (in which the number of spikes per bin are counted,
ie not necessarily binary quantity), get the median number of spikes
for each bin, among all symbols obtained by the embedding.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_multiplicities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphabet_size</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.get_multiplicities"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Get the multiplicities of some given symbol counts.</p>
<p>To estimate the entropy of a system, it is only important how
often a symbol/ event occurs (the probability that it occurs), not
what it represents. Therefore, computations can be simplified by
summarizing symbols by their frequency, as represented by the
multiplicities.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_past_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_bin_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling_k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.get_past_range"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Get the past range T of the embedding, based on the parameters d, tau_1 and k.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_raw_symbols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spike_times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">embedding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_bin_size</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.get_raw_symbols"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Get the raw symbols (in which the number of spikes per bin are counted,
ie not necessarily binary quantity), as obtained by applying the
embedding.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_symbol_counts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_array</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.get_symbol_counts"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Count how often symbols occur</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_window_delimiters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_bin_size</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.get_window_delimiters"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Get delimiters of the window, used to describe the embedding. The
window includes both the past embedding and the response.</p>
<p>The delimiters are times, relative to the first bin, that separate
two consequent bins.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">symbol_array_to_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spikes_in_window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.symbol_array_to_binary"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Given an array of 1s and 0s, representing spikes and the absence
thereof, read the array as a binary number to obtain a
(base 10) integer.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">symbol_binary_to_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_binary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.symbol_binary_to_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Given a binary representation of a symbol (cf symbol_array_to_binary),
convert it back into its array-representation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_Rudelt.</span></span><span class="sig-name descname"><span class="pre">RudeltAbstractNSBEstimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Abstract class for implementation of NSB estimators from Rudelt.</p>
<p>Abstract class for implementation of Nemenman-Shafee-Bialek (NSB)
estimators, child classes implement nsb estimators for mutual information
(MI).</p>
<p>implemented in idtxl by Michael Lindner, Göttingen 2021</p>
<p>References:</p>
<blockquote>
<div><dl class="simple">
<dt>[1]: L. Rudelt, D. G. Marx, M. Wibral, V. Priesemann: Embedding</dt><dd><p>optimization reveals long-lasting history dependence in
neural spiking activity, 2021, PLOS Computational Biology, 17(6)</p>
</dd>
<dt>[2]: I. Nemenman, F. Shafee, W. Bialek: Entropy and inference,</dt><dd><p>revisited. In T.G. Dietterich, S. Becker, and Z. Ghahramani,
editors, Advances in Neural Information Processing Systems 14,
Cambridge, MA, 2002. MIT Press.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><ul class="simple">
<li><dl class="simple">
<dt>embedding_step_size<span class="classifier">float [optional]</span></dt><dd><p>Step size delta t (in seconds) with which the window is slid through the data
(default = 0.005).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>normalise<span class="classifier">bool [optional]</span></dt><dd><p>rebase spike times to zero
(default=True)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>return_averaged_R<span class="classifier">bool [optional]</span></dt><dd><p>If set to True, compute R̂tot as the average over R̂(T ) for T ∈ [T̂D, Tmax ] instead of
R̂tot = R(T̂D ). If set to True, the setting for number_of_bootstraps_R_tot is ignored and
set to 0
(default=True)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">H1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.H1"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the first moment (expectation value) of the entropy H.</p>
<p>H is the entropy one obtains with a symmetric Dirichlet prior
with concentration parameter beta and a multinomial likelihood.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">alpha_ML</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.alpha_ML"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute first guess for the beta_MAP (cf get_beta_MAP) parameter
via the posterior of a Dirichlet process.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">d2_log_rho</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.d2_log_rho"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Second derivate of the logarithm of the Dirichlet multinomial likelihood.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">d2_log_rho_xi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.d2_log_rho_xi"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Second derivative of the logarithm of the nsb (unnormalized) posterior.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">d2_xi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.d2_xi"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Second derivative of xi(beta) (cf d_xi).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">d3_xi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.d3_xi"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Third derivative of xi(beta) (cf d_xi).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">d_log_rho</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.d_log_rho"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>First derivate of the logarithm of the Dirichlet multinomial likelihood.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">d_log_rho_xi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.d_log_rho_xi"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>First derivative of the logarithm of the nsb (unnormalized) posterior.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">d_xi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.d_xi"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>First derivative of xi(beta).</p>
<p>xi(beta) is the entropy of the system when no data has been observed.
d_xi is the prior for the nsb estimator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_beta_MAP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.get_beta_MAP"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Get the maximum a posteriori (MAP) value for beta.</p>
<p>Provides the location of the peak, around which we integrate.</p>
<p>beta_MAP is the value for beta for which the posterior of the
NSB estimator is maximised (or, equivalently, of the logarithm
thereof, as computed here).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_integration_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.get_integration_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Find the integration bounds for the estimator.</p>
<p>Typically it is a delta-like distribution so it is sufficient
to integrate around this peak. (If not this function is not
called.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">log_likelihood_DP_alpha</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.log_likelihood_DP_alpha"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Alpha-dependent terms of the log-likelihood of a Dirichlet Process.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">nsb_entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.nsb_entropy"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate the entropy of a system using the NSB estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mk</strong> – multiplicities</p></li>
<li><p><strong>K</strong> – number of possible symbols/ state space of the system</p></li>
<li><p><strong>N</strong> – total number of observed symbols</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">rho</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.rho"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>rho(beta, data) is the Dirichlet multinomial likelihood.</p>
<p>rho(beta, data) together with the d_xi(beta) make up
the posterior for the nsb estimator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">unnormalized_posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.unnormalized_posterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>The (unnormalized) posterior in the nsb estimator.</p>
<p>Product of the likelihood rho and the prior d_xi;
the normalizing factor is given by the marginal likelihood</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_Rudelt.</span></span><span class="sig-name descname"><span class="pre">RudeltBBCEstimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltBBCEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bayesian bias criterion (BBC) Estimator using NSB and Plugin estimator</p>
<p>Calculate the mutual information (MI) of one variable depending on its past
using nsb and plugin estimator and check if bias criterion is passed.
See parent class for references.</p>
<p>implemented in idtxl by Michael Lindner, Göttingen 2021</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><ul class="simple">
<li><dl class="simple">
<dt>embedding_step_size<span class="classifier">float [optional]</span></dt><dd><p>Step size delta t (in seconds) with which the window is slid through the data
(default = 0.005).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>normalise<span class="classifier">bool [optional]</span></dt><dd><p>rebase spike times to zero
(default=True)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>return_averaged_R<span class="classifier">bool [optional]</span></dt><dd><p>If set to True, compute R̂tot as the average over R̂(T ) for T ∈ [T̂D, Tmax ] instead of
R̂tot = R(T̂D ). If set to True, the setting for number_of_bootstraps_R_tot is ignored and
set to 0
(default=True)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">bayesian_bias_criterion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R_nsb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R_plugin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bbc_tolerance</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltBBCEstimator.bayesian_bias_criterion"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Get whether the Bayesian bias criterion (bbc) is passed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R_nsb</strong> – history dependence computed with NSB estimator</p></li>
<li><p><strong>R_plugin</strong> – history dependence computed with plugin estimator</p></li>
<li><p><strong>bbc_tolerance</strong> – tolerance for the Bayesian bias criterion</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">past_symbol_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_symbol_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bbc_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltBBCEstimator.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate the mutual information (MI) of one variable depending on its past
using nsb and plugin estimator and check if bias criterion is passed/</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>symbol_array<span class="classifier">1D numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
<dt>past_symbol_array<span class="classifier">numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
<dt>current_symbol_array<span class="classifier">numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>I (float)</dt><dd><p>MI (AIS)</p>
</dd>
<dt>R (float)</dt><dd><p>MI / H_uncond (History dependence)</p>
</dd>
<dt>bbc_term (float)</dt><dd><p>bbc tolerance-independent term of the Bayesian bias
criterion (bbc)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_bbc_term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R_nsb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R_plugin</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltBBCEstimator.get_bbc_term"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Get the bbc tolerance-independent term of the Bayesian bias
criterion (bbc).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R_nsb</strong> – history dependence computed with NSB estimator</p></li>
<li><p><strong>R_plugin</strong> – history dependence computed with plugin estimator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_Rudelt.</span></span><span class="sig-name descname"><span class="pre">RudeltNSBEstimatorSymbolsMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltNSBEstimatorSymbolsMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>History dependence NSB estimator</p>
<p>Calculate the mutual information (MI) of one variable depending on its past
using NSB estimator. See parent class for references.</p>
<p>implemented in idtxl by Michael Lindner, Göttingen 2021</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><ul class="simple">
<li><dl class="simple">
<dt>embedding_step_size<span class="classifier">float [optional]</span></dt><dd><p>Step size delta t (in seconds) with which the window is slid through the data
(default = 0.005).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>normalise<span class="classifier">bool [optional]</span></dt><dd><p>rebase spike times to zero
(default=True)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>return_averaged_R<span class="classifier">bool [optional]</span></dt><dd><p>If set to True, compute R̂tot as the average over R̂(T ) for T ∈ [T̂D, Tmax ] instead of
R̂tot = R(T̂D ). If set to True, the setting for number_of_bootstraps_R_tot is ignored and
set to 0
(default=True)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">past_symbol_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_symbol_array</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltNSBEstimatorSymbolsMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate mutual information using NSB estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>symbol_array<span class="classifier">1D numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
<dt>past_symbol_array<span class="classifier">numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
<dt>current_symbol_array<span class="classifier">numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>I (float)</dt><dd><p>MI (AIS)</p>
</dd>
<dt>R (float)</dt><dd><p>MI / H_uncond (History dependence)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">nsb_estimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">past_symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphabet_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphabet_size_past</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H_uncond</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltNSBEstimatorSymbolsMI.nsb_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate the entropy of a system using the NSB estimator.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_Rudelt.</span></span><span class="sig-name descname"><span class="pre">RudeltPluginEstimatorSymbolsMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltPluginEstimatorSymbolsMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Plugin History dependence estimator</p>
<p>Calculate the mutual information (MI) of one variable depending on its past
using plugin estimator. See parent class for references.</p>
<p>implemented in idtxl by Michael Lindner, Göttingen 2021</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><ul class="simple">
<li><dl class="simple">
<dt>embedding_step_size<span class="classifier">float [optional] - Step size delta t (in seconds) with which the window is slid</span></dt><dd><p>through the data (default = 0.005).</p>
</dd>
</dl>
</li>
<li><p>normalise : bool [optional] - rebase spike times to zero (default=True)</p></li>
<li><p>return_averaged_R : bool [optional] - rebase spike times to zero (default=True)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">past_symbol_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_symbol_array</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltPluginEstimatorSymbolsMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate mutual information using plugin estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>symbol_array<span class="classifier">1D numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
<dt>past_symbol_array<span class="classifier">numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
<dt>current_symbol_array<span class="classifier">numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>I (float)</dt><dd><p>MI (AIS)</p>
</dd>
<dt>R (float)</dt><dd><p>MI / H_uncond (History dependence)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">plugin_entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltPluginEstimatorSymbolsMI.plugin_entropy"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate the entropy of a system using the Plugin estimator.</p>
<p>(In principle this is the same function as utl.get_shannon_entropy,
only here it is a function of the multiplicities, not the probabilities.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mk</strong> – multiplicities</p></li>
<li><p><strong>N</strong> – total number of observed symbols</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">plugin_estimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">past_symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphabet_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphabet_size_past</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H_uncond</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltPluginEstimatorSymbolsMI.plugin_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate the entropy of a system using the BBC estimator.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_Rudelt.</span></span><span class="sig-name descname"><span class="pre">RudeltShufflingEstimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate the history dependence in a spike train using the shuffling estimator.</p>
<p>See parent class for references.</p>
<p>implemented in idtxl by Michael Lindner, Göttingen 2021</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_array</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate the history dependence in a spike train using the shuffling estimator.</p>
<blockquote>
<div><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>symbol_array<span class="classifier">1D numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>I (float)</dt><dd><p>MI (AIS)</p>
</dd>
<dt>R (float)</dt><dd><p>MI / H_uncond (History dependence)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_H0_X_past_cond_X</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">marginal_probabilities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P_X_uncond</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_H0_X_past_cond_X"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute H_0(X_past | X), the estimate of the entropy for the past
symbols given a response, under the assumption that activity in
the past contributes independently towards the response.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_H0_X_past_cond_X_eq_x</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">marginal_probabilities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_H0_X_past_cond_X_eq_x"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute H_0(X_past | X = x), cf get_H0_X_past_cond_X.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_H_X_past_cond_X</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P_X_uncond</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P_X_past_cond_X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_H_X_past_cond_X"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute H(X_past | X), the plug-in estimate of the conditional entropy for the past
symbols, conditioned on the response X,  given their probabilities.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_H_X_past_uncond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P_X_past_uncond</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_H_X_past_uncond"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute H(X_past), the plug-in estimate of the entropy for the past symbols, given
their probabilities.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_P_X_past_cond_X</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">past_symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_symbols</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_P_X_past_cond_X"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute P(X_past | X), the probability of the past activity conditioned
on the response X using the plug-in estimator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_P_X_past_uncond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">past_symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_symbols</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_P_X_past_uncond"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute P(X_past), the probability of the past activity using
the plug-in estimator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_P_X_uncond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_of_symbols</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_P_X_uncond"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute P(X), the probability of the current activity using
the plug-in estimator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_marginal_frequencies_of_spikes_in_bins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_marginal_frequencies_of_spikes_in_bins"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute for each past bin 1…d the sum of spikes found in that bin across all
observed symbols.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_shuffled_symbol_counts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">past_symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_symbols</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_shuffled_symbol_counts"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Simulate new data by, for each past bin 1…d, permutating the activity
across all observed past_symbols (for a given response X). The marginal
probability of observing a spike given the response is thus preserved for
each past bin.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">shuffling_MI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.shuffling_MI"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate the mutual information between current and past activity
in a spike train using the shuffling estimator.</p>
<p>To obtain the shuffling estimate, compute the plug-in estimate and
a correction term to reduce its bias.</p>
<p>For the plug-in estimate:</p>
<ul class="simple">
<li><p>Extract the past_symbol_counts from the symbol_counts.</p></li>
<li><p>I_plugin = H(X_past) - H(X_past | X)</p></li>
</ul>
<p>Notation:</p>
<ul class="simple">
<li><p>X: current activity, aka response</p></li>
<li><p>X_past: past activity</p></li>
<li><p>P_X_uncond: P(X)</p></li>
<li><p>P_X_past_uncond: P(X_past)</p></li>
<li><p>P_X_past_cond_X: P(X_past | X)</p></li>
<li><p>H_X_past_uncond: H(X_past)</p></li>
<li><p>H_X_past_cond_X: H(X_past | X)</p></li>
<li><p>I_plugin: plugin estimate of I(X_past; X)</p></li>
</ul>
<p>For the correction term:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Simulate additional data under the assumption that activity</dt><dd><p>in the past contributes independently towards the current activity.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Compute the entropy under the assumptions of the model, which</dt><dd><p>due to its simplicity is easy to sample and the estimate unbiased</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Compute the entropy using the plug-in estimate, whose bias is</dt><dd><p>similar to that of the plug-in estimate on the original data</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Compute the correction term as the difference between the</dt><dd><p>unbiased and biased terms</p>
</dd>
</dl>
</li>
</ul>
<p>Notation:</p>
<ul class="simple">
<li><p>P0_sh_X_past_cond_X: P_0,sh(X_past | X), equiv. to P(X_past | X)
on the shuffled data</p></li>
<li><p>H0_X_past_cond_X: H_0(X_past | X), based on the model of independent
contributions</p></li>
<li><p>H0_sh_X_past_cond_X: H_0,sh(X_past | X), based on</p></li>
<li><p>P0_sh_X_past_cond_X, ie the plug-in estimate</p></li>
<li><p>I_corr: the correction term to reduce the bias of I_plugin</p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>symbol_counts<span class="classifier">iterable</span></dt><dd><p>the activity of a spike train is embedded into symbols,
whose occurrences are counted (cf emb.get_symbol_counts)</p>
</dd>
<dt>number_of_bins_d<span class="classifier">int</span></dt><dd><p>the number of bins of the embedding</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Algorithms for the analysis of node dynamics</a><ul>
<li><a class="reference internal" href="#active-information-storage-ais">Active Information Storage (AIS)</a></li>
<li><a class="reference internal" href="#multivariate-partial-information-decomposition-pid">Multivariate Partial Information Decomposition (PID)</a></li>
<li><a class="reference internal" href="#bivariate-partial-information-decomposition-pid">Bivariate Partial Information Decomposition (PID)</a></li>
<li><a class="reference internal" href="#history-dependence-estimator-for-neural-spiking-data">History-dependence estimator for neural spiking data</a><ul>
<li><a class="reference internal" href="#embedding-optimization">Embedding optimization</a></li>
<li><a class="reference internal" href="#estimators">Estimators</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="idtxl_network_inference.html"
                          title="previous chapter">Algorithms for network inference</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="idtxl_network_comparison.html"
                          title="next chapter">Network comparison</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/idtxl_process_analysis.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="idtxl_network_comparison.html" title="Network comparison"
             >next</a> |</li>
        <li class="right" >
          <a href="idtxl_network_inference.html" title="Algorithms for network inference"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">IDTxl 1.5.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Algorithms for the analysis of node dynamics</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Patricia Wollstadt, Joseph T. Lizier, Raul Vicente, Conor Finn, Mario Martinez-Zarzuela, Pedro Mediano, Leonardo Novelli, Michael Wibral.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>