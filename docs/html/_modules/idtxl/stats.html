
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>idtxl.stats &#8212; IDTxl 1.5.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/pyramid.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">IDTxl 1.5.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">idtxl.stats</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for idtxl.stats</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Provide statistics functions.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">copy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">idtxl_utils</span> <span class="k">as</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">idtxl_exceptions</span> <span class="k">as</span> <span class="n">ex</span>


<div class="viewcode-block" id="ais_fdr"><a class="viewcode-back" href="../../idtxl_helper.html#idtxl.stats.ais_fdr">[docs]</a><span class="k">def</span> <span class="nf">ais_fdr</span><span class="p">(</span><span class="n">settings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">results</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform FDR-correction on results of network AIS estimation.</span>

<span class="sd">    Perform correction of the false discovery rate (FDR) after estimation of</span>
<span class="sd">    active information storage (AIS) for all processes in the network. FDR</span>
<span class="sd">    correction is applied by correcting the AIS estimate&#39;s omnibus p-values for</span>
<span class="sd">    individual processes/nodes in the network.</span>

<span class="sd">    Input can be a list of partial results to combine results from parallel</span>
<span class="sd">    analysis.</span>

<span class="sd">    References:</span>

<span class="sd">    - Genovese, C.R., Lazar, N.A., &amp; Nichols, T. (2002). Thresholding of</span>
<span class="sd">      statistical maps in functional neuroimaging using the false discovery</span>
<span class="sd">      rate. Neuroimage, 15(4), 870-878.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings : dict [optional]</span>
<span class="sd">            parameters for statistical testing with entries:</span>

<span class="sd">            - alpha_fdr : float [optional] - critical alpha level</span>
<span class="sd">              (default=0.05)</span>
<span class="sd">            - fdr_constant : int [optional] - choose one of two constants used</span>
<span class="sd">              for calculating the FDR-thresholds according to Genovese (2002):</span>
<span class="sd">              1 will divide alpha by 1, 2 will divide alpha by the sum_i(1/i);</span>
<span class="sd">              see the paper for details on the assumptions (default=2)</span>

<span class="sd">        results : instances of ResultsSingleProcessAnalysis</span>
<span class="sd">            results of network AIS estimation, see documentation of</span>
<span class="sd">            ResultsSingleProcessAnalysis()</span>

<span class="sd">    Returns:</span>
<span class="sd">        ResultsSingleProcessAnalysis instance</span>
<span class="sd">            input results objects pruned of non-significant estimates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">settings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Set defaults and get parameters from settings dictionary</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;alpha_fdr&quot;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">constant</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fdr_constant&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Combine results into single results dict.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">results_comb</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">results_comb</span><span class="o">.</span><span class="n">combine_results</span><span class="p">(</span><span class="o">*</span><span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">results_comb</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Collect p-values of whole processes (determined by the omnibus test).</span>
    <span class="n">pval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">process_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">n_perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">results_comb</span><span class="o">.</span><span class="n">processes_analysed</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">results_comb</span><span class="o">.</span><span class="n">_single_process</span><span class="p">[</span><span class="n">process</span><span class="p">]</span><span class="o">.</span><span class="n">ais_sign</span><span class="p">:</span>
            <span class="n">pval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pval</span><span class="p">,</span> <span class="n">results_comb</span><span class="o">.</span><span class="n">_single_process</span><span class="p">[</span><span class="n">process</span><span class="p">]</span><span class="o">.</span><span class="n">ais_pval</span><span class="p">)</span>
            <span class="n">process_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">process_idx</span><span class="p">,</span> <span class="n">process</span><span class="p">)</span>
            <span class="n">n_perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_perm</span><span class="p">,</span> <span class="n">results_comb</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">n_perm_mi</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pval</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;FDR correction: no links in final results ...</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">results_comb</span><span class="o">.</span><span class="n">_add_fdr</span><span class="p">(</span><span class="n">fdr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="n">constant</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results_comb</span>

    <span class="n">sign</span><span class="p">,</span> <span class="n">thresh</span> <span class="o">=</span> <span class="n">_perform_fdr_corretion</span><span class="p">(</span><span class="n">pval</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>

    <span class="c1"># If the number of permutations for calculating p-values for individual</span>
    <span class="c1"># variables is too low, return without performing any correction.</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_perm</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;WARNING: Number of permutations (&quot;</span>
            <span class="s2">&quot;n_perm_max_seq&quot;</span>
            <span class="s2">&quot;) for at &quot;</span>
            <span class="s2">&quot;least one target is too low to allow for FDR correction &quot;</span>
            <span class="s2">&quot;(FDR-threshold: </span><span class="si">{0:.4f}</span><span class="s2">, min. theoretically possible p-value: &quot;</span>
            <span class="s2">&quot;</span><span class="si">{1}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thresh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_perm</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">results_comb</span><span class="o">.</span><span class="n">_add_fdr</span><span class="p">(</span><span class="n">fdr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="n">constant</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results_comb</span>

    <span class="c1"># Go over list of all candidates and remove non-significant results from</span>
    <span class="c1"># the results object. Create a copy of the results object to leave the</span>
    <span class="c1"># original intact.</span>
    <span class="n">fdr</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">results_comb</span><span class="o">.</span><span class="n">_single_process</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sign</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sign</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">process_idx</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="n">fdr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">selected_vars</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">fdr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">ais_pval</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">fdr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">ais_sign</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">results_comb</span><span class="o">.</span><span class="n">_add_fdr</span><span class="p">(</span><span class="n">fdr</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">constant</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results_comb</span></div>


<div class="viewcode-block" id="network_fdr"><a class="viewcode-back" href="../../idtxl_helper.html#idtxl.stats.network_fdr">[docs]</a><span class="k">def</span> <span class="nf">network_fdr</span><span class="p">(</span><span class="n">settings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">results</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform FDR-correction on results of network inference.</span>

<span class="sd">    Perform correction of the false discovery rate (FDR) after network</span>
<span class="sd">    analysis. FDR correction can either be applied at the target level</span>
<span class="sd">    (by correcting omnibus p-values) or at the single-link level (by correcting</span>
<span class="sd">    p-values of individual links between single samples and the target).</span>

<span class="sd">    Input can be a list of partial results to combine results from parallel</span>
<span class="sd">    analysis.</span>

<span class="sd">    References:</span>

<span class="sd">    - Genovese, C.R., Lazar, N.A., &amp; Nichols, T. (2002). Thresholding of</span>
<span class="sd">      statistical maps in functional neuroimaging using the false discovery</span>
<span class="sd">      rate. Neuroimage, 15(4), 870-878.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings : dict [optional]</span>
<span class="sd">            parameters for statistical testing with entries:</span>

<span class="sd">            - alpha_fdr : float [optional] - critical alpha level</span>
<span class="sd">              (default=0.05)</span>
<span class="sd">            - correct_by_target : bool [optional] - if true correct p-values on</span>
<span class="sd">              on the target level (omnibus test p-values), otherwise correct</span>
<span class="sd">              p_values for individual variables (sequential max stats p-values)</span>
<span class="sd">              (default=True)</span>
<span class="sd">            - fdr_constant : int [optional] - choose one of two constants used</span>
<span class="sd">              for calculating the FDR-thresholds according to Genovese (2002):</span>
<span class="sd">              1 will divide alpha by 1, 2 will divide alpha by the sum_i(1/i);</span>
<span class="sd">              see the paper for details on the assumptions (default=2)</span>

<span class="sd">        results : instances of ResultsNetworkInference</span>
<span class="sd">            results of network inference, see documentation of</span>
<span class="sd">            ResultsNetworkInference()</span>

<span class="sd">    Returns:</span>
<span class="sd">        ResultsNetworkInference instance</span>
<span class="sd">            input object pruned of non-significant links</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">settings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Set defaults and get parameters from settings dictionary</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;alpha_fdr&quot;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">correct_by_target</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;correct_by_target&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">constant</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fdr_constant&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Combine results into single results dict.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">results_comb</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">results_comb</span><span class="o">.</span><span class="n">combine_results</span><span class="p">(</span><span class="o">*</span><span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">results_comb</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Collect significant source variables for all targets. Either correct</span>
    <span class="c1"># p-value of whole target (all candidates), or correct p-value of</span>
    <span class="c1"># individual source variables. Use targets with significant input only</span>
    <span class="c1"># (determined by the omnibus test).</span>
    <span class="n">pval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">target_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">n_perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">cands</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">correct_by_target</span><span class="p">:</span>  <span class="c1"># whole target</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">results_comb</span><span class="o">.</span><span class="n">targets_analysed</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">results_comb</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">omnibus_sign</span><span class="p">:</span>
                <span class="n">pval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pval</span><span class="p">,</span> <span class="n">results_comb</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">omnibus_pval</span><span class="p">)</span>
                <span class="n">target_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_idx</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
                <span class="n">n_perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_perm</span><span class="p">,</span> <span class="n">results_comb</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">n_perm_omnibus</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># individual variables</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">results_comb</span><span class="o">.</span><span class="n">targets_analysed</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">results_comb</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">omnibus_sign</span><span class="p">:</span>
                <span class="n">n_sign</span> <span class="o">=</span> <span class="n">results_comb</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">selected_sources_pval</span><span class="o">.</span><span class="n">size</span>
                <span class="n">pval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">pval</span><span class="p">,</span> <span class="p">(</span><span class="n">results_comb</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">selected_sources_pval</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">target_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_sign</span><span class="p">)</span> <span class="o">*</span> <span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">cands</span> <span class="o">=</span> <span class="n">cands</span> <span class="o">+</span> <span class="p">(</span>
                    <span class="n">results_comb</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">selected_vars_sources</span>
                <span class="p">)</span>
                <span class="n">n_perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_perm</span><span class="p">,</span> <span class="n">results_comb</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">n_perm_max_seq</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pval</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No links in final results ...&quot;</span><span class="p">)</span>
        <span class="n">results_comb</span><span class="o">.</span><span class="n">_add_fdr</span><span class="p">(</span>
            <span class="n">fdr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">correct_by_target</span><span class="o">=</span><span class="n">correct_by_target</span><span class="p">,</span>
            <span class="n">constant</span><span class="o">=</span><span class="n">constant</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">results_comb</span>

    <span class="n">sign</span><span class="p">,</span> <span class="n">thresh</span> <span class="o">=</span> <span class="n">_perform_fdr_corretion</span><span class="p">(</span><span class="n">pval</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>

    <span class="c1"># If the number of permutations for calculating p-values for individual</span>
    <span class="c1"># variables is too low, return without performing any correction.</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_perm</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;WARNING: Number of permutations (&quot;</span>
            <span class="s2">&quot;n_perm_max_seq&quot;</span>
            <span class="s2">&quot;) for at &quot;</span>
            <span class="s2">&quot;least one target is too low to allow for FDR correction &quot;</span>
            <span class="s2">&quot;(FDR-threshold: </span><span class="si">{0:.4f}</span><span class="s2">, min. theoretically possible p-value: &quot;</span>
            <span class="s2">&quot;</span><span class="si">{1}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thresh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_perm</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">results_comb</span><span class="o">.</span><span class="n">_add_fdr</span><span class="p">(</span>
            <span class="n">fdr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">correct_by_target</span><span class="o">=</span><span class="n">correct_by_target</span><span class="p">,</span>
            <span class="n">constant</span><span class="o">=</span><span class="n">constant</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">results_comb</span>

    <span class="c1"># Go over list of all candidates and remove non-significant results from</span>
    <span class="c1"># the results object. Create a copy of the results object to leave the</span>
    <span class="c1"># original intact.</span>
    <span class="n">fdr</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">results_comb</span><span class="o">.</span><span class="n">_single_target</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sign</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sign</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">correct_by_target</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">target_idx</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="n">fdr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">selected_vars_full</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span>
                    <span class="n">results_comb</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">selected_vars_target</span>
                <span class="p">)</span>
                <span class="n">fdr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">selected_sources_te</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fdr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">selected_sources_pval</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fdr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">selected_vars_sources</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">fdr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">omnibus_pval</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">fdr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">omnibus_sign</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">target_idx</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="n">cand</span> <span class="o">=</span> <span class="n">cands</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="n">cand_ind</span> <span class="o">=</span> <span class="n">fdr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cand</span><span class="p">)</span>
                <span class="n">fdr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">cand_ind</span><span class="p">)</span>
                <span class="n">fdr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">selected_sources_pval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
                    <span class="n">fdr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">selected_sources_pval</span><span class="p">,</span> <span class="n">cand_ind</span>
                <span class="p">)</span>
                <span class="n">fdr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">selected_sources_te</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
                    <span class="n">fdr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">selected_sources_te</span><span class="p">,</span> <span class="n">cand_ind</span>
                <span class="p">)</span>
                <span class="n">fdr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">selected_vars_full</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">fdr</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">selected_vars_full</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cand</span><span class="p">))</span>
    <span class="n">results_comb</span><span class="o">.</span><span class="n">_add_fdr</span><span class="p">(</span><span class="n">fdr</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">correct_by_target</span><span class="p">,</span> <span class="n">constant</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results_comb</span></div>


<span class="k">def</span> <span class="nf">_perform_fdr_corretion</span><span class="p">(</span><span class="n">pval</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate sequential threshold for FDR-correction.</span>

<span class="sd">    Calculate sequential thresholds for FDR-correction of p-values. The</span>
<span class="sd">    constant defines how the threshold is calculated. See Genovese (2002) for</span>
<span class="sd">    details.</span>

<span class="sd">    References:</span>

<span class="sd">    - Genovese, C.R., Lazar, N.A., &amp; Nichols, T. (2002). Thresholding of</span>
<span class="sd">      statistical maps in functional neuroimaging using the false discovery</span>
<span class="sd">      rate. Neuroimage, 15(4), 870-878.</span>

<span class="sd">    Args:</span>
<span class="sd">        pval : numpy array</span>
<span class="sd">            p-values to be corrected</span>
<span class="sd">        alpha : float</span>
<span class="sd">            critical alpha level</span>
<span class="sd">        fdr_constant : int</span>
<span class="sd">            one of two constants used for calculating the FDR-thresholds</span>
<span class="sd">            according to Genovese (2002): 1 will divide alpha by 1, 2 will</span>
<span class="sd">            divide alpha by the sum_i(1/i); see the paper for details on the</span>
<span class="sd">            assumptions (default=2)</span>

<span class="sd">    Returns:</span>
<span class="sd">        array of bools</span>
<span class="sd">            significance of p-values</span>
<span class="sd">        array of floats</span>
<span class="sd">            FDR-thresholds for each p-value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Sort all p-values in ascending order.</span>
    <span class="n">sort_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">pval</span><span class="p">)</span>
    <span class="n">pval</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="c1"># Calculate threshold</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">pval</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="n">constant</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># pick the requested constant (see Genovese, p.872)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span>
            <span class="n">const</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span>  <span class="c1"># aprx. harmonic sum with Euler&#39;s number</span>
    <span class="k">elif</span> <span class="n">constant</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># This is less strict than the other one and corresponds to a</span>
        <span class="c1"># Bonoferroni-correction for the first p-value, however, it makes more</span>
        <span class="c1"># strict assumptions on the distribution of p-values, while constant 2</span>
        <span class="c1"># works for any joint distribution of the p-values.</span>
        <span class="n">const</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">thresh</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">/</span> <span class="n">const</span>

    <span class="c1"># Compare data to threshold.</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="n">pval</span> <span class="o">&lt;=</span> <span class="n">thresh</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">sign</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">first_false</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">sign</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sign</span><span class="p">[</span><span class="n">first_false</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># avoids false positives due to equal pvals</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="n">sign</span><span class="p">[</span><span class="n">sort_idx</span><span class="p">]</span>  <span class="c1"># restore original ordering of significance values</span>
    <span class="k">return</span> <span class="n">sign</span><span class="p">,</span> <span class="n">thresh</span>


<div class="viewcode-block" id="omnibus_test"><a class="viewcode-back" href="../../idtxl_helper.html#idtxl.stats.omnibus_test">[docs]</a><span class="k">def</span> <span class="nf">omnibus_test</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform an omnibus test on identified conditional variables.</span>

<span class="sd">    Test the joint information transfer from all identified sources to the</span>
<span class="sd">    current value conditional on candidates in the target&#39;s past. To test for</span>
<span class="sd">    significance, this is repeated for shuffled realisations of the sources.</span>
<span class="sd">    The distribution of values from shuffled data is then used as test</span>
<span class="sd">    distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        analysis_setup : MultivariateTE instance</span>
<span class="sd">            information on the current analysis, can have an optional attribute</span>
<span class="sd">            &#39;settings&#39;, a dictionary with parameters for statistical testing:</span>

<span class="sd">            - n_perm_omnibus : int [optional] - number of permutations</span>
<span class="sd">              (default=500)</span>
<span class="sd">            - alpha_omnibus : float [optional] - critical alpha level</span>
<span class="sd">              (default=0.05)</span>
<span class="sd">            - permute_in_time : bool [optional] - generate surrogates by</span>
<span class="sd">              shuffling samples in time instead of shuffling whole replications</span>
<span class="sd">              (default=False)</span>

<span class="sd">        data : Data instance</span>
<span class="sd">            raw data</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance</span>
<span class="sd">        float</span>
<span class="sd">            the test&#39;s p-value</span>
<span class="sd">        float</span>
<span class="sd">            the estimated test statisic, i.e., the information transfer from</span>
<span class="sd">            all sources into the target</span>

<span class="sd">    Raises:</span>
<span class="sd">        ex.AlgorithmExhaustedError</span>
<span class="sd">            Raised from estimate() calls when calculation cannot be made</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set defaults and get parameters from settings dictionary</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;n_perm_omnibus&quot;</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
    <span class="n">n_permutations</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;n_perm_omnibus&quot;</span><span class="p">]</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;alpha_omnibus&quot;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;alpha_omnibus&quot;</span><span class="p">]</span>
    <span class="n">permute_in_time</span> <span class="o">=</span> <span class="n">_check_permute_in_time</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_permutations</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">,</span> <span class="s2">&quot;No sources to test.&quot;</span>

    <span class="c1"># Create temporary variables b/c realisations for sources and targets are</span>
    <span class="c1"># created on the fly, which is costly, so we want to re-use them after</span>
    <span class="c1"># creation. (This does not apply to the current value realisations).</span>
    <span class="c1"># If there was no target variable selected (e.g., if MI is used for network</span>
    <span class="c1"># inference), set conditional to None such that the MI instead of the CMI</span>
    <span class="c1"># estimator is used when calculating the statistic.</span>
    <span class="n">cond_source_realisations</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_selected_vars_sources_realisations</span>
    <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_selected_vars_target</span><span class="p">:</span>
        <span class="n">cond_target_realisations</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_selected_vars_target_realisations</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cond_target_realisations</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">statistic</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span>
        <span class="n">var1</span><span class="o">=</span><span class="n">cond_source_realisations</span><span class="p">,</span>
        <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span><span class="p">,</span>
        <span class="n">conditional</span><span class="o">=</span><span class="n">cond_target_realisations</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Create the surrogate distribution by permuting the conditional sources.</span>
    <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;verbose&quot;</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;omnibus test, n_perm: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_permutations</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">is_analytic_null_estimator</span><span class="p">()</span> <span class="ow">and</span> <span class="n">permute_in_time</span><span class="p">:</span>
        <span class="c1"># Generate the surrogates analytically</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;analytical_surrogates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">surr_distribution</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate_surrogates_analytic</span><span class="p">(</span>
            <span class="n">n_perm</span><span class="o">=</span><span class="n">n_permutations</span><span class="p">,</span>
            <span class="n">var1</span><span class="o">=</span><span class="n">cond_source_realisations</span><span class="p">,</span>
            <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span><span class="p">,</span>
            <span class="n">conditional</span><span class="o">=</span><span class="n">cond_target_realisations</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;analytical_surrogates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">surr_cond_real</span> <span class="o">=</span> <span class="n">_get_surrogates</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">,</span>
            <span class="n">n_permutations</span><span class="p">,</span>
            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">surr_distribution</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate_parallel</span><span class="p">(</span>
            <span class="n">n_chunks</span><span class="o">=</span><span class="n">n_permutations</span><span class="p">,</span>
            <span class="n">re_use</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;var2&quot;</span><span class="p">,</span> <span class="s2">&quot;conditional&quot;</span><span class="p">],</span>
            <span class="n">var1</span><span class="o">=</span><span class="n">surr_cond_real</span><span class="p">,</span>
            <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span><span class="p">,</span>
            <span class="n">conditional</span><span class="o">=</span><span class="n">cond_target_realisations</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">[</span><span class="n">significance</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span>
        <span class="n">statistic</span><span class="p">,</span> <span class="n">surr_distribution</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="s2">&quot;one_bigger&quot;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;verbose&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">significance</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; -- significant</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; -- not significant</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">significance</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">,</span> <span class="n">statistic</span></div>


<div class="viewcode-block" id="max_statistic"><a class="viewcode-back" href="../../idtxl_helper.html#idtxl.stats.max_statistic">[docs]</a><span class="k">def</span> <span class="nf">max_statistic</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">candidate_set</span><span class="p">,</span> <span class="n">te_max_candidate</span><span class="p">,</span> <span class="n">conditional</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform maximum statistics for one candidate source.</span>

<span class="sd">    Test if a transfer entropy value is significantly bigger than the maximum</span>
<span class="sd">    values obtained from surrogates of all remanining candidates.</span>

<span class="sd">    Args:</span>
<span class="sd">        analysis_setup : MultivariateTE instance</span>
<span class="sd">            information on the current analysis, can have an optional attribute</span>
<span class="sd">            &#39;settings&#39;, a dictionary with parameters for statistical testing:</span>

<span class="sd">            - n_perm_max_stat : int [optional] - number of permutations</span>
<span class="sd">              (default=200)</span>
<span class="sd">            - alpha_max_stat : float [optional] - critical alpha level</span>
<span class="sd">              (default=0.05)</span>
<span class="sd">            - permute_in_time : bool [optional] - generate surrogates by</span>
<span class="sd">              shuffling samples in time instead of shuffling whole replications</span>
<span class="sd">              (default=False)</span>

<span class="sd">        data : Data instance</span>
<span class="sd">            raw data</span>
<span class="sd">        candidate_set : list of tuples</span>
<span class="sd">            list of indices of remaning candidates</span>
<span class="sd">        te_max_candidate : float</span>
<span class="sd">            transfer entropy value to be tested</span>
<span class="sd">        conditional : numpy array</span>
<span class="sd">            realisations of conditional, 2D numpy array where array dimensions</span>
<span class="sd">            represent [realisations x variable dimension]</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance</span>
<span class="sd">        float</span>
<span class="sd">            the test&#39;s p-value</span>
<span class="sd">        numpy array</span>
<span class="sd">            surrogate table</span>

<span class="sd">    Raises:</span>
<span class="sd">        ex.AlgorithmExhaustedError</span>
<span class="sd">            Raised from _create_surrogate_table() when calculation cannot be</span>
<span class="sd">            made</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set defaults and get parameters from settings dictionary</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;n_perm_max_stat&quot;</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
    <span class="n">n_perm</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;n_perm_max_stat&quot;</span><span class="p">]</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;alpha_max_stat&quot;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;alpha_max_stat&quot;</span><span class="p">]</span>
    <span class="n">_check_permute_in_time</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">candidate_set</span><span class="p">,</span> <span class="s2">&quot;The candidate set is empty.&quot;</span>
    <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;verbose&quot;</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;maximum statistic, n_perm: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;n_perm_max_stat&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># todo pass correct conditioning set</span>
    <span class="n">surr_table</span> <span class="o">=</span> <span class="n">_create_surrogate_table</span><span class="p">(</span>
        <span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">candidate_set</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">,</span> <span class="n">conditional</span>
    <span class="p">)</span>
    <span class="n">max_distribution</span> <span class="o">=</span> <span class="n">_find_table_max</span><span class="p">(</span><span class="n">surr_table</span><span class="p">)</span>
    <span class="p">[</span><span class="n">significance</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span>
        <span class="n">statistic</span><span class="o">=</span><span class="n">te_max_candidate</span><span class="p">,</span>
        <span class="n">distribution</span><span class="o">=</span><span class="n">max_distribution</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
        <span class="n">tail</span><span class="o">=</span><span class="s2">&quot;one_bigger&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">significance</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">,</span> <span class="n">surr_table</span></div>


<div class="viewcode-block" id="max_statistic_sequential"><a class="viewcode-back" href="../../idtxl_helper.html#idtxl.stats.max_statistic_sequential">[docs]</a><span class="k">def</span> <span class="nf">max_statistic_sequential</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform sequential maximum statistics for a set of candidate sources.</span>

<span class="sd">    Test multivariate/bivariate MI/TE values against surrogates. Test highest</span>
<span class="sd">    TE/MI value against distribution of highest surrogate values, second</span>
<span class="sd">    highest against distribution of second highest, and so forth. Surrogates</span>
<span class="sd">    are created from each candidate in the candidate set, including the</span>
<span class="sd">    candidate that is currently tested. Surrogates are then sorted over</span>
<span class="sd">    candidates. This is repeated n_perm_max_seq times. Stop comparison if a</span>
<span class="sd">    TE/MI value is not significant compared to the distribution of surrogate</span>
<span class="sd">    values of the same rank. All smaller values are considered non-significant</span>
<span class="sd">    as well.</span>

<span class="sd">    The conditional for estimation of MI/TE is taken from the current set of</span>
<span class="sd">    conditional variables in the analysis setup. For multivariate MI or TE</span>
<span class="sd">    surrogate creation, the full set of conditional variables is used. For</span>
<span class="sd">    bivariate MI or TE surrogate creation, the conditioning set has to be</span>
<span class="sd">    restricted to a subset of the current set of conditional variables: for</span>
<span class="sd">    bivariate MI no conditioning set is required, for bivariate TE only the</span>
<span class="sd">    past variables from the target are required (not the variables selected</span>
<span class="sd">    from other relevant sources).</span>

<span class="sd">    This function will re-use the surrogate table created in the last min-stats</span>
<span class="sd">    round if that table is in the analysis_setup. This saves the complete</span>
<span class="sd">    calculation of surrogates for this statistic.</span>

<span class="sd">    Args:</span>

<span class="sd">        analysis_setup : MultivariateTE instance</span>
<span class="sd">            information on the current analysis, can have an optional attribute</span>
<span class="sd">            &#39;settings&#39;, a dictionary with parameters for statistical testing:</span>

<span class="sd">            - n_perm_max_seq : int [optional] - number of permutations</span>
<span class="sd">              (default=&#39;n_perm_min_stat&#39;|500)</span>
<span class="sd">            - alpha_max_seq : float [optional] - critical alpha level</span>
<span class="sd">              (default=0.05)</span>
<span class="sd">            - permute_in_time : bool [optional] - generate surrogates by</span>
<span class="sd">              shuffling samples in time instead of shuffling whole replications</span>
<span class="sd">              (default=False)</span>

<span class="sd">        data : Data instance</span>
<span class="sd">            raw data</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy array, bool</span>
<span class="sd">            statistical significance of each source</span>
<span class="sd">        numpy array, float</span>
<span class="sd">            the test&#39;s p-values for each source</span>
<span class="sd">        numpy array, float</span>
<span class="sd">            TE values for individual sources</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set defaults and get test parameters.</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;n_perm_max_seq&quot;</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
    <span class="n">n_permutations</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;n_perm_max_seq&quot;</span><span class="p">]</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;alpha_max_seq&quot;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;alpha_max_seq&quot;</span><span class="p">]</span>
    <span class="n">_check_permute_in_time</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_permutations</span><span class="p">)</span>
    <span class="n">permute_in_time</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;permute_in_time&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;verbose&quot;</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;sequential maximum statistic, n_perm: </span><span class="si">{0}</span><span class="s2">, testing </span><span class="si">{1}</span><span class="s2"> selected&quot;</span>
            <span class="s2">&quot; sources&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_permutations</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">assert</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">,</span> <span class="s2">&quot;No sources to test.&quot;</span>

    <span class="n">idx_conditional</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_full</span>
    <span class="n">conditional_realisations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">data</span><span class="o">.</span><span class="n">n_realisations</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">)</span>
            <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">),</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">idx_conditional</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span>
    <span class="n">candidate_realisations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">data</span><span class="o">.</span><span class="n">n_realisations</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">)</span>
            <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">),</span>
            <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span>

    <span class="c1"># Calculate TE for each candidate in the conditional source set, i.e.,</span>
    <span class="c1"># calculate the conditional MI between each candidate and the current</span>
    <span class="c1"># value, conditional on all selected variables in the conditioning set,</span>
    <span class="c1"># excluding the current source. Calculate surrogates for each candidate by</span>
    <span class="c1"># shuffling the candidate realisations n_perm times. Afterwards, sort the</span>
    <span class="c1"># estimated TE values.</span>
    <span class="n">i_1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i_2</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">n_realisations</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">)</span>
    <span class="n">surr_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">),</span> <span class="n">n_permutations</span><span class="p">))</span>
    <span class="c1"># Collect data for each candidate and the corresponding conditioning set.</span>
    <span class="c1"># Use realisations for parallel estimation of the test statistic later.</span>
    <span class="k">for</span> <span class="n">idx_c</span><span class="p">,</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">):</span>
        <span class="p">[</span>
            <span class="n">conditional_realisations_current</span><span class="p">,</span>
            <span class="n">candidate_realisations_current</span><span class="p">,</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_separate_realisations</span><span class="p">(</span><span class="n">idx_conditional</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>

        <span class="c1"># The following may happen if either the requested conditing is &#39;none&#39;</span>
        <span class="c1"># or if the conditiong set that is tested consists only of a single</span>
        <span class="c1"># candidate.</span>
        <span class="k">if</span> <span class="n">conditional_realisations_current</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">conditional_realisations</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">re_use</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;var2&quot;</span><span class="p">,</span> <span class="s2">&quot;conditional&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">conditional_realisations</span><span class="p">[</span><span class="n">i_1</span><span class="p">:</span><span class="n">i_2</span><span class="p">,]</span> <span class="o">=</span> <span class="n">conditional_realisations_current</span>
            <span class="n">re_use</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;var2&quot;</span><span class="p">]</span>
        <span class="n">candidate_realisations</span><span class="p">[</span><span class="n">i_1</span><span class="p">:</span><span class="n">i_2</span><span class="p">,]</span> <span class="o">=</span> <span class="n">candidate_realisations_current</span>
        <span class="n">i_1</span> <span class="o">=</span> <span class="n">i_2</span>
        <span class="n">i_2</span> <span class="o">+=</span> <span class="n">data</span><span class="o">.</span><span class="n">n_realisations</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">)</span>

        <span class="c1"># Generate surrogates for the current candidate.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">is_analytic_null_estimator</span><span class="p">()</span>
            <span class="ow">and</span> <span class="n">permute_in_time</span>
        <span class="p">):</span>
            <span class="c1"># Generate the surrogates analytically</span>
            <span class="n">surr_table</span><span class="p">[</span>
                <span class="n">idx_c</span><span class="p">,</span> <span class="p">:</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate_surrogates_analytic</span><span class="p">(</span>
                <span class="n">n_perm</span><span class="o">=</span><span class="n">n_permutations</span><span class="p">,</span>
                <span class="n">var1</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span> <span class="p">[</span><span class="n">candidate</span><span class="p">])[</span>
                    <span class="mi">0</span>
                <span class="p">],</span>
                <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span><span class="p">,</span>
                <span class="n">conditional</span><span class="o">=</span><span class="n">conditional_realisations_current</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;analytical_surrogates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">surr_candidate_realisations</span> <span class="o">=</span> <span class="n">_get_surrogates</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
                <span class="p">[</span><span class="n">candidate</span><span class="p">],</span>
                <span class="n">n_permutations</span><span class="p">,</span>
                <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">surr_table</span><span class="p">[</span><span class="n">idx_c</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate_parallel</span><span class="p">(</span>
                    <span class="n">n_chunks</span><span class="o">=</span><span class="n">n_permutations</span><span class="p">,</span>
                    <span class="n">re_use</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;var2&quot;</span><span class="p">,</span> <span class="s2">&quot;conditional&quot;</span><span class="p">],</span>
                    <span class="n">var1</span><span class="o">=</span><span class="n">surr_candidate_realisations</span><span class="p">,</span>
                    <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span><span class="p">,</span>
                    <span class="n">conditional</span><span class="o">=</span><span class="n">conditional_realisations_current</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="n">ex</span><span class="o">.</span><span class="n">AlgorithmExhaustedError</span> <span class="k">as</span> <span class="n">aee</span><span class="p">:</span>
                <span class="c1"># The aglorithm cannot continue here, so</span>
                <span class="c1">#  we&#39;ll terminate the max sequential stats test,</span>
                <span class="c1">#  and declare all not significant</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;AlgorithmExhaustedError encountered in estimations: </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">aee</span><span class="o">.</span><span class="n">message</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Stopping sequential max stats at candidate with rank 0&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">)),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">)),</span>
                <span class="p">)</span>

    <span class="c1"># Calculate original statistic (multivariate/bivariate TE/MI)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">individual_stat</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate_parallel</span><span class="p">(</span>
            <span class="n">n_chunks</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">),</span>
            <span class="n">re_use</span><span class="o">=</span><span class="n">re_use</span><span class="p">,</span>
            <span class="n">var1</span><span class="o">=</span><span class="n">candidate_realisations</span><span class="p">,</span>
            <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span><span class="p">,</span>
            <span class="n">conditional</span><span class="o">=</span><span class="n">conditional_realisations</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="n">ex</span><span class="o">.</span><span class="n">AlgorithmExhaustedError</span> <span class="k">as</span> <span class="n">aee</span><span class="p">:</span>
        <span class="c1"># The aglorithm cannot continue here, so</span>
        <span class="c1">#  we&#39;ll terminate the max sequential stats test,</span>
        <span class="c1">#  and declare all not significant</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;AlgorithmExhaustedError encountered in estimations: </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">aee</span><span class="o">.</span><span class="n">message</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Stopping sequential max stats at candidate with rank 0&quot;</span><span class="p">)</span>
        <span class="c1"># For now we don&#39;t need a stack trace:</span>
        <span class="c1"># traceback.print_tb(aee.__traceback__)</span>
        <span class="c1"># Return (signficance, pvalue, TEs):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">)),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">)),</span>
        <span class="p">)</span>

    <span class="n">selected_vars_order</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">argsort_descending</span><span class="p">(</span><span class="n">individual_stat</span><span class="p">)</span>
    <span class="n">individual_stat_sorted</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sort_descending</span><span class="p">(</span><span class="n">individual_stat</span><span class="p">)</span>
    <span class="n">max_distribution</span> <span class="o">=</span> <span class="n">_sort_table_max</span><span class="p">(</span><span class="n">surr_table</span><span class="p">)</span>

    <span class="c1"># Compare each original value with the distribution of the same rank,</span>
    <span class="c1"># starting with the highest value.</span>
    <span class="n">significance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">individual_stat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">pvalue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">individual_stat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">individual_stat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span>
            <span class="n">individual_stat_sorted</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">max_distribution</span><span class="p">[</span><span class="n">c</span><span class="p">,],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="s2">&quot;one_bigger&quot;</span>
        <span class="p">)</span>
        <span class="n">significance</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">pvalue</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>  <span class="c1"># break as soon as a candidate is no longer significant</span>
            <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;verbose&quot;</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Stopping sequential max stats at candidate with rank &quot;</span>
                    <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">break</span>

    <span class="c1"># Get back original order and return results.</span>
    <span class="n">significance</span> <span class="o">=</span> <span class="n">significance</span><span class="p">[</span><span class="n">selected_vars_order</span><span class="p">]</span>
    <span class="n">pvalue</span> <span class="o">=</span> <span class="n">pvalue</span><span class="p">[</span><span class="n">selected_vars_order</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">significance</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">,</span> <span class="n">individual_stat</span></div>


<div class="viewcode-block" id="max_statistic_sequential_bivariate"><a class="viewcode-back" href="../../idtxl_helper.html#idtxl.stats.max_statistic_sequential_bivariate">[docs]</a><span class="k">def</span> <span class="nf">max_statistic_sequential_bivariate</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform sequential maximum statistics for a set of candidate sources.</span>

<span class="sd">    Test multivariate/bivariate MI/TE values against surrogates. Test highest</span>
<span class="sd">    TE/MI value against distribution of highest surrogate values, second</span>
<span class="sd">    highest against distribution of second highest, and so forth. Surrogates</span>
<span class="sd">    are created from each candidate in the candidate set, including the</span>
<span class="sd">    candidate that is currently tested. Surrogates are then sorted over</span>
<span class="sd">    candidates. This is repeated n_perm_max_seq times. Stop comparison if a</span>
<span class="sd">    TE/MI value is not significant compared to the distribution of surrogate</span>
<span class="sd">    values of the same rank. All smaller values are considered non-significant</span>
<span class="sd">    as well.</span>

<span class="sd">    The conditional for estimation of MI/TE is taken from the current set of</span>
<span class="sd">    conditional variables in the analysis setup. For multivariate MI or TE</span>
<span class="sd">    surrogate creation, the full set of conditional variables is used. For</span>
<span class="sd">    bivariate MI or TE surrogate creation, the conditioning set has to be</span>
<span class="sd">    restricted to a subset of the current set of conditional variables: for</span>
<span class="sd">    bivariate MI no conditioning set is required, for bivariate TE only the</span>
<span class="sd">    past variables from the target are required (not the variables selected</span>
<span class="sd">    from other relevant sources).</span>

<span class="sd">    This function will re-use the surrogate table created in the last min-stats</span>
<span class="sd">    round if that table is in the analysis_setup. This saves the complete</span>
<span class="sd">    calculation of surrogates for this statistic.</span>

<span class="sd">    Args:</span>

<span class="sd">        analysis_setup : MultivariateTE instance</span>
<span class="sd">            information on the current analysis, can have an optional attribute</span>
<span class="sd">            &#39;settings&#39;, a dictionary with parameters for statistical testing:</span>

<span class="sd">            - n_perm_max_seq : int [optional] - number of permutations</span>
<span class="sd">              (default=&#39;n_perm_min_stat&#39;|500)</span>
<span class="sd">            - alpha_max_seq : float [optional] - critical alpha level</span>
<span class="sd">              (default=0.05)</span>
<span class="sd">            - permute_in_time : bool [optional] - generate surrogates by</span>
<span class="sd">              shuffling samples in time instead of shuffling whole replications</span>
<span class="sd">              (default=False)</span>

<span class="sd">        data : Data instance</span>
<span class="sd">            raw data</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy array, bool</span>
<span class="sd">            statistical significance of each source</span>
<span class="sd">        numpy array, float</span>
<span class="sd">            the test&#39;s p-values for each source</span>
<span class="sd">        numpy array, float</span>
<span class="sd">            TE values for individual sources</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set defaults and get test parameters.</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;n_perm_max_seq&quot;</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
    <span class="n">n_permutations</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;n_perm_max_seq&quot;</span><span class="p">]</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;alpha_max_seq&quot;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;alpha_max_seq&quot;</span><span class="p">]</span>
    <span class="n">_check_permute_in_time</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_permutations</span><span class="p">)</span>
    <span class="n">permute_in_time</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;permute_in_time&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;verbose&quot;</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;sequential maximum statistic, n_perm: </span><span class="si">{0}</span><span class="s2">, testing </span><span class="si">{1}</span><span class="s2"> selected&quot;</span>
            <span class="s2">&quot; sources&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_permutations</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">assert</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">,</span> <span class="s2">&quot;No sources to test.&quot;</span>

    <span class="c1"># Check if target variables were selected to distinguish between TE and MI</span>
    <span class="c1"># analysis.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_selected_vars_target</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">conditional_realisations_target</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">conditional_realisations_target</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_selected_vars_target_realisations</span>
        <span class="p">)</span>

    <span class="c1"># Test all selected sources separately. This way, the conditioning</span>
    <span class="c1"># uses past variables from the current source only (opposed to past</span>
    <span class="c1"># variables from all sources as in multivariate network inference).</span>
    <span class="n">significant_sources</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
        <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">significance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">pvalue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">))</span>
    <span class="n">stat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">significant_sources</span><span class="p">:</span>
        <span class="c1"># Find selected past variables for current source</span>
        <span class="n">source_vars</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span> <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">source</span>
        <span class="p">]</span>

        <span class="c1"># Determine length of conditioning set and allocate memory.</span>
        <span class="n">idx_conditional</span> <span class="o">=</span> <span class="n">source_vars</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">conditional_realisations_target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">idx_conditional</span> <span class="o">+=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_target</span>
        <span class="n">conditional_realisations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">data</span><span class="o">.</span><span class="n">n_realisations</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_vars</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">idx_conditional</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span>
        <span class="n">candidate_realisations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">n_realisations</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_vars</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span>

        <span class="c1"># Calculate TE/MI for each candidate in the conditional source set,</span>
        <span class="c1"># i.e., calculate the conditional MI between each candidate and the</span>
        <span class="c1"># current value, conditional on all selected variables in the</span>
        <span class="c1"># conditioning set. Then sort the estimated TE/MI values.</span>
        <span class="n">i_1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">i_2</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">n_realisations</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">)</span>
        <span class="n">surr_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">source_vars</span><span class="p">),</span> <span class="n">n_permutations</span><span class="p">))</span>
        <span class="c1"># Collect data for each candidate and the corresponding conditioning set.</span>
        <span class="k">for</span> <span class="n">idx_c</span><span class="p">,</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">source_vars</span><span class="p">):</span>
            <span class="n">temp_cond</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span>
                <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
                <span class="nb">set</span><span class="p">(</span><span class="n">source_vars</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">candidate</span><span class="p">])),</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">temp_cand</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span>
                <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span> <span class="p">[</span><span class="n">candidate</span><span class="p">]</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># The following may happen if either the requested conditing is</span>
            <span class="c1"># &#39;none&#39; or if the conditiong set that is tested consists only of</span>
            <span class="c1"># a single candidate.</span>
            <span class="k">if</span> <span class="n">temp_cond</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">conditional_realisations</span> <span class="o">=</span> <span class="n">conditional_realisations_target</span>
                <span class="n">re_use</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;var2&quot;</span><span class="p">,</span> <span class="s2">&quot;conditional&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">re_use</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;var2&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">conditional_realisations_target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">conditional_realisations</span><span class="p">[</span><span class="n">i_1</span><span class="p">:</span><span class="n">i_2</span><span class="p">,]</span> <span class="o">=</span> <span class="n">temp_cond</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">conditional_realisations</span><span class="p">[</span><span class="n">i_1</span><span class="p">:</span><span class="n">i_2</span><span class="p">,]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">temp_cond</span><span class="p">,</span> <span class="n">conditional_realisations_target</span><span class="p">)</span>
                    <span class="p">)</span>
            <span class="n">candidate_realisations</span><span class="p">[</span><span class="n">i_1</span><span class="p">:</span><span class="n">i_2</span><span class="p">,]</span> <span class="o">=</span> <span class="n">temp_cand</span>
            <span class="n">i_1</span> <span class="o">=</span> <span class="n">i_2</span>
            <span class="n">i_2</span> <span class="o">+=</span> <span class="n">data</span><span class="o">.</span><span class="n">n_realisations</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">)</span>

        <span class="c1"># Generate surrogates for the current candidate.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">is_analytic_null_estimator</span><span class="p">()</span>
            <span class="ow">and</span> <span class="n">permute_in_time</span>
        <span class="p">):</span>
            <span class="c1"># Generate the surrogates analytically</span>
            <span class="n">surr_table</span><span class="p">[</span>
                <span class="n">idx_c</span><span class="p">,</span> <span class="p">:</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate_surrogates_analytic</span><span class="p">(</span>
                <span class="n">n_perm</span><span class="o">=</span><span class="n">n_permutations</span><span class="p">,</span>
                <span class="n">var1</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span> <span class="p">[</span><span class="n">candidate</span><span class="p">])[</span>
                    <span class="mi">0</span>
                <span class="p">],</span>
                <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span><span class="p">,</span>
                <span class="n">conditional</span><span class="o">=</span><span class="n">temp_cond</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;analytical_surrogates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">surr_candidate_realisations</span> <span class="o">=</span> <span class="n">_get_surrogates</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
                <span class="p">[</span><span class="n">candidate</span><span class="p">],</span>
                <span class="n">n_permutations</span><span class="p">,</span>
                <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">surr_table</span><span class="p">[</span><span class="n">idx_c</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate_parallel</span><span class="p">(</span>
                    <span class="n">n_chunks</span><span class="o">=</span><span class="n">n_permutations</span><span class="p">,</span>
                    <span class="n">re_use</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;var2&quot;</span><span class="p">,</span> <span class="s2">&quot;conditional&quot;</span><span class="p">],</span>
                    <span class="n">var1</span><span class="o">=</span><span class="n">surr_candidate_realisations</span><span class="p">,</span>
                    <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span><span class="p">,</span>
                    <span class="n">conditional</span><span class="o">=</span><span class="n">temp_cond</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="n">ex</span><span class="o">.</span><span class="n">AlgorithmExhaustedError</span> <span class="k">as</span> <span class="n">aee</span><span class="p">:</span>
                <span class="c1"># The aglorithm cannot continue here, so</span>
                <span class="c1">#  we&#39;ll terminate the max sequential stats test,</span>
                <span class="c1">#  and declare all not significant</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;AlgorithmExhaustedError encountered in estimations: </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">aee</span><span class="o">.</span><span class="n">message</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Stopping sequential max stats at candidate with rank 0&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">)),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">)),</span>
                <span class="p">)</span>

        <span class="c1"># Calculate original statistic (multivariate/bivariate TE/MI)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">individual_stat</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate_parallel</span><span class="p">(</span>
                <span class="n">n_chunks</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">source_vars</span><span class="p">),</span>
                <span class="n">re_use</span><span class="o">=</span><span class="n">re_use</span><span class="p">,</span>
                <span class="n">var1</span><span class="o">=</span><span class="n">candidate_realisations</span><span class="p">,</span>
                <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span><span class="p">,</span>
                <span class="n">conditional</span><span class="o">=</span><span class="n">conditional_realisations</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="n">ex</span><span class="o">.</span><span class="n">AlgorithmExhaustedError</span> <span class="k">as</span> <span class="n">aee</span><span class="p">:</span>
            <span class="c1"># The aglorithm cannot continue here, so</span>
            <span class="c1">#  we&#39;ll terminate the max sequential stats test,</span>
            <span class="c1">#  and declare all not significant</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;AlgorithmExhaustedError encountered in &quot;</span>
                <span class="s2">&quot;estimations: </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aee</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Stopping sequential max stats at candidate with rank 0&quot;</span><span class="p">)</span>
            <span class="c1"># For now we don&#39;t need a stack trace:</span>
            <span class="c1"># traceback.print_tb(aee.__traceback__)</span>
            <span class="c1"># Return (signficance, pvalue, TEs):</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">)),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">)),</span>
            <span class="p">)</span>

        <span class="n">selected_vars_order</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">argsort_descending</span><span class="p">(</span><span class="n">individual_stat</span><span class="p">)</span>
        <span class="n">individual_stat_sorted</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sort_descending</span><span class="p">(</span><span class="n">individual_stat</span><span class="p">)</span>
        <span class="n">max_distribution</span> <span class="o">=</span> <span class="n">_sort_table_max</span><span class="p">(</span><span class="n">surr_table</span><span class="p">)</span>

        <span class="c1"># Compare each original value with the distribution of the same rank,</span>
        <span class="c1"># starting with the highest value.</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">individual_stat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span>
                <span class="n">individual_stat_sorted</span><span class="p">[</span><span class="n">c</span><span class="p">],</span>
                <span class="n">max_distribution</span><span class="p">[</span><span class="n">c</span><span class="p">,],</span>
                <span class="n">alpha</span><span class="p">,</span>
                <span class="n">tail</span><span class="o">=</span><span class="s2">&quot;one_bigger&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Write results into an array with the same order as the set of</span>
            <span class="c1"># selected sources from all process. Find the currently tested</span>
            <span class="c1"># variable and its index in the list of all selected variables.</span>
            <span class="n">current_var</span> <span class="o">=</span> <span class="n">source_vars</span><span class="p">[</span><span class="n">selected_vars_order</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">current_var</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">significance</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
            <span class="n">pvalue</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">stat</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">individual_stat_sorted</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>  <span class="c1"># break as soon as a candidate is no longer significant</span>
                <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;verbose&quot;</span><span class="p">]:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Stopping sequential max stats at candidate with &quot;</span>
                        <span class="s2">&quot;rank </span><span class="si">{0}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">break</span>

    <span class="k">return</span> <span class="n">significance</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">,</span> <span class="n">stat</span></div>


<div class="viewcode-block" id="min_statistic"><a class="viewcode-back" href="../../idtxl_helper.html#idtxl.stats.min_statistic">[docs]</a><span class="k">def</span> <span class="nf">min_statistic</span><span class="p">(</span>
    <span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">candidate_set</span><span class="p">,</span> <span class="n">te_min_candidate</span><span class="p">,</span> <span class="n">conditional</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform minimum statistics for one candidate source.</span>

<span class="sd">    Test if a transfer entropy value is significantly bigger than the minimum</span>
<span class="sd">    values obtained from surrogates of all remanining candidates.</span>

<span class="sd">    Args:</span>
<span class="sd">        analysis_setup : MultivariateTE instance</span>
<span class="sd">            information on the current analysis, can have an optional attribute</span>
<span class="sd">            &#39;settings&#39;, a dictionary with parameters for statistical testing:</span>

<span class="sd">            - n_perm_min_stat : int [optional] - number of permutations</span>
<span class="sd">              (default=500)</span>
<span class="sd">            - alpha_min_stat : float [optional] - critical alpha level</span>
<span class="sd">              (default=0.05)</span>
<span class="sd">            - permute_in_time : bool [optional] - generate surrogates by</span>
<span class="sd">              shuffling samples in time instead of shuffling whole replications</span>
<span class="sd">              (default=False)</span>

<span class="sd">        data : Data instance</span>
<span class="sd">            raw data</span>
<span class="sd">        candidate_set : list of tuples</span>
<span class="sd">            list of indices of remaning candidates</span>
<span class="sd">        te_min_candidate : float</span>
<span class="sd">            transfer entropy value to be tested</span>
<span class="sd">        conditional : numpy array [optional]</span>
<span class="sd">            realisations of conditional, 2D numpy array where array dimensions</span>
<span class="sd">            represent [realisations x variable dimension] (default=None, no</span>
<span class="sd">            conditioning performed)</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance</span>
<span class="sd">        float</span>
<span class="sd">            the test&#39;s p-value</span>
<span class="sd">        numpy array</span>
<span class="sd">            surrogate table</span>

<span class="sd">    Raises:</span>
<span class="sd">        ex.AlgorithmExhaustedError</span>
<span class="sd">            Raised from _create_surrogate_table() when calculation cannot be</span>
<span class="sd">            made</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set defaults and get parameters from settings dictionary</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;n_perm_min_stat&quot;</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
    <span class="n">n_perm</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;n_perm_min_stat&quot;</span><span class="p">]</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;alpha_min_stat&quot;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;alpha_min_stat&quot;</span><span class="p">]</span>
    <span class="n">_check_permute_in_time</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;verbose&quot;</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;minimum statistic, n_perm: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;n_perm_min_stat&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">assert</span> <span class="n">candidate_set</span><span class="p">,</span> <span class="s2">&quot;The candidate set is empty.&quot;</span>

    <span class="n">surr_table</span> <span class="o">=</span> <span class="n">_create_surrogate_table</span><span class="p">(</span>
        <span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">candidate_set</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">,</span> <span class="n">conditional</span>
    <span class="p">)</span>
    <span class="n">min_distribution</span> <span class="o">=</span> <span class="n">_find_table_min</span><span class="p">(</span><span class="n">surr_table</span><span class="p">)</span>
    <span class="p">[</span><span class="n">significance</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span>
        <span class="n">statistic</span><span class="o">=</span><span class="n">te_min_candidate</span><span class="p">,</span>
        <span class="n">distribution</span><span class="o">=</span><span class="n">min_distribution</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
        <span class="n">tail</span><span class="o">=</span><span class="s2">&quot;one_bigger&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">significance</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">,</span> <span class="n">surr_table</span></div>


<div class="viewcode-block" id="mi_against_surrogates"><a class="viewcode-back" href="../../idtxl_helper.html#idtxl.stats.mi_against_surrogates">[docs]</a><span class="k">def</span> <span class="nf">mi_against_surrogates</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Test estimated mutual information for significance against surrogate data.</span>

<span class="sd">    Shuffle realisations of the current value (point to be predicted) and re-</span>
<span class="sd">    calculate mutual information (MI) for shuffled data. The actual estimated</span>
<span class="sd">    MI is then compared against this distribution of MI values from surrogate</span>
<span class="sd">    data.</span>

<span class="sd">    Args:</span>
<span class="sd">        analysis_setup : MultivariateTE instance</span>
<span class="sd">            information on the current analysis, can have an optional attribute</span>
<span class="sd">            &#39;settings&#39;, a dictionary with parameters for statistical testing:</span>

<span class="sd">            - n_perm_mi : int [optional] - number of permutations</span>
<span class="sd">              (default=500)</span>
<span class="sd">            - alpha_mi : float [optional] - critical alpha level</span>
<span class="sd">              (default=0.05)</span>
<span class="sd">            - permute_in_time : bool [optional] - generate surrogates by</span>
<span class="sd">              shuffling samples in time instead of shuffling whole replications</span>
<span class="sd">              (default=False)</span>

<span class="sd">        data : Data instance</span>
<span class="sd">            raw data</span>

<span class="sd">    Returns:</span>
<span class="sd">        float</span>
<span class="sd">            estimated MI value</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance</span>
<span class="sd">        float</span>
<span class="sd">            p_value for estimated MI value</span>

<span class="sd">    Raises:</span>
<span class="sd">        ex.AlgorithmExhaustedError</span>
<span class="sd">            Raised from estimate() methods when calculation cannot be made</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;n_perm_mi&quot;</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
    <span class="n">n_perm</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;n_perm_mi&quot;</span><span class="p">]</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;alpha_mi&quot;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;alpha_mi&quot;</span><span class="p">]</span>
    <span class="n">permute_in_time</span> <span class="o">=</span> <span class="n">_check_permute_in_time</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;verbose&quot;</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;mi permutation test against surrogates, n_perm: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;n_perm_mi&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    surr_realisations = np.empty(</span>
<span class="sd">                        (data.n_realisations(analysis_setup.current_value) *</span>
<span class="sd">                         (n_perm + 1), 1))</span>
<span class="sd">    i_1 = 0</span>
<span class="sd">    i_2 = data.n_realisations(analysis_setup.current_value)</span>
<span class="sd">    # The first chunk holds the original data</span>
<span class="sd">    surr_realisations[i_1:i_2, ] = analysis_setup._current_value_realisations</span>
<span class="sd">    # Create surrogate data by shuffling the realisations of the current value.</span>
<span class="sd">    for perm in range(n_perm):</span>
<span class="sd">        i_1 = i_2</span>
<span class="sd">        i_2 += data.n_realisations(analysis_setup.current_value)</span>
<span class="sd">        # Check the permutation type for the current candidate.</span>
<span class="sd">        if permute_over_replications:</span>
<span class="sd">            surr_temp = data.permute_data(analysis_setup.current_value,</span>
<span class="sd">                                          [analysis_setup.current_value])[0]</span>
<span class="sd">        else:</span>
<span class="sd">            [real, repl_idx] = data.get_realisations(</span>
<span class="sd">                                            analysis_setup.current_value,</span>
<span class="sd">                                            [analysis_setup.current_value])</span>
<span class="sd">            surr_temp = _permute_realisations(real, repl_idx, perm_range)</span>
<span class="sd">        # Add current shuffled realisation to the array of all realisations for</span>
<span class="sd">        # parallel MI estimation.</span>
<span class="sd">        # surr_realisations[i_1:i_2, ] = surr_temp</span>
<span class="sd">        [real, repl_idx] = data.get_realisations(</span>
<span class="sd">                                            analysis_setup.current_value,</span>
<span class="sd">                                            [analysis_setup.current_value])</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">is_analytic_null_estimator</span><span class="p">()</span> <span class="ow">and</span> <span class="n">permute_in_time</span><span class="p">:</span>
        <span class="c1"># Generate the surrogates analytically</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;analytical_surrogates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">surr_dist</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate_surrogates_analytic</span><span class="p">(</span>
            <span class="n">n_perm</span><span class="o">=</span><span class="n">n_perm</span><span class="p">,</span>
            <span class="n">var1</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span><span class="p">,</span>
            <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_selected_vars_realisations</span><span class="p">,</span>
            <span class="n">conditional</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;analytical_surrogates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">surr_realisations</span> <span class="o">=</span> <span class="n">_get_surrogates</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
            <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">],</span>
            <span class="n">n_perm</span><span class="p">,</span>
            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">surr_dist</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate_parallel</span><span class="p">(</span>
            <span class="n">n_chunks</span><span class="o">=</span><span class="n">n_perm</span><span class="p">,</span>
            <span class="n">re_use</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;var2&quot;</span><span class="p">,</span> <span class="s2">&quot;conditional&quot;</span><span class="p">],</span>
            <span class="n">var1</span><span class="o">=</span><span class="n">surr_realisations</span><span class="p">,</span>
            <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_selected_vars_realisations</span><span class="p">,</span>
            <span class="n">conditional</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="n">orig_mi</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span>
        <span class="n">var1</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span><span class="p">,</span>
        <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_selected_vars_realisations</span><span class="p">,</span>
        <span class="n">conditional</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="p">[</span><span class="n">significance</span><span class="p">,</span> <span class="n">p_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span>
        <span class="n">statistic</span><span class="o">=</span><span class="n">orig_mi</span><span class="p">,</span> <span class="n">distribution</span><span class="o">=</span><span class="n">surr_dist</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="s2">&quot;one_bigger&quot;</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">orig_mi</span><span class="p">,</span> <span class="n">significance</span><span class="p">,</span> <span class="n">p_value</span><span class="p">]</span></div>


<div class="viewcode-block" id="unq_against_surrogates"><a class="viewcode-back" href="../../idtxl_helper.html#idtxl.stats.unq_against_surrogates">[docs]</a><span class="k">def</span> <span class="nf">unq_against_surrogates</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Test the unique information in the PID estimate against surrogate data.</span>

<span class="sd">    Shuffle realisations of both sources individually and re-calculate PID,</span>
<span class="sd">    in particular the unique information from shuffled data. The original</span>
<span class="sd">    unique information is then compared against the distribution of values</span>
<span class="sd">    calculated from surrogate data.</span>

<span class="sd">    Args:</span>
<span class="sd">        analysis_setup : Partial_information_decomposition instance</span>
<span class="sd">            information on the current analysis, should have an Attribute</span>
<span class="sd">            &#39;settings&#39;, a dict with optional fields</span>

<span class="sd">            - n_perm : int [optional] - number of permutations (default=500)</span>
<span class="sd">            - alpha : float [optional] - critical alpha level (default=0.05)</span>
<span class="sd">            - permute_in_time : bool [optional] - generate surrogates by</span>
<span class="sd">              shuffling samples in time instead of shuffling whole replications</span>
<span class="sd">              (default=False)</span>

<span class="sd">        data : Data instance</span>
<span class="sd">            raw data</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict</span>
<span class="sd">            PID estimate from original data</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance of the unique information in source 1</span>
<span class="sd">        float</span>
<span class="sd">            p-value of the unique information in source 1</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance of the unique information in source 2</span>
<span class="sd">        float</span>
<span class="sd">            p-value of the unique information in source 2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get analysis settings and defaults.</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;n_perm&quot;</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
    <span class="n">n_perm</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;n_perm&quot;</span><span class="p">]</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;alpha&quot;</span><span class="p">]</span>
    <span class="n">_check_permute_in_time</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">)</span>

    <span class="c1"># Get realisations and estimate PID for orginal data</span>
    <span class="n">target_realisations</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span> <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">]</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">source_1_realisations</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span> <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">source_2_realisations</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span> <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">sources</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">orig_pid</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_pid_estimator</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span>
        <span class="n">settings</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
        <span class="n">s1</span><span class="o">=</span><span class="n">source_1_realisations</span><span class="p">,</span>
        <span class="n">s2</span><span class="o">=</span><span class="n">source_2_realisations</span><span class="p">,</span>
        <span class="n">t</span><span class="o">=</span><span class="n">target_realisations</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Test unique information from source 1</span>
    <span class="n">surr_realisations</span> <span class="o">=</span> <span class="n">_get_surrogates</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
        <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
        <span class="n">n_perm</span><span class="p">,</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># Calculate surrogate distribution for unique information of source 1.</span>
    <span class="c1"># Note: calling  .estimate_parallel does not work here because the PID</span>
    <span class="c1"># estimator returns a dictionary not a single value. We have to get the</span>
    <span class="c1"># unique from the dictionary manually.</span>
    <span class="n">surr_dist_s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_perm</span><span class="p">)</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">surr_realisations</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_perm</span><span class="p">)</span>
    <span class="n">i_1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i_2</span> <span class="o">=</span> <span class="n">chunk_size</span>
    <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;verbose&quot;</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Testing unq information in s1&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_perm</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;verbose&quot;</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">perm </span><span class="si">{0}</span><span class="s2"> of </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">))</span>
        <span class="n">pid_est</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_pid_estimator</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span>
            <span class="n">settings</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
            <span class="n">s1</span><span class="o">=</span><span class="n">surr_realisations</span><span class="p">[</span><span class="n">i_1</span><span class="p">:</span><span class="n">i_2</span><span class="p">,</span> <span class="p">:],</span>
            <span class="n">s2</span><span class="o">=</span><span class="n">source_2_realisations</span><span class="p">,</span>
            <span class="n">t</span><span class="o">=</span><span class="n">target_realisations</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">surr_dist_s1</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">pid_est</span><span class="p">[</span><span class="s2">&quot;unq_s1&quot;</span><span class="p">]</span>
        <span class="n">i_1</span> <span class="o">=</span> <span class="n">i_2</span>
        <span class="n">i_2</span> <span class="o">+=</span> <span class="n">chunk_size</span>

    <span class="c1"># Test unique information from source 2</span>
    <span class="n">surr_realisations</span> <span class="o">=</span> <span class="n">_get_surrogates</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
        <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">sources</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
        <span class="n">n_perm</span><span class="p">,</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># Calculate surrogate distribution for unique information of source 2.</span>
    <span class="n">surr_dist_s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_perm</span><span class="p">)</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">surr_realisations</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_perm</span><span class="p">)</span>
    <span class="n">i_1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i_2</span> <span class="o">=</span> <span class="n">chunk_size</span>
    <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;verbose&quot;</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Testing unq information in s2&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_perm</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;verbose&quot;</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">perm </span><span class="si">{0}</span><span class="s2"> of </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">))</span>
        <span class="n">pid_est</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_pid_estimator</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span>
            <span class="n">settings</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
            <span class="n">s1</span><span class="o">=</span><span class="n">source_1_realisations</span><span class="p">,</span>
            <span class="n">s2</span><span class="o">=</span><span class="n">surr_realisations</span><span class="p">[</span><span class="n">i_1</span><span class="p">:</span><span class="n">i_2</span><span class="p">,</span> <span class="p">:],</span>
            <span class="n">t</span><span class="o">=</span><span class="n">target_realisations</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">surr_dist_s2</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">pid_est</span><span class="p">[</span><span class="s2">&quot;unq_s2&quot;</span><span class="p">]</span>
        <span class="n">i_1</span> <span class="o">=</span> <span class="n">i_2</span>
        <span class="n">i_2</span> <span class="o">+=</span> <span class="n">chunk_size</span>
    <span class="p">[</span><span class="n">sign_1</span><span class="p">,</span> <span class="n">p_val_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span>
        <span class="n">statistic</span><span class="o">=</span><span class="n">orig_pid</span><span class="p">[</span><span class="s2">&quot;unq_s1&quot;</span><span class="p">],</span>
        <span class="n">distribution</span><span class="o">=</span><span class="n">surr_dist_s1</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
        <span class="n">tail</span><span class="o">=</span><span class="s2">&quot;one_bigger&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="p">[</span><span class="n">sign_2</span><span class="p">,</span> <span class="n">p_val_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span>
        <span class="n">statistic</span><span class="o">=</span><span class="n">orig_pid</span><span class="p">[</span><span class="s2">&quot;unq_s2&quot;</span><span class="p">],</span>
        <span class="n">distribution</span><span class="o">=</span><span class="n">surr_dist_s2</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
        <span class="n">tail</span><span class="o">=</span><span class="s2">&quot;one_bigger&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">orig_pid</span><span class="p">,</span> <span class="n">sign_1</span><span class="p">,</span> <span class="n">p_val_1</span><span class="p">,</span> <span class="n">sign_2</span><span class="p">,</span> <span class="n">p_val_2</span><span class="p">]</span></div>


<div class="viewcode-block" id="syn_shd_against_surrogates"><a class="viewcode-back" href="../../idtxl_helper.html#idtxl.stats.syn_shd_against_surrogates">[docs]</a><span class="k">def</span> <span class="nf">syn_shd_against_surrogates</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Test the shared/synergistic information in the PID estimate.</span>

<span class="sd">    Shuffle realisations of the target and re-calculate PID, in particular the</span>
<span class="sd">    synergistic and shared information from shuffled data. The original</span>
<span class="sd">    shared and synergistic information are then compared against the</span>
<span class="sd">    distribution of values calculated from surrogate data.</span>

<span class="sd">    Args:</span>
<span class="sd">        analysis_setup : Partial_information_decomposition instance</span>
<span class="sd">            information on the current analysis, should have an Attribute</span>
<span class="sd">            &#39;settings&#39;, a dict with optional fields</span>

<span class="sd">            - n_perm : int [optional] - number of permutations (default=500)</span>
<span class="sd">            - alpha : float [optional] - critical alpha level (default=0.05)</span>
<span class="sd">            - permute_in_time : bool [optional] - generate surrogates by</span>
<span class="sd">              shuffling samples in time instead of shuffling whole replications</span>
<span class="sd">              (default=False)</span>

<span class="sd">        data : Data instance</span>
<span class="sd">            raw data</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict</span>
<span class="sd">            PID estimate from original data</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance of the shared information</span>
<span class="sd">        float</span>
<span class="sd">            p-value of the shared information</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance of the synergistic information</span>
<span class="sd">        float</span>
<span class="sd">            p-value of the synergistic information</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get analysis settings and defaults.</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;n_perm&quot;</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
    <span class="n">n_perm</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;n_perm&quot;</span><span class="p">]</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;alpha&quot;</span><span class="p">]</span>
    <span class="n">_check_permute_in_time</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">)</span>

    <span class="c1"># Get realisations and estimate PID for original data</span>
    <span class="n">target_realisations</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span> <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">]</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">source_1_realisations</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span> <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">source_2_realisations</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span> <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">sources</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">orig_pid</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_pid_estimator</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span>
        <span class="n">settings</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
        <span class="n">s1</span><span class="o">=</span><span class="n">source_1_realisations</span><span class="p">,</span>
        <span class="n">s2</span><span class="o">=</span><span class="n">source_2_realisations</span><span class="p">,</span>
        <span class="n">t</span><span class="o">=</span><span class="n">target_realisations</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Test shared and synergistic information from both sources</span>
    <span class="n">surr_realisations</span> <span class="o">=</span> <span class="n">_get_surrogates</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
        <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">],</span>
        <span class="n">n_perm</span><span class="p">,</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># Calculate surrogate distribution for shd/syn information of both sources.</span>
    <span class="c1"># Note: calling  .estimate_parallel does not work here because the PID</span>
    <span class="c1"># estimator returns a dictionary not a single value. We have to get the</span>
    <span class="c1"># shared info and synergy from the dictionary manually.</span>
    <span class="n">surr_dist_shd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_perm</span><span class="p">)</span>
    <span class="n">surr_dist_syn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_perm</span><span class="p">)</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">surr_realisations</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_perm</span><span class="p">)</span>
    <span class="n">i_1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i_2</span> <span class="o">=</span> <span class="n">chunk_size</span>
    <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;verbose&quot;</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Testing shd and syn information in both sources&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_perm</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;verbose&quot;</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">perm </span><span class="si">{0}</span><span class="s2"> of </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">))</span>
        <span class="n">pid_est</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_pid_estimator</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span>
            <span class="n">settings</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
            <span class="n">s1</span><span class="o">=</span><span class="n">source_1_realisations</span><span class="p">,</span>
            <span class="n">s2</span><span class="o">=</span><span class="n">source_2_realisations</span><span class="p">,</span>
            <span class="n">t</span><span class="o">=</span><span class="n">surr_realisations</span><span class="p">[</span><span class="n">i_1</span><span class="p">:</span><span class="n">i_2</span><span class="p">,</span> <span class="p">:],</span>
        <span class="p">)</span>
        <span class="n">surr_dist_shd</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">pid_est</span><span class="p">[</span><span class="s2">&quot;shd_s1_s2&quot;</span><span class="p">]</span>
        <span class="n">surr_dist_syn</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">pid_est</span><span class="p">[</span><span class="s2">&quot;syn_s1_s2&quot;</span><span class="p">]</span>
        <span class="n">i_1</span> <span class="o">=</span> <span class="n">i_2</span>
        <span class="n">i_2</span> <span class="o">+=</span> <span class="n">chunk_size</span>
    <span class="p">[</span><span class="n">sign_shd</span><span class="p">,</span> <span class="n">p_val_shd</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span>
        <span class="n">statistic</span><span class="o">=</span><span class="n">orig_pid</span><span class="p">[</span><span class="s2">&quot;shd_s1_s2&quot;</span><span class="p">],</span>
        <span class="n">distribution</span><span class="o">=</span><span class="n">surr_dist_shd</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
        <span class="n">tail</span><span class="o">=</span><span class="s2">&quot;one_bigger&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="p">[</span><span class="n">sign_syn</span><span class="p">,</span> <span class="n">p_val_syn</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span>
        <span class="n">statistic</span><span class="o">=</span><span class="n">orig_pid</span><span class="p">[</span><span class="s2">&quot;syn_s1_s2&quot;</span><span class="p">],</span>
        <span class="n">distribution</span><span class="o">=</span><span class="n">surr_dist_syn</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
        <span class="n">tail</span><span class="o">=</span><span class="s2">&quot;one_bigger&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">orig_pid</span><span class="p">,</span> <span class="n">sign_shd</span><span class="p">,</span> <span class="n">p_val_shd</span><span class="p">,</span> <span class="n">sign_syn</span><span class="p">,</span> <span class="n">p_val_syn</span><span class="p">]</span></div>


<div class="viewcode-block" id="check_n_perm"><a class="viewcode-back" href="../../idtxl_helper.html#idtxl.stats.check_n_perm">[docs]</a><span class="k">def</span> <span class="nf">check_n_perm</span><span class="p">(</span><span class="n">n_perm</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check if no. permutations is big enough to obtain the requested alpha.</span>

<span class="sd">    Note:</span>
<span class="sd">        The no. permutations must be big enough to theoretically allow for the</span>
<span class="sd">        detection of a p-value that is smaller than the critical alpha level.</span>
<span class="sd">        Otherwise the permutation test is pointless. The smalles possible</span>
<span class="sd">        p-value is 1/n_perm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">n_perm</span> <span class="o">&lt;</span> <span class="n">alpha</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;The number of permutations </span><span class="si">{0}</span><span class="s2"> is to small to test&quot;</span>
            <span class="s2">&quot; the requested alpha level </span><span class="si">{1}</span><span class="s2">. The number of &quot;</span>
            <span class="s2">&quot;permutations must be greater than 1/alpha.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_perm</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_create_surrogate_table</span><span class="p">(</span>
    <span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">idx_test_set</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">,</span> <span class="n">conditional</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a table of surrogate MI/CMI/TE values.</span>

<span class="sd">    Calculate MI/CMI/TE between surrogates for each source variable in the test</span>
<span class="sd">    set and the target in the analysis setup. The conditional is taken from the</span>
<span class="sd">    current set of conditional variables in the analysis setup. For</span>
<span class="sd">    multivariate MI or TE surrogate creation, the full set of conditional</span>
<span class="sd">    variables is used. For bivariate MI or TE surrogate creation, the</span>
<span class="sd">    conditioning set has to be restricted to a subset of the current set of</span>
<span class="sd">    conditional variables: for bivariate MI no conditioning set is required,</span>
<span class="sd">    for bivariate TE only the past variables from the target are required (not</span>
<span class="sd">    the variables selected from other relevant sources).</span>

<span class="sd">    Args:</span>
<span class="sd">        analysis_setup : instance of NetworkAnalysis or child class</span>
<span class="sd">            information on the current analysis, must contain an attribute</span>
<span class="sd">            settings with entry &#39;permute_in_time&#39;</span>
<span class="sd">        data : Data instance</span>
<span class="sd">            raw data</span>
<span class="sd">        idx_test_set : list of tuples</span>
<span class="sd">            list of indices indicating samples to be used as sources</span>
<span class="sd">        n_perm : int</span>
<span class="sd">            number of permutations for testing</span>
<span class="sd">        conditional : numpy array [optional]</span>
<span class="sd">            realisations of conditional, 2D numpy array where array dimensions</span>
<span class="sd">            represent [realisations x variable dimension] (default=None, no</span>
<span class="sd">            conditioning performed)</span>
<span class="sd">    Returns:</span>
<span class="sd">        numpy array</span>
<span class="sd">            surrogate MI/CMI/TE values, dimensions: (length test set, number of</span>
<span class="sd">            surrogates)</span>

<span class="sd">    Raises:</span>
<span class="sd">        ex.AlgorithmExhaustedError</span>
<span class="sd">            Raised from estimate_parallel() when calculation cannot be made</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check which permutation type is requested by the calling function.</span>
    <span class="n">permute_in_time</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;permute_in_time&quot;</span><span class="p">]</span>

    <span class="c1"># Create surrogate table.</span>
    <span class="n">surr_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_test_set</span><span class="p">),</span> <span class="n">n_perm</span><span class="p">))</span>
    <span class="n">current_value_realisations</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span>
    <span class="n">idx_c</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">idx_test_set</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">is_analytic_null_estimator</span><span class="p">()</span>
            <span class="ow">and</span> <span class="n">permute_in_time</span>
        <span class="p">):</span>
            <span class="c1"># Generate the surrogates analytically</span>
            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;analytical_surrogates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">surr_table</span><span class="p">[</span>
                <span class="n">idx_c</span><span class="p">,</span> <span class="p">:</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate_surrogates_analytic</span><span class="p">(</span>
                <span class="n">n_perm</span><span class="o">=</span><span class="n">n_perm</span><span class="p">,</span>
                <span class="n">var1</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span> <span class="p">[</span><span class="n">candidate</span><span class="p">])[</span>
                    <span class="mi">0</span>
                <span class="p">],</span>
                <span class="n">var2</span><span class="o">=</span><span class="n">current_value_realisations</span><span class="p">,</span>
                <span class="n">conditional</span><span class="o">=</span><span class="n">conditional</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;analytical_surrogates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">surr_candidate_realisations</span> <span class="o">=</span> <span class="n">_get_surrogates</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
                <span class="p">[</span><span class="n">candidate</span><span class="p">],</span>
                <span class="n">n_perm</span><span class="p">,</span>
                <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">surr_table</span><span class="p">[</span><span class="n">idx_c</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate_parallel</span><span class="p">(</span>
                <span class="n">n_chunks</span><span class="o">=</span><span class="n">n_perm</span><span class="p">,</span>
                <span class="n">re_use</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;var2&quot;</span><span class="p">,</span> <span class="s2">&quot;conditional&quot;</span><span class="p">],</span>
                <span class="n">var1</span><span class="o">=</span><span class="n">surr_candidate_realisations</span><span class="p">,</span>
                <span class="n">var2</span><span class="o">=</span><span class="n">current_value_realisations</span><span class="p">,</span>
                <span class="n">conditional</span><span class="o">=</span><span class="n">conditional</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">idx_c</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">surr_table</span>


<span class="k">def</span> <span class="nf">_find_table_max</span><span class="p">(</span><span class="n">table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find maximum for each column of a table.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_find_table_min</span><span class="p">(</span><span class="n">table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find minimum for each column of a table.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sort_table_min</span><span class="p">(</span><span class="n">table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sort each column in a table in ascending order.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">permutation</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">table</span><span class="p">[:,</span> <span class="n">permutation</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">table</span>


<span class="k">def</span> <span class="nf">_sort_table_max</span><span class="p">(</span><span class="n">table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sort each column in a table in descending order.&quot;&quot;&quot;</span>
    <span class="n">table_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">permutation</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">table_sorted</span><span class="p">[:,</span> <span class="n">permutation</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sort_descending</span><span class="p">(</span><span class="n">table</span><span class="p">[:,</span> <span class="n">permutation</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">table_sorted</span>


<span class="k">def</span> <span class="nf">_find_pvalue</span><span class="p">(</span><span class="n">statistic</span><span class="p">,</span> <span class="n">distribution</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">tail</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find p-value of a test statistic under some distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        statistic : numeric</span>
<span class="sd">            value to be tested against distribution</span>
<span class="sd">        distribution : numpy array</span>
<span class="sd">            1-dimensional distribution of values, test distribution</span>
<span class="sd">        alpha : float</span>
<span class="sd">            critical alpha level for statistical significance</span>
<span class="sd">        tail : str</span>
<span class="sd">            &#39;one&#39; or &#39;one_bigger&#39; for one-tailed testing H1 &gt; H0,</span>
<span class="sd">            &#39;one_smaller&#39; for one- tailed testing H1 &lt; H0, or &#39;two&#39; for two-</span>
<span class="sd">            tailed testing</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance</span>
<span class="sd">        float</span>
<span class="sd">            the test&#39;s p-value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s2">&quot;Critical alpha levels needs to be smaller than 1.&quot;</span>
    <span class="k">assert</span> <span class="n">distribution</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Test distribution must be 1D.&quot;</span>
    <span class="n">check_n_perm</span><span class="p">(</span><span class="n">distribution</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tail</span> <span class="o">==</span> <span class="s2">&quot;one_bigger&quot;</span> <span class="ow">or</span> <span class="n">tail</span> <span class="o">==</span> <span class="s2">&quot;one&quot;</span><span class="p">:</span>
        <span class="n">pvalue</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">distribution</span> <span class="o">&gt;=</span> <span class="n">statistic</span><span class="p">)</span> <span class="o">/</span> <span class="n">distribution</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">tail</span> <span class="o">==</span> <span class="s2">&quot;one_smaller&quot;</span><span class="p">:</span>
        <span class="n">pvalue</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">distribution</span> <span class="o">&lt;=</span> <span class="n">statistic</span><span class="p">)</span> <span class="o">/</span> <span class="n">distribution</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">tail</span> <span class="o">==</span> <span class="s2">&quot;two&quot;</span><span class="p">:</span>
        <span class="n">p_bigger</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">distribution</span> <span class="o">&gt;=</span> <span class="n">statistic</span><span class="p">)</span> <span class="o">/</span> <span class="n">distribution</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">p_smaller</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">distribution</span> <span class="o">&lt;=</span> <span class="n">statistic</span><span class="p">)</span> <span class="o">/</span> <span class="n">distribution</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pvalue</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">p_bigger</span><span class="p">,</span> <span class="n">p_smaller</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="s2">&quot;Unkown value for &quot;</span>
                <span class="s2">&quot;tail&quot;</span>
                <span class="s2">&quot;, should be &quot;</span>
                <span class="s2">&quot;one&quot;</span>
                <span class="s2">&quot;, &quot;</span>
                <span class="s2">&quot;one_bigger&quot;</span>
                <span class="s2">&quot;,&quot;</span>
                <span class="s2">&quot; &quot;</span>
                <span class="s2">&quot;one_smaller&quot;</span>
                <span class="s2">&quot;, or &quot;</span>
                <span class="s2">&quot;two&quot;</span>
                <span class="s2">&quot;): </span><span class="si">{0}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># If the statistic is larger than all values in the test distribution, set</span>
    <span class="c1"># the p-value to the smallest possible value 1/n_perm.</span>
    <span class="k">if</span> <span class="n">pvalue</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">pvalue</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">distribution</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">significance</span> <span class="o">=</span> <span class="n">pvalue</span> <span class="o">&lt;</span> <span class="n">alpha</span>

    <span class="k">return</span> <span class="n">significance</span><span class="p">,</span> <span class="n">pvalue</span>


<span class="k">def</span> <span class="nf">_sufficient_replications</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Test if no. replications is high enough for surrogate creation.</span>

<span class="sd">    Test if the number of replications is high enough to allow for the required</span>
<span class="sd">    number of permutations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">n_replications</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n_perm</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_get_surrogates</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">current_value</span><span class="p">,</span> <span class="n">idx_list</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">,</span> <span class="n">perm_settings</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return surrogate data for statistical testing.</span>

<span class="sd">    Calls surrogate generation methods of the data instance. The method for</span>
<span class="sd">    surrogate generation depends on whether sufficient replications of the data</span>
<span class="sd">    exists. If the number of replications is high enough (reps! &gt;</span>
<span class="sd">    n_permutations), surrogates are created by shuffling data over replications</span>
<span class="sd">    (while keeping the temporal order of samples intact). If the number of</span>
<span class="sd">    replications is too low, samples are shuffled over time (while keeping the</span>
<span class="sd">    order of replications intact). The latter method can be forced by setting</span>
<span class="sd">    &#39;permute_in_time&#39; to True in &#39;perm_settings&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">        data : Data instance</span>
<span class="sd">            raw data for analysis</span>
<span class="sd">        current_value : tuple</span>
<span class="sd">            index of the current value in current analysis, has to have the</span>
<span class="sd">            form (idx process, idx sample)</span>
<span class="sd">        idx_list : list of tuples</span>
<span class="sd">            list of variables, for which surrogates have to be created</span>
<span class="sd">        n_perm : int</span>
<span class="sd">            number of permutations</span>
<span class="sd">        perm_settings : dict</span>
<span class="sd">            settings for surrogate creation by shuffling samples over time, set</span>
<span class="sd">            &#39;permute_in_time&#39; to True to create surrogates by shuffling data</span>
<span class="sd">            over time. See Data.permute_samples() for settings for surrogate</span>
<span class="sd">            creation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy array</span>
<span class="sd">            surrogate data with dimensions</span>
<span class="sd">            (realisations * n_perm) x len(idx_list)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Allocate memory for surrogates</span>
    <span class="n">n_realisations</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">n_realisations</span><span class="p">(</span><span class="n">current_value</span><span class="p">)</span>
    <span class="n">surrogates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_realisations</span> <span class="o">*</span> <span class="n">n_perm</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_list</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
        <span class="n">data</span><span class="o">.</span><span class="n">data_type</span>
    <span class="p">)</span>

    <span class="c1"># Check if the user requested to permute samples in time and not over</span>
    <span class="c1"># replications</span>
    <span class="n">permute_in_time</span> <span class="o">=</span> <span class="n">perm_settings</span><span class="p">[</span><span class="s2">&quot;permute_in_time&quot;</span><span class="p">]</span>

    <span class="c1"># Generate surrogates by permuting over replications if possible (no.</span>
    <span class="c1"># replications needs to be sufficient); else permute samples over time.</span>
    <span class="n">i_1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i_2</span> <span class="o">=</span> <span class="n">n_realisations</span>
    <span class="c1"># permute samples</span>
    <span class="k">if</span> <span class="n">permute_in_time</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_perm</span><span class="p">):</span>
            <span class="n">surrogates</span><span class="p">[</span><span class="n">i_1</span><span class="p">:</span><span class="n">i_2</span><span class="p">,]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">permute_samples</span><span class="p">(</span>
                <span class="n">current_value</span><span class="p">,</span> <span class="n">idx_list</span><span class="p">,</span> <span class="n">perm_settings</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">i_1</span> <span class="o">=</span> <span class="n">i_2</span>
            <span class="n">i_2</span> <span class="o">+=</span> <span class="n">n_realisations</span>

    <span class="k">else</span><span class="p">:</span>  <span class="c1"># permute replications</span>
        <span class="k">assert</span> <span class="n">_sufficient_replications</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span>
        <span class="p">),</span> <span class="s2">&quot;Not enough replications for surrogate creation.&quot;</span>
        <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_perm</span><span class="p">):</span>
            <span class="n">surrogates</span><span class="p">[</span><span class="n">i_1</span><span class="p">:</span><span class="n">i_2</span><span class="p">,]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">permute_replications</span><span class="p">(</span><span class="n">current_value</span><span class="p">,</span> <span class="n">idx_list</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">i_1</span> <span class="o">=</span> <span class="n">i_2</span>
            <span class="n">i_2</span> <span class="o">+=</span> <span class="n">n_realisations</span>
    <span class="k">return</span> <span class="n">surrogates</span>


<span class="k">def</span> <span class="nf">_generate_spectral_surrogates</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">,</span> <span class="n">perm_settings</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate surrogate data for statistical testing of spectral TE.</span>

<span class="sd">    The method for surrogate generation depends on whether sufficient</span>
<span class="sd">    replications of the data exists. If the number of replications is high</span>
<span class="sd">    enough (reps! &gt; n_permutations), surrogates are created by shuffling data</span>
<span class="sd">    over replications (while keeping the temporal order of samples intact). If</span>
<span class="sd">    the number of replications is too low, samples are shuffled over time</span>
<span class="sd">    (while keeping the order of replications intact).</span>

<span class="sd">    Args:</span>
<span class="sd">        data : Data instance</span>
<span class="sd">            raw data for analysis</span>
<span class="sd">        scale : int</span>
<span class="sd">            index of the scale to be shuffled</span>
<span class="sd">        n_perm : int</span>
<span class="sd">            number of permutations</span>
<span class="sd">        perm_settings : dict</span>
<span class="sd">            settings for surrogate creation by shuffling samples over time</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy array</span>
<span class="sd">            surrogate data with dimensions</span>
<span class="sd">            (realisations * n_perm) x len(idx_list)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Allocate memory for surrogates</span>
    <span class="n">surrogates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">n_replications</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
        <span class="n">data</span><span class="o">.</span><span class="n">data_type</span>
    <span class="p">)</span>
    <span class="n">permute_in_time</span> <span class="o">=</span> <span class="n">perm_settings</span><span class="p">[</span><span class="s2">&quot;permute_in_time&quot;</span><span class="p">]</span>
    <span class="c1"># Generate surrogates by permuting over replications if possible (no.</span>
    <span class="c1"># replications needs to be sufficient); else permute samples over time.</span>
    <span class="k">if</span> <span class="n">permute_in_time</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_perm</span><span class="p">):</span>
            <span class="n">surrogates</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">perm</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">slice_permute_samples</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">perm_settings</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">_sufficient_replications</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_perm</span><span class="p">):</span>
            <span class="n">surrogates</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">perm</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">slice_permute_replications</span><span class="p">(</span><span class="n">scale</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">surrogates</span>


<span class="k">def</span> <span class="nf">_check_permute_in_time</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set defaults for permuting samples in time.</span>

<span class="sd">    The default for creating surrogate data is the permutation of original data</span>
<span class="sd">    over replications (such that the temporal ordering of samples stays</span>
<span class="sd">    intact). The function checks if this default can be used given the</span>
<span class="sd">    requested number of permutations and the number of replications in the</span>
<span class="sd">    data.</span>

<span class="sd">    The function tries to set the setting &#39;permute_in_time&#39; to its default</span>
<span class="sd">    &#39;False&#39; if no value for &#39;permute_in_time&#39; was provided by the user. If the</span>
<span class="sd">    number of replications is insufficient to generate the requested number of</span>
<span class="sd">    permutations, the function sets &#39;permute_in_time&#39; to true such that</span>
<span class="sd">    surrogates are created by permuting samples in time (if not requested</span>
<span class="sd">    otherwise the &#39;perm_type&#39; is set to &#39;random&#39;, see documentation of</span>
<span class="sd">    Data().permute_samples() for further settings).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;permute_in_time&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;permute_in_time&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_sufficient_replications</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span>
    <span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">WARNING: Number of replications is not sufficient to &quot;</span>
            <span class="s2">&quot;generate the desired number of surrogates. Permuting samples &quot;</span>
            <span class="s2">&quot;in time instead.&quot;</span>
        <span class="p">)</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;permute_in_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;permute_in_time&quot;</span><span class="p">]:</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;perm_type&quot;</span><span class="p">,</span> <span class="s2">&quot;random&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;permute_in_time&quot;</span><span class="p">]</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">IDTxl 1.5.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">idtxl.stats</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Patricia Wollstadt, Joseph T. Lizier, Raul Vicente, Conor Finn, Mario Martinez-Zarzuela, Pedro Mediano, Leonardo Novelli, Michael Wibral.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>