
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>idtxl.postprocessing &#8212; IDTxl 1.5.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/pyramid.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">IDTxl 1.5.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">idtxl.postprocessing</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for idtxl.postprocessing</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">hypergeom</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">binom</span>


<div class="viewcode-block" id="SignificantSubgraphMining"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining">[docs]</a><span class="k">class</span> <span class="nc">SignificantSubgraphMining</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Implementation of significant subgraph mining as described in</span>

<span class="sd">    Sugiyama M, Lopez FL, Kasenburg N, Borgwardt KM.  Significant</span>
<span class="sd">    subgraph mining with multiple testing correction.</span>
<span class="sd">    In:  Proceedings of the 2015 SIAMInternational Conference</span>
<span class="sd">    on Data Mining. SIAM; 2015. p. 37–45.</span>

<span class="sd">    Llinares-Lopez F, Sugiyama M, Papaxanthos L, Borgwardt K.  Fast and</span>
<span class="sd">    memory-efficient significant pattern mining via permutation testing.</span>
<span class="sd">    In:Proceedings of the 21th ACM SIGKDD International Conference on</span>
<span class="sd">    Knowledge Discovery and Data Mining. ACM; 2015. p. 725–734.</span>

<span class="sd">    Gutknecht, Wibral (2021): &quot;Significant Subgraph Mining for Neural Network</span>
<span class="sd">    Inference with Multiple Comparisons Correction&quot;. bioRxiv.</span>
<span class="sd">    https://www.biorxiv.org/content/10.1101/2021.11.03.467050v1.full</span>

<span class="sd">    Attributes:</span>
<span class="sd">        resultsA : list</span>
<span class="sd">            List of lists of IDTxl results dicts. One list per subject in</span>
<span class="sd">            Group A and one results dict per target.</span>
<span class="sd">        resultsB : list</span>
<span class="sd">            List of lists of IDTxl results dicts. One list per subject in</span>
<span class="sd">            Group B and one results dict per target</span>
<span class="sd">        coding_list : list</span>
<span class="sd">            List of all target-source-lag triplets in data set. Used to encode</span>
<span class="sd">            networks as lists of indices.</span>
<span class="sd">        groupA_networks : list</span>
<span class="sd">            List of lists of indices representing networks of subjects in</span>
<span class="sd">            Group A</span>
<span class="sd">        groupB_networks : list</span>
<span class="sd">            List of lists of indices representing networks of subjects in</span>
<span class="sd">            Group B</span>
<span class="sd">        graph_type : string</span>
<span class="sd">            can be either &quot;directed&quot; or &quot;undirected&quot; (undirected is only</span>
<span class="sd">            possible if data_format is &quot;adjacency&quot;)</span>
<span class="sd">        data_format : string</span>
<span class="sd">            can be either &quot;idtxl&quot; or &quot;adjacency&quot;</span>
<span class="sd">        design : string</span>
<span class="sd">            Sampling design. Either &quot;within&quot; for within-subject designs (the</span>
<span class="sd">            same group of subjects is measured under two different conditions)</span>
<span class="sd">            or &quot;between&quot; for between-subjects designs (two different groups</span>
<span class="sd">            of subjects are measured under the same condition)</span>
<span class="sd">        n_A : int</span>
<span class="sd">            Sample size of group A</span>
<span class="sd">        n_B : int</span>
<span class="sd">            Sample size of group B</span>
<span class="sd">        N : int</span>
<span class="sd">            Total sample size</span>
<span class="sd">        alpha : float</span>
<span class="sd">            Uncorrected significance level</span>
<span class="sd">        min_p_value_table : list</span>
<span class="sd">            List of minimum achievable p-values for all possible numbers of</span>
<span class="sd">            total occurrences of a subgraph (0 to N)</span>
<span class="sd">        p_value_table : numpy array</span>
<span class="sd">            Lookup table of p-values for each combination of occurrences in</span>
<span class="sd">            Group A and total occurrences between 0 and N</span>
<span class="sd">        min_freq : int</span>
<span class="sd">            Minimum number of occurrences required for testability at</span>
<span class="sd">            level alpha</span>
<span class="sd">        link_counts : list</span>
<span class="sd">            List of links counts for each link that occurs at least once</span>
<span class="sd">            in the data set (i.e. for each target-source-lag triplet</span>
<span class="sd">            in coding_list)</span>
<span class="sd">        union_indices : list</span>
<span class="sd">            List of indices of target-source-lag triplets in coding_list</span>
<span class="sd">            occuring at east min_freq times. All other triplets and all their</span>
<span class="sd">            supergraphs can be ignored because they are not even testable at</span>
<span class="sd">            level alpha</span>
<span class="sd">        frequent_graphs : list</span>
<span class="sd">            List of frequent subgraphs in data set occuring at least min_freq</span>
<span class="sd">            times. Initialized empty and filled by calling the</span>
<span class="sd">            enumerate_frequent_subgraphs method</span>
<span class="sd">        p_values : list</span>
<span class="sd">            List of p-values for each frequent subgraph. Initialized empty and</span>
<span class="sd">            filled by calling the enumerate_frequent_subgraphs method</span>
<span class="sd">        minimum_p_values : list</span>
<span class="sd">            List of minimum p-values for each frequent subgraph. Initialized</span>
<span class="sd">            empty and  filled by calling the enumerate_frequent_subgraphs</span>
<span class="sd">            method</span>
<span class="sd">        num_testable_graphs : int</span>
<span class="sd">            Number of subgraphs testable at level alpha. Initialized as 0 and</span>
<span class="sd">            determined by calling the enumerate_significant_subgraphs method.</span>
<span class="sd">        k_rt : int</span>
<span class="sd">            Tarones correction factor. Initialized as None. Determined by</span>
<span class="sd">            calling the enumerate_significant_subgraphs method</span>
<span class="sd">        p_values_corr : list</span>
<span class="sd">            List of corrected p-values. Intialized empty and filled by calling</span>
<span class="sd">            the enumerate_significant_subgraphs method</span>
<span class="sd">        significant_graphs : list</span>
<span class="sd">            List of tuples of significant subgraphs in data set and their</span>
<span class="sd">            associated corrected p-values. Initialized empty and filled by</span>
<span class="sd">            calling the enumerate_significant_subgraphs method</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">resultsA</span><span class="p">,</span>
        <span class="n">resultsB</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">,</span>
        <span class="n">design</span><span class="p">,</span>
        <span class="n">graph_type</span><span class="o">=</span><span class="s2">&quot;directed&quot;</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="s2">&quot;adjacency&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;alpha must be of type float&quot;</span><span class="p">)</span>

        <span class="c1"># if not alpha &lt; 1 and alpha &gt; 0:</span>
        <span class="c1">#     raise ValueError(&quot;alpha must be strictly between 0 and 1&quot;)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">resultsA</span> <span class="o">=</span> <span class="n">resultsA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resultsB</span> <span class="o">=</span> <span class="n">resultsB</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_A</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resultsA</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_B</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resultsB</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;between&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resultsA</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resultsB</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;within&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resultsA</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">=</span> <span class="n">design</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">graph_type</span> <span class="o">=</span> <span class="n">graph_type</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data_format</span> <span class="o">=</span> <span class="n">data_format</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_min_p_table</span><span class="p">(</span><span class="n">design</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">p_value_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_p_table</span><span class="p">(</span><span class="n">design</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
                <span class="n">ind</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value_table</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">alpha</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Due to the sample size, a significant result at level </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="si">}</span><span class="s2"> is in principle not possible.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># represent graphs as lists of link indices</span>
        <span class="k">if</span> <span class="n">data_format</span> <span class="o">==</span> <span class="s2">&quot;idtxl&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coding_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_coding_list</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groupA_networks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groupB_networks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">data_format</span> <span class="o">==</span> <span class="s2">&quot;adjacency&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resultsA</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coding_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_coding_list</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groupA_networks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_adjacency</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groupB_networks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_adjacency</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># count total occurrences for each link in the data set</span>
        <span class="n">link_counts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coding_list</span><span class="p">)):</span>
            <span class="n">link_counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">count_subgraph</span><span class="p">([</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_subgraph</span><span class="p">([</span><span class="n">i</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">link_counts</span> <span class="o">=</span> <span class="n">link_counts</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">union_indices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link_counts</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">link_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">infty</span>

        <span class="c1"># create ascending list of all possible p-values</span>
        <span class="n">all_possible_p_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_value_table</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">all_possible_p_values</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">all_possible_p_values</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">all_possible_p_values</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">frequent_graphs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimum_p_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_rt</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_values_corr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_testable_graphs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">significant_subgraphs</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="SignificantSubgraphMining.generate_coding_list"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.generate_coding_list">[docs]</a>    <span class="k">def</span> <span class="nf">generate_coding_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If data_format = &quot;idtxl&quot;: Creates list of all target-source-lag</span>
<span class="sd">        triplets occuring at least once</span>
<span class="sd">        in the data set. This list is used to encode subject networks as</span>
<span class="sd">        lists including all indices of the coding list such that the</span>
<span class="sd">        corresponding triplet is part of the network.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of 3-tuples</span>
<span class="sd">                each tuple has the form (target index, source index, lags)</span>


<span class="sd">        If data_format = &quot;adjacency&quot;: Creates list of all source-target tuples</span>
<span class="sd">        occuring at least once in the data set. This list is used to encode</span>
<span class="sd">        subject networks as lists including all indices of the coding list</span>
<span class="sd">        such that the corresponding tuple is part of the network.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of 2-tuples</span>
<span class="sd">                each tuple has the form (source index, target index)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_format</span> <span class="o">==</span> <span class="s2">&quot;idtxl&quot;</span><span class="p">:</span>
            <span class="n">tsl_triplet_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">resultsA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultsB</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">results_dicts_list</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">results_dict</span> <span class="ow">in</span> <span class="n">results_dicts_list</span><span class="p">:</span>
                        <span class="n">target</span> <span class="o">=</span> <span class="n">results_dict</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span>

                        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">results_dict</span><span class="p">[</span><span class="s2">&quot;selected_vars_sources&quot;</span><span class="p">]:</span>
                            <span class="n">tsl_triplet</span> <span class="o">=</span> <span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                            <span class="n">tsl_triplet_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tsl_triplet</span><span class="p">)</span>

            <span class="n">tsl_triplet_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tsl_triplet_set</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">tsl_triplet_list</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_format</span> <span class="o">==</span> <span class="s2">&quot;adjacency&quot;</span><span class="p">:</span>
            <span class="n">st_tuple_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_type</span> <span class="o">==</span> <span class="s2">&quot;directed&quot;</span><span class="p">:</span>
                <span class="c1"># all possible source-target tuples</span>
                <span class="n">tuples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)]</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_type</span> <span class="o">==</span> <span class="s2">&quot;undirected&quot;</span><span class="p">:</span>
                <span class="c1"># only ascending source-target tuples</span>
                <span class="n">tuples</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span>
                <span class="p">]</span>

            <span class="c1"># for each tuple, check if it occurs in the data set. If so, add</span>
            <span class="c1"># it to st_tuple_set</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tuples</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">adj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultsA</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultsB</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">adj</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">st_tuple_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">st_tuple_set</span><span class="p">)</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.encode"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.encode">[docs]</a>    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encodes all subject networks as lists of indices. The ith entry</span>
<span class="sd">        describes the occurrence of the ith target-source-lag triplet</span>
<span class="sd">        in the coding list (self.coding_list).</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple of lists of integers</span>
<span class="sd">                The first entry of the tuple is a list of integers</span>
<span class="sd">                describing the networks of subjects in Group A. The second</span>
<span class="sd">                entry is a list of integers for Group B.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">all_networks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">resultsA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultsB</span><span class="p">]:</span>
            <span class="n">group_networks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">results_dicts_list</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                <span class="n">subject_network</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">results_dict</span> <span class="ow">in</span> <span class="n">results_dicts_list</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">results_dict</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span>

                    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">results_dict</span><span class="p">[</span><span class="s2">&quot;selected_vars_sources&quot;</span><span class="p">]:</span>
                        <span class="n">subject_network</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">coding_list</span><span class="o">.</span><span class="n">index</span><span class="p">((</span><span class="n">target</span><span class="p">,</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="p">)</span>

                <span class="n">group_networks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subject_network</span><span class="p">)</span>
                <span class="mi">0</span>
            <span class="n">all_networks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_networks</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">all_networks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">all_networks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.decode"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.decode">[docs]</a>    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a given list of indices (representing a subgraph) into</span>
<span class="sd">        a list of corresponding target-source-lag triplets using the mapping</span>
<span class="sd">        described in the coding list.</span>

<span class="sd">        Args:</span>
<span class="sd">            indices : list of integers</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of 3-tuples</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tsl_triplets</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">tsl_triplets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coding_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">tsl_triplets</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.encode_adjacency"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.encode_adjacency">[docs]</a>    <span class="k">def</span> <span class="nf">encode_adjacency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Encodes all input adjacency matrices as lists of indices&quot;&quot;&quot;</span>

        <span class="n">all_networks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">resultsA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultsB</span><span class="p">]:</span>
            <span class="n">group_networks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">adj</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                <span class="n">subject_network</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coding_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">adj</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">subject_network</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coding_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

                <span class="n">group_networks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subject_network</span><span class="p">)</span>

            <span class="n">all_networks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_networks</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">all_networks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">all_networks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.decode_adjacency"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.decode_adjacency">[docs]</a>    <span class="k">def</span> <span class="nf">decode_adjacency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decodes list of indices as adjacency matrix&quot;&quot;&quot;</span>

        <span class="n">adjacency</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coding_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">adjacency</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">adjacency</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.generate_min_p_table"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.generate_min_p_table">[docs]</a>    <span class="k">def</span> <span class="nf">generate_min_p_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">design</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes list of minimum p_values depending on the total number of</span>
<span class="sd">        occurrences and given the group sample sizes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list</span>
<span class="sd">                minimum p-values for each number of occurrences between 0 and N</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;between&quot;</span><span class="p">:</span>
            <span class="n">min_p_value_table</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">min_upper_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_B</span><span class="p">])</span>
                <span class="n">max_upper_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_A</span><span class="p">,</span> <span class="n">m</span><span class="p">])</span>

                <span class="c1"># consider most extreme cases</span>

                <span class="c1"># First option: put as many occurrences as possible in group A</span>
                <span class="n">p_value_r</span> <span class="o">=</span> <span class="n">hypergeom</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">max_upper_left</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_A</span><span class="p">)</span>

                <span class="c1"># Second option: put as few occurrences as possible in group A</span>
                <span class="n">p_value_l</span> <span class="o">=</span> <span class="n">hypergeom</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">min_upper_left</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_A</span><span class="p">)</span>

                <span class="n">min_p_value_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">p_value_r</span><span class="p">,</span> <span class="n">p_value_l</span><span class="p">]))</span>

            <span class="k">return</span> <span class="n">min_p_value_table</span>

        <span class="k">elif</span> <span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;within&quot;</span><span class="p">:</span>
            <span class="n">min_p_value_table</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># consider most extreme cases</span>

                <span class="c1"># First option: put as many discordant pairs as possible in</span>
                <span class="c1"># condition A (meaning that they are all of the kind where</span>
                <span class="c1"># the subgraph occurred under condition A but not under</span>
                <span class="c1"># condition B)</span>

                <span class="n">p_value_r</span> <span class="o">=</span> <span class="n">binom</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>

                <span class="c1"># Second option: put as few discordant pairs as possible in</span>
                <span class="c1"># condition A. Due to the symmetry of the Binomial distribution</span>
                <span class="c1"># this leads to the same p-value as first option.</span>

                <span class="c1"># p_value_l = binom.pmf(0, d, 0.5)</span>

                <span class="n">min_p_value_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p_value_r</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">min_p_value_table</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.generate_p_table"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.generate_p_table">[docs]</a>    <span class="k">def</span> <span class="nf">generate_p_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">design</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes table of p-values depending on the total number of</span>
<span class="sd">        occurrences, the occurrences in Group A, and given the group</span>
<span class="sd">        sample sizes.</span>

<span class="sd">        Args:</span>
<span class="sd">            design : string</span>
<span class="sd">                sampling design. either &quot;within&quot; or &quot;between&quot;</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy array</span>
<span class="sd">                p-values for each number of occurrences and occurrences in</span>
<span class="sd">                Group A between 0 and N</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;between&quot;</span><span class="p">:</span>
            <span class="n">p_value_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">countA</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">occurrences</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">p_value_R</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">hypergeom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span>
                        <span class="n">countA</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">occurrences</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_A</span>
                    <span class="p">)</span>

                    <span class="n">p_value_L</span> <span class="o">=</span> <span class="n">hypergeom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span>
                        <span class="n">countA</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">occurrences</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_A</span>
                    <span class="p">)</span>

                    <span class="n">p_value</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">p_value_R</span><span class="p">,</span> <span class="n">p_value_L</span><span class="p">])</span>

                    <span class="n">p_value_table</span><span class="p">[</span><span class="n">countA</span><span class="p">,</span> <span class="n">occurrences</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_value</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_A</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_B</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">p_value_table</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if sample sizes are equal, the numerical  representation</span>
                <span class="c1"># of p-values should be made</span>
                <span class="c1"># unique. Otherwise p-values for each</span>
                <span class="c1"># combination of countA and occurrences will be different due</span>
                <span class="c1"># to numerical errors even though they should be equal because</span>
                <span class="c1"># of symmetries. There are three such symmetries:</span>

                <span class="c1"># Firstly, the p-value for f(G) and f_1(G) is the same as that</span>
                <span class="c1"># for n - f(G) and (n_1 - f(G)) + f_1(G). For instance,</span>
                <span class="c1"># given a total sample sie of n= 40 we have that 10</span>
                <span class="c1"># total occurrences with three in group 1 is the same as</span>
                <span class="c1"># 30 total occurrences with 13 occurrences in group 1.</span>
                <span class="c1"># For this reason only p-values for f(G) up to floor(N/2) have</span>
                <span class="c1"># to be computed. p-values for f(G) equal to floor(N/2) + 1</span>
                <span class="c1"># up to N are always identical to one of the already computed</span>
                <span class="c1"># values</span>

                <span class="n">p_value_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">occurrences</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">countA</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">occurrences</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">p_value_R</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">hypergeom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span>
                            <span class="n">countA</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">occurrences</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_A</span>
                        <span class="p">)</span>

                        <span class="n">p_value_L</span> <span class="o">=</span> <span class="n">hypergeom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span>
                            <span class="n">countA</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">occurrences</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_A</span>
                        <span class="p">)</span>

                        <span class="n">p_value</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">p_value_R</span><span class="p">,</span> <span class="n">p_value_L</span><span class="p">])</span>

                        <span class="n">p_value_table</span><span class="p">[</span><span class="n">countA</span><span class="p">,</span> <span class="n">occurrences</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_value</span>

                        <span class="n">p_value_table</span><span class="p">[</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">n_A</span> <span class="o">-</span> <span class="n">occurrences</span> <span class="o">+</span> <span class="n">countA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="n">occurrences</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">p_value</span>

                <span class="c1"># Secondly, given k total successes, the p-values corresponding to</span>
                <span class="c1"># k successes and 0 have to be the same. The same is true for</span>
                <span class="c1"># k-1 and 1, k-2 and 2, and so on.</span>

                <span class="k">for</span> <span class="n">occurrences</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">countA</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">countA</span> <span class="o">&lt;</span> <span class="n">occurrences</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">p_value_table</span><span class="p">[</span><span class="n">countA</span><span class="p">,</span> <span class="n">occurrences</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_value_table</span><span class="p">[</span>
                                <span class="n">occurrences</span> <span class="o">-</span> <span class="n">countA</span><span class="p">,</span> <span class="n">occurrences</span>
                            <span class="p">]</span>

                <span class="c1"># Thirdly, if sample sizes are equal then each hypergeometric</span>
                <span class="c1"># distribution corresponding to a specific total number of</span>
                <span class="c1"># occurrences f(G) is symmetric. This means that if is uneven,</span>
                <span class="c1"># the p-values corresponding to f_1(G) = ceil(F(G) / 2) and</span>
                <span class="c1"># f_1(G) = floor(F(G) / 2) have to be equal to 1.</span>

                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">p_value_table</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">j</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">p_value_table</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">j</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="k">return</span> <span class="n">p_value_table</span>

        <span class="k">elif</span> <span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;within&quot;</span><span class="p">:</span>
            <span class="c1"># compute p-value table based on Binomial distribution</span>

            <span class="n">p_value_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">d_in_A</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">p_value_r</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">binom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">d_in_A</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>

                    <span class="n">p_value_l</span> <span class="o">=</span> <span class="n">binom</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">d_in_A</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>

                    <span class="n">p_value_table</span><span class="p">[</span><span class="n">d_in_A</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">p_value_r</span><span class="p">,</span> <span class="n">p_value_l</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">p_value_table</span></div>

    <span class="c1"># In the following two &quot;count&quot; methods and four &quot;extend&quot; methods are defined.</span>

    <span class="c1"># There is one extend method for each combination of sampling design</span>
    <span class="c1"># &quot;within&quot; / &quot;between&quot; and correction method &quot;Tarone/Hommel&quot; / &quot;Westfall-Young&quot;</span>

    <span class="c1"># Between + Tarone: extend()</span>
    <span class="c1"># Between + WY: extend_wy()</span>
    <span class="c1"># Within + Tarone: extend_mcnemar()</span>
    <span class="c1"># Within + WY: extend _wy_mcnemar()</span>

<div class="viewcode-block" id="SignificantSubgraphMining.count_subgraph"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.count_subgraph">[docs]</a>    <span class="k">def</span> <span class="nf">count_subgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;original&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Counts the number of occurrences of a subgraph represented by a list of</span>
<span class="sd">        indices</span>

<span class="sd">        Args:</span>
<span class="sd">            indices : list of integers</span>
<span class="sd">                indices of all links the subgraph to be counted consists of</span>
<span class="sd">            where : string</span>
<span class="sd">                if &quot;original&quot; then the subgraph is counted in the original</span>
<span class="sd">                data set. if &quot;perm&quot; the subgraph is counted in the permuted</span>
<span class="sd">                data set (for WY procedure)</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple of integers</span>
<span class="sd">                number of occurrences of subgraph in GroupA and in GroupB</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">where</span> <span class="o">==</span> <span class="s2">&quot;original&quot;</span><span class="p">:</span>
            <span class="n">graphsA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupA_networks</span>
            <span class="n">graphsB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupB_networks</span>
        <span class="k">elif</span> <span class="n">where</span> <span class="o">==</span> <span class="s2">&quot;perm&quot;</span><span class="p">:</span>
            <span class="n">graphsA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm_groupA_networks</span>
            <span class="n">graphsB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm_groupB_networks</span>

        <span class="n">countA</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">graph</span> <span class="ow">in</span> <span class="n">graphsA</span><span class="p">:</span>
            <span class="c1"># check if sub_graph occurs in graph</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">):</span>
                <span class="n">countA</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">countB</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">graph</span> <span class="ow">in</span> <span class="n">graphsB</span><span class="p">:</span>
            <span class="c1"># check if sub_graph occurs in graph</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">):</span>
                <span class="n">countB</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">countA</span><span class="p">,</span> <span class="n">countB</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.count_discordants"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.count_discordants">[docs]</a>    <span class="k">def</span> <span class="nf">count_discordants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;original&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Counts the discordant pairs for a given subgraph represented as a</span>
<span class="sd">        list of indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            indices : list of integers</span>
<span class="sd">                indices of all links the subgraph to be counted consists of</span>
<span class="sd">            where : string</span>
<span class="sd">                if &quot;original&quot; then the discordants are counted in the original</span>
<span class="sd">                data set. if &quot;perm&quot; the discordants are counted in the permuted</span>
<span class="sd">                data set (for WY procedure)</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple of integers</span>
<span class="sd">                number of cases in which the subgraph occurred in condition A</span>
<span class="sd">                but not in B, and number of cases in which the subgraph</span>
<span class="sd">                occurred in B but not in A</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;between&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;The count_discordants method can only be used for within-subject designs. Currently the design is set to between subjects.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">where</span> <span class="o">==</span> <span class="s2">&quot;original&quot;</span><span class="p">:</span>
            <span class="n">graphsA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupA_networks</span>
            <span class="n">graphsB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupB_networks</span>
        <span class="k">elif</span> <span class="n">where</span> <span class="o">==</span> <span class="s2">&quot;perm&quot;</span><span class="p">:</span>
            <span class="n">graphsA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm_groupA_networks</span>
            <span class="n">graphsB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm_groupB_networks</span>

        <span class="n">discordants_B</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">discordants_A</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">graphsA</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">i</span> <span class="ow">in</span> <span class="n">graphsB</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span>
            <span class="p">):</span>
                <span class="n">discordants_A</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">graphsB</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">i</span> <span class="ow">in</span> <span class="n">graphsA</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span>
            <span class="p">):</span>
                <span class="n">discordants_B</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">discordants_A</span><span class="p">,</span> <span class="n">discordants_B</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.extend"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_be_extended</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively extends the input subgraph checking at each recursion</span>
<span class="sd">        step if the current subgraph occurs frequently enough to reach</span>
<span class="sd">        significance at level alpha. If this is not the case, it is not</span>
<span class="sd">        extended any further. If it is, the extend method is called again.</span>
<span class="sd">        Frequent subgraphs are appended to self.frequent_subgraphs.</span>

<span class="sd">        Args:</span>
<span class="sd">            to_be_extended : list</span>
<span class="sd">                list of indices describing the locations of 1s in the union</span>
<span class="sd">                network. Each such list represent a particular subgraph.</span>
<span class="sd">           freq : int</span>
<span class="sd">               desired minimum frequency</span>
<span class="sd">           max_depth : int</span>
<span class="sd">               If specified, only subgraphs with at most max_depth links are</span>
<span class="sd">               considered. For instance, if max_depth = 1 only individual</span>
<span class="sd">               links are tested. The default value is infinity meaning that</span>
<span class="sd">               all possible subgraphs are considered.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># the variable &quot;remaining&quot; contains all union indices larger than the</span>
        <span class="c1"># largest index in to_be_extended. These are the indices considered</span>
        <span class="c1"># in the extension process. In this way the subgraphs to be extended</span>
        <span class="c1"># are always represented by an ascending list of indices making sure</span>
        <span class="c1"># that only one permutation of the same set of indices is checked</span>
        <span class="c1"># (e.g. only [0,1] and not also [1,0] since these represent exactly</span>
        <span class="c1"># the same subgraph)</span>

        <span class="c1"># the following if-else statement makes sure that the extend method</span>
        <span class="c1"># can also be called with an empty list of indices. In this case</span>
        <span class="c1"># all links occurring at least once in the data set are considered</span>
        <span class="c1"># for extension.</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_be_extended</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">to_be_extended</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="n">max_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">to_be_extended</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">remaining</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">union_indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">max_index</span><span class="p">:</span>
                    <span class="n">remaining</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="c1"># successively extend the current subgraph by the indices in</span>
            <span class="c1"># remaining</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">remaining</span><span class="p">:</span>
                <span class="c1"># create extended subgraph. to_be_extended is already in the</span>
                <span class="c1"># list of frequent subgraphs and should not be altered. Thus,</span>
                <span class="c1"># only a copy of it should be extended.</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">to_be_extended</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="c1"># count occurrences of new subgraph in data set</span>
                <span class="n">countA</span><span class="p">,</span> <span class="n">countB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_subgraph</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>

                <span class="n">occurrences</span> <span class="o">=</span> <span class="n">countA</span> <span class="o">+</span> <span class="n">countB</span>

                <span class="c1"># if the new subgraph occurs often enough, append it to</span>
                <span class="c1"># self.frequent_graphs and store its minimum and actual</span>
                <span class="c1"># p-value. Then apply the extend method to the new subgraph</span>
                <span class="c1"># again.</span>
                <span class="k">if</span> <span class="n">occurrences</span> <span class="o">&gt;=</span> <span class="n">freq</span><span class="p">:</span>
                    <span class="n">minimum_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value_table</span><span class="p">[</span><span class="n">countA</span> <span class="o">+</span> <span class="n">countB</span><span class="p">]</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">minimum_p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minimum_p</span><span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">frequent_graphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>

                    <span class="n">p_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_value_table</span><span class="p">[</span><span class="n">countA</span><span class="p">,</span> <span class="n">occurrences</span><span class="p">]</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_value</span><span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span><span class="p">)</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.extend_mcnemar"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.extend_mcnemar">[docs]</a>    <span class="k">def</span> <span class="nf">extend_mcnemar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_be_extended</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as extend() method but using McNemar&#39;s test for within subject</span>
<span class="sd">        designs</span>

<span class="sd">        Args:</span>
<span class="sd">            to_be_extended : list</span>
<span class="sd">                list of indices describing the locations of 1s in the union</span>
<span class="sd">                network. Each such list represent a particular subgraph.</span>
<span class="sd">           freq : int</span>
<span class="sd">               desired minimum frequency</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_be_extended</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">to_be_extended</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="n">max_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">to_be_extended</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">remaining</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">union_indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">max_index</span><span class="p">:</span>
                    <span class="n">remaining</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">remaining</span><span class="p">:</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">to_be_extended</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="n">countA</span><span class="p">,</span> <span class="n">countB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_subgraph</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>

                <span class="n">occurrences</span> <span class="o">=</span> <span class="n">countA</span> <span class="o">+</span> <span class="n">countB</span>

                <span class="k">if</span> <span class="n">occurrences</span> <span class="o">&gt;=</span> <span class="n">freq</span><span class="p">:</span>
                    <span class="c1"># count discordant pairs</span>
                    <span class="n">discordants_A</span><span class="p">,</span> <span class="n">discordants_B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_discordants</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
                    <span class="n">discordants</span> <span class="o">=</span> <span class="n">discordants_A</span> <span class="o">+</span> <span class="n">discordants_B</span>

                    <span class="c1"># calculate and store p-value and minimal p-value</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">minimum_p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_p_value_table</span><span class="p">[</span><span class="n">discordants</span><span class="p">])</span>
                    <span class="n">p_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_value_table</span><span class="p">[</span><span class="n">discordants_A</span><span class="p">,</span> <span class="n">discordants</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_value</span><span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">frequent_graphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">extend_mcnemar</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span><span class="p">)</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.extend_wy"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.extend_wy">[docs]</a>    <span class="k">def</span> <span class="nf">extend_wy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_be_extended</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the smallest observed p-value in permuted version of the</span>
<span class="sd">        data set by recursively extending the input subgraph. At each</span>
<span class="sd">        recursion step the function checks if the current subgraph occurs</span>
<span class="sd">        frequently enough (&gt; self.current_min_freq) to obtain a p-value smaller</span>
<span class="sd">        than the smallest p-value observed so far (self.current_min_p).</span>
<span class="sd">        If this is not the case, it is not extended any further. If it is,</span>
<span class="sd">        the actual p-value is calculated. If this p-value happens to be smaller</span>
<span class="sd">        than current_min_p, then current_min_p and self.current_min_freq are</span>
<span class="sd">        updated, and the extend method is called again. If this p-value happens</span>
<span class="sd">        to be larger than current_min_p, the extend method is called again</span>
<span class="sd">        immediately.</span>

<span class="sd">        Args:</span>
<span class="sd">            list of indices of coding list. Each such list represent</span>
<span class="sd">            a particular subgraph.</span>
<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_be_extended</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">to_be_extended</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="n">max_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">to_be_extended</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">remaining</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coding_list</span><span class="p">))]:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">max_index</span><span class="p">:</span>
                    <span class="n">remaining</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">remaining</span><span class="p">:</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">to_be_extended</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="n">countA</span><span class="p">,</span> <span class="n">countB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_subgraph</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;perm&quot;</span><span class="p">)</span>

                <span class="n">occurrences</span> <span class="o">=</span> <span class="n">countA</span> <span class="o">+</span> <span class="n">countB</span>

                <span class="k">if</span> <span class="n">occurrences</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_min_freq</span><span class="p">:</span>
                    <span class="n">p_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_value_table</span><span class="p">[</span><span class="n">countA</span><span class="p">,</span> <span class="n">occurrences</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">p_value</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_min_p</span><span class="p">:</span>
                        <span class="c1"># update current minimum p-value</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">current_min_p</span> <span class="o">=</span> <span class="n">p_value</span>

                        <span class="c1"># calculate minimum frequency necessary to obtain a p-value</span>
                        <span class="c1"># smaller than the current minimum observed p-value.</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">current_min_freq</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
                            <span class="n">ind</span>
                            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value_table</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_min_p</span>
                        <span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">extend_wy</span><span class="p">(</span><span class="n">new</span><span class="p">)</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.extend_wy_mcnemar"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.extend_wy_mcnemar">[docs]</a>    <span class="k">def</span> <span class="nf">extend_wy_mcnemar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_be_extended</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as extend_wy but using McNemars test</span>

<span class="sd">        Args:</span>
<span class="sd">            list of indices of coding list. Each such list represent</span>
<span class="sd">            a particular subgraph.</span>
<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_be_extended</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">to_be_extended</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="n">max_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">to_be_extended</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">remaining</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">union_indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">max_index</span><span class="p">:</span>
                    <span class="n">remaining</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">remaining</span><span class="p">:</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">to_be_extended</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="c1"># count occurrences in permuted data set</span>
                <span class="c1"># the reasoning is that in order to obtain a certain</span>
                <span class="c1"># p-value, there must be a certain minimal number of</span>
                <span class="c1"># discordant pairs. But for this to be the case there</span>
                <span class="c1"># must be at this the same number of total occurrences.</span>
                <span class="c1"># Importantly, one cannot directly use the required number</span>
                <span class="c1"># of discordant pairs as a cut-off because a supergraph</span>
                <span class="c1"># may in fact have more discordant pairs than its subgraphs.</span>

                <span class="n">countA</span><span class="p">,</span> <span class="n">countB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_subgraph</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;perm&quot;</span><span class="p">)</span>

                <span class="n">occurrences</span> <span class="o">=</span> <span class="n">countA</span> <span class="o">+</span> <span class="n">countB</span>

                <span class="k">if</span> <span class="n">occurrences</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_min_freq</span><span class="p">:</span>
                    <span class="c1"># count discordant pairs in permuted data set</span>
                    <span class="n">discordants_A</span><span class="p">,</span> <span class="n">discordants_B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_discordants</span><span class="p">(</span>
                        <span class="n">new</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;perm&quot;</span>
                    <span class="p">)</span>
                    <span class="n">discordants</span> <span class="o">=</span> <span class="n">discordants_A</span> <span class="o">+</span> <span class="n">discordants_B</span>

                    <span class="n">p_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_value_table</span><span class="p">[</span><span class="n">discordants_A</span><span class="p">,</span> <span class="n">discordants</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">p_value</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_min_p</span><span class="p">:</span>
                        <span class="c1"># update current minimum p-value</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">current_min_p</span> <span class="o">=</span> <span class="n">p_value</span>

                        <span class="c1"># calculate minimum frequency necessary to obtain a p-value</span>
                        <span class="c1"># smaller than the current minimum observed p-value.</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">current_min_freq</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
                            <span class="n">ind</span>
                            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value_table</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_min_p</span>
                        <span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">extend_wy_mcnemar</span><span class="p">(</span><span class="n">new</span><span class="p">)</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.determine_tarone_factor"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.determine_tarone_factor">[docs]</a>    <span class="k">def</span> <span class="nf">determine_tarone_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines Tarone&#39;s correction factor in case there are at least two</span>
<span class="sd">        testable subgraphs.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int</span>
<span class="sd">                Tarone&#39;s correction factor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_testable_graphs</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;There are less than two testable subgraphs. No correction required.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Use bisection search to find Tarone&#39;s factor</span>
        <span class="c1"># the goal is to find the smallest integer k such that the ration of</span>
        <span class="c1"># the number of subgraphs testable at level alpha/k and k itself is</span>
        <span class="c1"># smaller than or equal to 1. We can restrict the search to the</span>
        <span class="c1"># interval 2 - number of alpha-testable subgraphs.</span>

        <span class="n">criterion</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_testable_graphs</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">low</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">criterion</span><span class="p">:</span>
            <span class="n">iterations</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">iterations</span> <span class="o">==</span> <span class="n">max_iter</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;WARNING: Correction factor could not be determined &quot;</span> <span class="o">+</span> <span class="s2">&quot;after&quot;</span><span class="p">,</span>
                    <span class="n">max_iter</span><span class="p">,</span>
                    <span class="s2">&quot;iterations&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">k_rt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">up</span> <span class="o">+</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># if the number of subgraphs testable at level alpha/k_rt is smaller</span>
            <span class="c1"># than k_rt, then the true k_rt must be smaller than or equal to</span>
            <span class="c1"># the current k_rt. So we set the current k_rt as the new upper</span>
            <span class="c1"># bound. Otherwise, the true k_rt must be larger, so we set the</span>
            <span class="c1"># current one as the new lower bound.</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_p_values</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">/</span> <span class="n">k_rt</span><span class="p">))</span> <span class="o">-</span> <span class="n">k_rt</span>
                <span class="o">&lt;=</span> <span class="mi">0</span>
            <span class="p">):</span>
                <span class="n">up</span> <span class="o">=</span> <span class="n">k_rt</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">low</span> <span class="o">=</span> <span class="n">k_rt</span>

            <span class="c1"># We have found the true k_rt if:</span>
            <span class="c1"># the tarone criterion m(k) / k &lt;= 1 is fulfilled for current k_rt</span>
            <span class="c1"># but not for the next smaller integer k_rt - 1</span>
            <span class="n">criterion</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_p_values</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">/</span> <span class="n">k_rt</span><span class="p">))</span> <span class="o">-</span> <span class="n">k_rt</span>
                <span class="o">&lt;=</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_p_values</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">/</span> <span class="p">(</span><span class="n">k_rt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
                <span class="o">-</span> <span class="n">k_rt</span>
                <span class="o">+</span> <span class="mi">1</span>
                <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">k_rt</span> <span class="o">=</span> <span class="n">k_rt</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.enumerate_frequent_graphs"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.enumerate_frequent_graphs">[docs]</a>    <span class="k">def</span> <span class="nf">enumerate_frequent_graphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds all subgraphs occuring at least freq times to self.frequent_graphs</span>
<span class="sd">        The process is carried out recursively using the extend() method.</span>
<span class="sd">        Individual links of the union network are successively extended to</span>
<span class="sd">        build more complex subgraphs. As soon as a subgraph does not occur</span>
<span class="sd">        often enough the extension process can be stopped because all</span>
<span class="sd">        supergraphs can at best occur with the same frequency. The extend()</span>
<span class="sd">        method also saves the minimum and actual p-values of all frequent</span>
<span class="sd">        subgraphs.</span>

<span class="sd">        Args:</span>
<span class="sd">            freq : int</span>
<span class="sd">                desired minimum frequency</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create union network consisting of all individual links occuring</span>
        <span class="c1"># at least freq times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">union_indices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link_counts</span><span class="p">))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">link_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">freq</span>
        <span class="p">]</span>

        <span class="c1"># reinitialize set of frequent subgraphs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frequent_graphs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># reinititalize list of actual p-values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_values</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># reinitialize list of minimum p-values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimum_p_values</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># recursively extend subgraphs starting from individual links in the</span>
        <span class="c1"># union network</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;between&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">([],</span> <span class="n">freq</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequent_graphs</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;within&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extend_mcnemar</span><span class="p">([],</span> <span class="n">freq</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequent_graphs</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.enumerate_significant_subgraphs"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.enumerate_significant_subgraphs">[docs]</a>    <span class="k">def</span> <span class="nf">enumerate_significant_subgraphs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Hommel&quot;</span><span class="p">,</span>
        <span class="n">wy_algorithm</span><span class="o">=</span><span class="s2">&quot;simple_depth_first&quot;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">num_perm</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
        <span class="n">max_depth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">infty</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the main function carrying out significant subgraph mining</span>
<span class="sd">        according to the multiple comparisons correction method (and algorithm</span>
<span class="sd">        in the case of Westfall-Young) of choice. It calls the relevant</span>
<span class="sd">        methods depending on the input arguments.</span>

<span class="sd">        Args:</span>
<span class="sd">            verbose : bool</span>
<span class="sd">                If True, print summary of results</span>
<span class="sd">            method : string</span>
<span class="sd">                Determines method used for multiple comparisons correction. can</span>
<span class="sd">                be &quot;Tarone&quot;, &quot;Hommel&quot;, or &quot;Westfall-Young&quot;</span>
<span class="sd">            num_perm : int</span>
<span class="sd">                Number of permutations used for Westfall-Young procedure.</span>
<span class="sd">            wy_algorithm : string</span>
<span class="sd">                algorithm used for Westfall-Young permutation procedure. Can be</span>
<span class="sd">                either &quot;simple_depth_fist&quot; (evaluates one permuted data set</span>
<span class="sd">                at a time) or &quot;wy_light&quot; for the Westfall-Young light algorithm</span>
<span class="sd">                introduced by Llinares-Lopez et al 2015 (distributes</span>
<span class="sd">                computations across permutations)</span>
<span class="sd">            max_depth : integer</span>
<span class="sd">                maximum complexity of subgraphs (number of links) up to which</span>
<span class="sd">                subgraphs are mined.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of tuples</span>
<span class="sd">                The first entry of each tuple is a list of indices representing</span>
<span class="sd">                the identified significant subgraph. The second entry is the</span>
<span class="sd">                associated (uncorrected) p-value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span> <span class="o">=</span> <span class="n">max_depth</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s2">&quot;Hommel&quot;</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">!=</span> <span class="s2">&quot;Tarone&quot;</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">!=</span> <span class="s2">&quot;Westfall-Young&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Method must be &#39;Hommel&#39; or &#39;Tarone&#39; or &#39;Westfall-Young&#39;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">infty</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Search Space: All possible subgraphs&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Search Space: Subgraphs consisting of up to&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">,</span>
                    <span class="s2">&quot;links&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;between&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Between-Subjects Design: Using Fishers Exact Test&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;within&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Within-Subject Design: Using McNemars Test&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">()</span>

        <span class="c1"># if union network is empty, there are no testable subgraphs and hence</span>
        <span class="c1"># no significant subgraphs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">union_indices</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;There are no alpha-testable subgraphs. No significant differences detectable.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># reinitialize list of significant subgraphs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">significant_subgraphs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Westfall-Young&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wy_algorithm</span> <span class="o">==</span> <span class="s2">&quot;simple_depth_first&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">westfall_young</span><span class="p">(</span><span class="n">num_perm</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">significant_subgraphs</span>

            <span class="k">elif</span> <span class="n">wy_algorithm</span> <span class="o">==</span> <span class="s2">&quot;wy_light&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">westfall_young_light</span><span class="p">(</span><span class="n">num_perm</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">significant_subgraphs</span>

            <span class="c1"># elif wy_algorithm == &quot;wy_light&quot; and self.design == &quot;within&quot;:</span>
            <span class="c1">#     raise Exception(&quot;wy_light algorithm is currently only &quot;</span>
            <span class="c1">#             &quot;implemented for between subjects designs&quot;)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;wy_algorithm has to be either simple_depth_first or wy_light&quot;</span>
                <span class="p">)</span>

        <span class="c1"># if method is not Westfall-Young the set of frequent subgraphs has</span>
        <span class="c1"># to be determined (all subgraphs occuring often enough to reach</span>
        <span class="c1"># significance at level alpha)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Determining frequent subgraphs...&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">enumerate_frequent_graphs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span><span class="p">)</span>

        <span class="c1"># If there are no testable subgraphs at level alpha, there can be no</span>
        <span class="c1"># significant subgraphs</span>
        <span class="c1"># count alpha testable graphs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_testable_graphs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_p_values</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of frequent subgraphs: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequent_graphs</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of alpha-testable subgraphs:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_testable_graphs</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_testable_graphs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;There are no testable subgraphs. No significant &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;differences detectable.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_testable_graphs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_rt</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># determine Tarone&#39;s correction factor</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Determining Tarone correction factor...&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">determine_tarone_factor</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Hommel&quot;</span><span class="p">:</span>
            <span class="n">hommel_level</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_p_values</span><span class="p">)[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_rt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="n">corrected_level</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">hommel_level</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_rt</span><span class="p">)])</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using Hommel correction...&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Corrected level:&quot;</span><span class="p">,</span> <span class="n">corrected_level</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Correction factor:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">/</span> <span class="n">corrected_level</span><span class="p">)</span>
                <span class="c1"># print(&quot;Hommel level&quot;, hommel_level)</span>
                <span class="nb">print</span><span class="p">()</span>

            <span class="c1"># determine significant subgraphs</span>
            <span class="n">run</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_values</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_rt</span> <span class="ow">or</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">hommel_level</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">significant_subgraphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequent_graphs</span><span class="p">[</span><span class="n">run</span><span class="p">]),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">p_values</span><span class="p">[</span><span class="n">run</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">/</span> <span class="n">corrected_level</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

                <span class="n">run</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">significant_subgraphs</span><span class="p">),</span> <span class="s2">&quot;significant subgraphs identified.&quot;</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">significant_subgraphs</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Tarone&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Correction factor:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_rt</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Corrected level:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_rt</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using Tarone correction...&quot;</span><span class="p">)</span>

            <span class="c1"># correct p-values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_values_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_values</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_values_corr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_rt</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_values_corr</span>

            <span class="c1"># determine significant subgraphs and corresponding p-values</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_values</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_values_corr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">significant_subgraphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequent_graphs</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">significant_subgraphs</span><span class="p">),</span> <span class="s2">&quot;significant subgraphs identified.&quot;</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">significant_subgraphs</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.westfall_young"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.westfall_young">[docs]</a>    <span class="k">def</span> <span class="nf">westfall_young</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_perm</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines significant subgraphs using the Westfall-Young Permutation</span>
<span class="sd">        procedure for multiple comparisons correction. This algorithm computes</span>
<span class="sd">        the permutation distribution of the smallest observed p-value</span>
<span class="sd">        permutation-by-permutation.</span>

<span class="sd">        Args:</span>
<span class="sd">            num_perm : int</span>
<span class="sd">                Number of permutation used for Westfall-Young procedure.</span>
<span class="sd">            verbose : bool</span>
<span class="sd">                If True, print summary of results</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Determining permutation distribution based on&quot;</span><span class="p">,</span>
                <span class="n">num_perm</span><span class="p">,</span>
                <span class="s2">&quot;permutations...&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># INITIALIZATION</span>

        <span class="c1"># current_min_p is the smallest p-value observed so far. Should be</span>
        <span class="c1"># initialized at some value larger than the largest possible p-value</span>
        <span class="c1"># (which in this case is 2)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_min_p</span> <span class="o">=</span> <span class="mi">10</span>

        <span class="c1"># minimum frequency necessary to reach a p-value smaller than</span>
        <span class="c1"># current_min_p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_min_freq</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># permutated versions of the data set. initialized at the original data</span>
        <span class="c1"># set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perm_groupA_networks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupA_networks</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perm_groupB_networks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupB_networks</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># list to store minimum observed p-values for each permutation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">permutation_min_p_values</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># initialize class labels</span>
        <span class="n">group_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="n">group_idx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_B</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">all_networks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupA_networks</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupB_networks</span>

        <span class="c1"># END OF INITIALIZATION</span>

        <span class="c1"># calculate minimum observed p-value for original data set</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;between&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extend_wy</span><span class="p">([])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;within&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extend_wy_mcnemar</span><span class="p">([])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">permutation_min_p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_min_p</span><span class="p">)</span>

        <span class="c1"># reinitialize current_min_p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_min_p</span> <span class="o">=</span> <span class="mi">10</span>

        <span class="c1"># find minimum observed p-values for num_perm permutated data sets</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_perm</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># create empty network lists</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">perm_groupA_networks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">perm_groupB_networks</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># generate permuted class labels and add networks to lists</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;between&quot;</span><span class="p">:</span>
                <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">group_idx</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">perm_groupA_networks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_networks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">perm_groupB_networks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_networks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                <span class="c1"># calculate minimum observed p-value for permuted data set</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">extend_wy</span><span class="p">([])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">permutation_min_p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_min_p</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;within&quot;</span><span class="p">:</span>
                <span class="c1"># decide independently for each subject if outcome is flipped</span>
                <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">perm_groupA_networks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groupA_networks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">perm_groupB_networks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groupB_networks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">perm_groupA_networks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groupB_networks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">perm_groupB_networks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groupA_networks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                <span class="c1"># calculate minimum observed p-value for permuted data set</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">extend_wy_mcnemar</span><span class="p">([])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">permutation_min_p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_min_p</span><span class="p">)</span>

            <span class="c1"># reinitialize current_min_p and current_min_freq</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_min_p</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_min_freq</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># calculate corrected level as largest value delta in</span>
        <span class="c1"># permutation_min_p_values such that the fraction of values in</span>
        <span class="c1"># permutation_min_p_values smaller or equal to delta is smaller or</span>
        <span class="c1"># equal to self.alpha</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># The maximum, i.e. the correction factor, should be determined</span>
        <span class="c1"># over the set of all possible p-values. This is because choosing</span>
        <span class="c1"># the correction factor between two possible p-values p_1 and p_2</span>
        <span class="c1"># leads to the same results as simply setting it to p_1. Hence we only</span>
        <span class="c1"># have to maximize over all possible p-values instead of over the</span>
        <span class="c1"># entire real interval (0,alpha) using grid search.</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_possible_p_values</span><span class="p">):</span>
            <span class="c1"># count fraction of minimum p values below ith entry</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">permutation_min_p_values</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_perm</span>
            <span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">:</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wy_corrected_level</span> <span class="o">=</span> <span class="n">delta</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wy_corrected_level</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Corrected level is zero. Try a larger number of permutations.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># The final step is to determine which subgraphs reach significant at</span>
        <span class="c1"># the corrected level. In order to do so it is not necessary to compute</span>
        <span class="c1"># the p-values of all subgraphs but only those occuring often enough</span>
        <span class="c1"># to reach significance at the corrected level:</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">min_freq_wy</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
            <span class="n">ind</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value_table</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_corrected_level</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">enumerate_frequent_graphs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_freq_wy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">significant_subgraphs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_values</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_corrected_level</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">significant_subgraphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequent_graphs</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">p_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_corrected_level</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Corrected level:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_corrected_level</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">significant_subgraphs</span><span class="p">),</span> <span class="s2">&quot;significant subgraphs identified.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.westfall_young_light"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.westfall_young_light">[docs]</a>    <span class="k">def</span> <span class="nf">westfall_young_light</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_perm</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines significant subgraphs using the Westfall-Young light</span>
<span class="sd">        algorithm described in</span>

<span class="sd">        Llinares-Lopez F, Sugiyama M, Papaxanthos L, Borgwardt K.  Fast and</span>
<span class="sd">        memory-efficient significant pattern mining via permutation testing.</span>
<span class="sd">        In:Proceedings of the 21th ACM SIGKDD International Conference on</span>
<span class="sd">        Knowledge Discovery and Data Mining. ACM; 2015. p. 725–734.</span>

<span class="sd">        Args:</span>
<span class="sd">            num_perm : int</span>
<span class="sd">                Number of permutation used for Westfall-Young procedure.</span>
<span class="sd">            verbose : bool</span>
<span class="sd">                If True, print summary of results</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Determining permutation distribution based on&quot;</span><span class="p">,</span>
                <span class="n">num_perm</span><span class="p">,</span>
                <span class="s2">&quot;permutations...&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Design:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_min_freq</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_perm</span> <span class="o">=</span> <span class="n">num_perm</span>

        <span class="c1"># initialize Westfall-Young corrected significance level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># initialize list of smallest p-values for each permuted data set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smallest_p_perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_perm</span><span class="p">)</span>

        <span class="c1"># initialize permuted data sets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_permuted_datasets</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># vector to be permuted</span>
        <span class="n">group_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="n">group_idx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_B</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">all_networks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupA_networks</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupB_networks</span>

        <span class="c1"># add original dataset as first entry to all_permuted_datasets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_permuted_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_permuted_datasets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groupA_networks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_permuted_datasets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groupB_networks</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;between&quot;</span><span class="p">:</span>
            <span class="c1"># add permutations and store all permuted data sets</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_perm</span><span class="p">):</span>
                <span class="c1"># create random permutation of class labels</span>
                <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">group_idx</span><span class="p">)</span>

                <span class="c1"># add corresponding data set to list of all permuted data sets</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_permuted_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">([[],</span> <span class="p">[]])</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">all_permuted_datasets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_networks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">all_permuted_datasets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_networks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;within&quot;</span><span class="p">:</span>
            <span class="c1"># add permutations and store all permuted data sets</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_perm</span><span class="p">):</span>
                <span class="c1"># decide independently for each subject if outcome is flipped</span>
                <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

                <span class="c1"># add corresponding data set to list of all permuted data sets</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_permuted_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">([[],</span> <span class="p">[]])</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">all_permuted_datasets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">groupA_networks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">all_permuted_datasets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">groupB_networks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">all_permuted_datasets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">groupB_networks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">all_permuted_datasets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">groupA_networks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="p">)</span>

        <span class="c1"># start extension process</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;between&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extend_wy_light</span><span class="p">([])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;within&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extend_wy_light_mcnemar</span><span class="p">([])</span>

        <span class="c1"># index of current estimate of WY threshold</span>
        <span class="n">wy_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_possible_p_values</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span><span class="p">)</span>
        <span class="c1"># look for final threshold within set of possible p-values up to the</span>
        <span class="c1"># current estimate (sanity check)</span>
        <span class="n">search_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_possible_p_values</span><span class="p">[</span><span class="n">wy_index</span><span class="p">:]</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smallest_p_perm</span> <span class="o">&lt;=</span> <span class="n">search_in</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_perm</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
        <span class="p">):</span>
            <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span> <span class="o">=</span> <span class="n">search_in</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WY-level determined...&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">min_freq_wy</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
            <span class="n">ind</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value_table</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">enumerate_frequent_graphs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_freq_wy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">significant_subgraphs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_values</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">significant_subgraphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequent_graphs</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">p_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Corrected level:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">significant_subgraphs</span><span class="p">),</span> <span class="s2">&quot;significant subgraphs identified.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.extend_wy_light"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.extend_wy_light">[docs]</a>    <span class="k">def</span> <span class="nf">extend_wy_light</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_be_extended</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Westfall-Young light extension method. Evaluates all permutations</span>
<span class="sd">        at the same time for each subgraph. The goal is to determine the</span>
<span class="sd">        Westfall-Young corrected level, i.e. the alpha quantile of the</span>
<span class="sd">        permutation distribution of the smallest observed p-value among</span>
<span class="sd">        subgraphs.  Recursively, evaluates subgraphs and updates</span>
<span class="sd">        the current estimate of the Westfall-Young corrected level</span>
<span class="sd">        self.wy_level_light.</span>

<span class="sd">        Args:</span>
<span class="sd">            indices : list of integers</span>
<span class="sd">                indices of all links of the subgraph</span>
<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_be_extended</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">to_be_extended</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="n">max_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">to_be_extended</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">remaining</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coding_list</span><span class="p">))]:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">max_index</span><span class="p">:</span>
                    <span class="n">remaining</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">remaining</span><span class="p">:</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">to_be_extended</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="c1"># calculate minimum achievable p-value</span>
                <span class="n">countA</span><span class="p">,</span> <span class="n">countB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_subgraph</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
                <span class="n">occurrences</span> <span class="o">=</span> <span class="n">countA</span> <span class="o">+</span> <span class="n">countB</span>
                <span class="n">min_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value_table</span><span class="p">[</span><span class="n">occurrences</span><span class="p">]</span>

                <span class="c1"># only continue if subgraph if testable at current estimate</span>
                <span class="c1"># of wy_level</span>
                <span class="k">if</span> <span class="n">min_p</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span><span class="p">:</span>
                    <span class="c1"># calculate p-value for all permuted data sets:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_perm</span><span class="p">):</span>
                        <span class="n">countA_perm</span><span class="p">,</span> <span class="n">countB_perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_subgraph_wylight</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                        <span class="n">p_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_value_table</span><span class="p">[</span><span class="n">countA_perm</span><span class="p">,</span> <span class="n">occurrences</span><span class="p">]</span>

                        <span class="c1"># update smallest p-value for k-th permuted data set</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">smallest_p_perm</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">p_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">smallest_p_perm</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
                        <span class="p">)</span>

                    <span class="c1"># estimate of FWER</span>
                    <span class="n">FWER</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smallest_p_perm</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span><span class="p">)</span>
                        <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_perm</span>
                    <span class="p">)</span>

                    <span class="k">while</span> <span class="n">FWER</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">:</span>
                        <span class="c1"># decrease corrected level while FWER is greater than alpha</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
                            <span class="n">p</span>
                            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_possible_p_values</span>
                            <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span>
                        <span class="p">)</span>
                        <span class="n">FWER</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smallest_p_perm</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span><span class="p">)</span>
                            <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_perm</span>
                        <span class="p">)</span>

                <span class="c1"># check if subgraph occurs often enough to be testable</span>
                <span class="c1"># at updated significance level</span>
                <span class="c1"># Only if this is the case, extend it further</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">current_min_freq</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
                    <span class="n">ind</span>
                    <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value_table</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">occurrences</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_min_freq</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">extend_wy_light</span><span class="p">(</span><span class="n">new</span><span class="p">)</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.count_subgraph_wylight"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.count_subgraph_wylight">[docs]</a>    <span class="k">def</span> <span class="nf">count_subgraph_wylight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Counts subgraph occurrences in k-th permuted data set</span>

<span class="sd">        Args:</span>
<span class="sd">            indices : list of integers</span>
<span class="sd">                indices of all links of the subgraph</span>
<span class="sd">            k : integer</span>
<span class="sd">                index of permuted data set</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple of integers</span>
<span class="sd">                number of occurrences in group A and number of occurrences</span>
<span class="sd">                in group B</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">countA</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">graph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_permuted_datasets</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># check if sub_graph occurs in graph</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">):</span>
                <span class="n">countA</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">countB</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">graph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_permuted_datasets</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># check if sub_graph occurs in graph</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">):</span>
                <span class="n">countB</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">countA</span><span class="p">,</span> <span class="n">countB</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.extend_wy_light_mcnemar"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.extend_wy_light_mcnemar">[docs]</a>    <span class="k">def</span> <span class="nf">extend_wy_light_mcnemar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_be_extended</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Westfall-Young light extension method for the within-subjects case</span>
<span class="sd">        using McNemars test. Recursively, evaluates subgraphs and updates</span>
<span class="sd">        the current estimate of the Westfall-Young corrected level</span>
<span class="sd">        self.wy_level_light.</span>

<span class="sd">        Args:</span>
<span class="sd">            indices : list of integers</span>
<span class="sd">                indices of all links of the subgraph</span>
<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_be_extended</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">to_be_extended</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="n">max_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">to_be_extended</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">remaining</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coding_list</span><span class="p">))]:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">max_index</span><span class="p">:</span>
                    <span class="n">remaining</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">remaining</span><span class="p">:</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">to_be_extended</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="c1"># count occurrences</span>
                <span class="n">countA</span><span class="p">,</span> <span class="n">countB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_subgraph</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
                <span class="n">occurrences</span> <span class="o">=</span> <span class="n">countA</span> <span class="o">+</span> <span class="n">countB</span>

                <span class="c1"># calculate minimum achievable p-value</span>
                <span class="n">discordants_A</span><span class="p">,</span> <span class="n">discordants_B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_discordants</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
                <span class="n">discordants</span> <span class="o">=</span> <span class="n">discordants_A</span> <span class="o">+</span> <span class="n">discordants_B</span>
                <span class="n">min_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value_table</span><span class="p">[</span><span class="n">discordants</span><span class="p">]</span>

                <span class="c1"># only continue if subgraph if testable at current estimate</span>
                <span class="c1"># of wy_level</span>
                <span class="k">if</span> <span class="n">min_p</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span><span class="p">:</span>
                    <span class="c1"># calculate p-value for all permuted data sets:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_perm</span><span class="p">):</span>
                        <span class="p">(</span>
                            <span class="n">discordants_A_perm</span><span class="p">,</span>
                            <span class="n">discordants_B_perm</span><span class="p">,</span>
                        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_discordants_wylight</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                        <span class="n">p_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_value_table</span><span class="p">[</span><span class="n">discordants_A_perm</span><span class="p">,</span> <span class="n">discordants</span><span class="p">]</span>

                        <span class="c1"># update smallest p-value for k-th permuted data set</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">smallest_p_perm</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">p_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">smallest_p_perm</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
                        <span class="p">)</span>

                    <span class="c1"># estimate of FWER</span>
                    <span class="n">FWER</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smallest_p_perm</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span><span class="p">)</span>
                        <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_perm</span>
                    <span class="p">)</span>

                    <span class="k">while</span> <span class="n">FWER</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">:</span>
                        <span class="c1"># decrease corrected level while FWER is greater than alpha</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
                            <span class="n">p</span>
                            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_possible_p_values</span>
                            <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span>
                        <span class="p">)</span>
                        <span class="n">FWER</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smallest_p_perm</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span><span class="p">)</span>
                            <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_perm</span>
                        <span class="p">)</span>

                <span class="c1"># check how many discordant pairs would be needed to obtain</span>
                <span class="c1"># a p-value significant at the new wy_level</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">current_min_freq</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
                    <span class="n">ind</span>
                    <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value_table</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wy_level_light</span>
                <span class="p">)</span>

                <span class="c1"># Only if there are enough occurrences to obtain this number</span>
                <span class="c1"># of discordant pairs extend the graph further</span>
                <span class="k">if</span> <span class="n">occurrences</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_min_freq</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">extend_wy_light_mcnemar</span><span class="p">(</span><span class="n">new</span><span class="p">)</span></div>

<div class="viewcode-block" id="SignificantSubgraphMining.count_discordants_wylight"><a class="viewcode-back" href="../../idtxl_postprocessing.html#idtxl.postprocessing.SignificantSubgraphMining.count_discordants_wylight">[docs]</a>    <span class="k">def</span> <span class="nf">count_discordants_wylight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Counts discordant pairs for subgraph given by list if indices</span>
<span class="sd">        in k-th permuted data set.</span>

<span class="sd">        Args:</span>
<span class="sd">            indices : list of integers</span>
<span class="sd">                indices of all links of the subgraph</span>
<span class="sd">            k : integer</span>
<span class="sd">                index of permuted data set</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple of integers</span>
<span class="sd">                number of cases in which the subgraph occurred in condition A</span>
<span class="sd">                but not in B, and number of cases in which the subgraph</span>
<span class="sd">                occurred in B but not in A</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">graphsA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_permuted_datasets</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">graphsB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_permuted_datasets</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">discordants_B</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">discordants_A</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">graphsA</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">i</span> <span class="ow">in</span> <span class="n">graphsB</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span>
            <span class="p">):</span>
                <span class="n">discordants_A</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">graphsB</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">i</span> <span class="ow">in</span> <span class="n">graphsA</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span>
            <span class="p">):</span>
                <span class="n">discordants_B</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">discordants_A</span><span class="p">,</span> <span class="n">discordants_B</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">IDTxl 1.5.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">idtxl.postprocessing</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Patricia Wollstadt, Joseph T. Lizier, Raul Vicente, Conor Finn, Mario Martinez-Zarzuela, Pedro Mediano, Leonardo Novelli, Michael Wibral.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>