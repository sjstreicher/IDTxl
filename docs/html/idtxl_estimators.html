
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Information theoretic estimators &#8212; IDTxl 1.5.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/pyramid.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Postprocessing of inferred networks" href="idtxl_postprocessing.html" />
    <link rel="prev" title="The Results Class" href="idtxl_results_class.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="idtxl_postprocessing.html" title="Postprocessing of inferred networks"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="idtxl_results_class.html" title="The Results Class"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">IDTxl 1.5.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Information theoretic estimators</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="information-theoretic-estimators">
<h1>Information theoretic estimators<a class="headerlink" href="#information-theoretic-estimators" title="Permalink to this headline">¶</a></h1>
<section id="jidt-estimators-cpu">
<h2>JIDT Estimators (CPU)<a class="headerlink" href="#jidt-estimators-cpu" title="Permalink to this headline">¶</a></h2>
<p>Provide JIDT estimators.</p>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtDiscrete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscrete"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Abstract class for implementation of discrete JIDT-estimators.</p>
<p>Abstract class for implementation of plug-in JIDT-estimators for discrete
data. Child classes implement estimators for mutual information (MI),
conditional mutual information (CMI), actice information storage (AIS), and
transfer entropy (TE). See parent class for references.</p>
<p>Set common estimation parameters for discrete JIDT-estimators. For usage of
these estimators see documentation for the child classes.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>discretise_method : str [optional] - if and how to discretise
incoming continuous data, can be ‘max_ent’ for maximum entropy
binning, ‘equal’ for equal size bins, and ‘none’ if no binning is
required (default=’none’)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Discrete JIDT estimators require the data’s alphabet size for
instantiation. Hence, opposed to the Kraskov and Gaussian estimators,
the JAVA class is added to the object instance, while for Kraskov/
Gaussian estimators an instance of that class is added (because for the
latter, objects can be instantiated independent of data properties).</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate_surrogates_analytic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_perm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscrete.estimate_surrogates_analytic"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return estimate of the analytical surrogate distribution.</p>
<p>This method must be implemented because this class’
is_analytic_null_estimator() method returns true.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>n_perms<span class="classifier">int [optional]</span></dt><dd><p>number of permutations (default=200)</p>
</dd>
<dt>data<span class="classifier">numpy arrays</span></dt><dd><p>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for
CMI). Formatted as per the estimate method for this estimator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>n_perm surrogates of the average MI/CMI/TE over all samples
under the null hypothesis of no relationship between var1 and
var2 (in the context of conditional)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_analytic_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscrete.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">numpy arrays</span></dt><dd><p>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for
CMI). Formatted as per the estimate method for this estimator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscrete.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtDiscreteAIS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteAIS"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate AIS with JIDT’s discrete-variable implementation.</p>
<p>Calculate the active information storage (AIS) for one process. Call JIDT
via jpype and use the discrete estimator. See parent class for references.</p>
<p>Results are returned in bits.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>history : int - number of samples in the target’s past used as
embedding (&gt;= 0)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>discretise_method : str [optional] - if and how to discretise
incoming continuous data, can be ‘max_ent’ for maximum entropy
binning, ‘equal’ for equal size bins, and ‘none’ if no binning is
required (default=’none’)</p></li>
<li><p>n_discrete_bins : int [optional] - number of discrete bins/
levels or the base of each dimension of the discrete variables
(default=2). If set, this parameter overwrites/sets alph. (&gt;= 2)</p></li>
<li><p>alph : int [optional] - number of discrete bins/levels for var1
(default=2 , or the value set for n_discrete_bins). (&gt;= 2)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_calc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteAIS.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate active information storage.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>process<span class="classifier">numpy array</span></dt><dd><p>realisations as either a 2D numpy array where array dimensions
represent [realisations x variable dimension] or a 1D array
representing [realisations], array type can be float (requires
discretisation) or int</p>
</dd>
<dt>return_calc<span class="classifier">boolean</span></dt><dd><p>return the calculator used here as well as the numeric
calculated value(s)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average AIS over all samples or local AIS for individual
samples if ‘local_values’=True</p>
</dd>
<dt>Java object</dt><dd><p>JIDT calculator that was used here. Only returned if
return_calc was set.</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.JidtOutOfMemoryError</dt><dd><p>Raised when JIDT object cannot be instantiated due to mem error</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_analytic_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteAIS.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>process<span class="classifier">numpy array</span></dt><dd><p>realisations as either a 2D numpy array where array dimensions
represent [realisations x variable dimension] or a 1D array
representing [realisations], array type can be float (requires
discretisation) or int</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtDiscreteCMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteCMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate CMI with JIDT’s implementation for discrete variables.</p>
<p>Calculate the conditional mutual information between two variables given
the third. Call JIDT via jpype and use the discrete estimator. See parent
class for references.</p>
<p>Results are returned in bits.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>discretise_method : str [optional] - if and how to discretise
incoming continuous data, can be ‘max_ent’ for maximum entropy
binning, ‘equal’ for equal size bins, and ‘none’ if no binning is
required (default=’none’)</p></li>
<li><p>n_discrete_bins : int [optional] - number of discrete bins/
levels or the base of each dimension of the discrete variables
(default=2). If set, this parameter overwrites/sets alph1, alph2
and alphc</p></li>
<li><p>alph1 : int [optional] - number of discrete bins/levels for var1
(default=2, or the value set for n_discrete_bins)</p></li>
<li><p>alph2 : int [optional] - number of discrete bins/levels for var2
(default=2, or the value set for n_discrete_bins)</p></li>
<li><p>alphc : int [optional] - number of discrete bins/levels for
conditional (default=2, or the value set for n_discrete_bins)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_calc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteCMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate conditional mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</p>
</dd>
<dt>return_calc<span class="classifier">boolean</span></dt><dd><p>return the calculator used here as well as the numeric
calculated value(s)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average CMI over all samples or local CMI for individual
samples if ‘local_values’=True</p>
</dd>
<dt>Java object</dt><dd><p>JIDT calculator that was used here. Only returned if
return_calc was set.</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.JidtOutOfMemoryError</dt><dd><p>Raised when JIDT object cannot be instantiated due to mem error</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_analytic_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteCMI.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtDiscreteMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate MI with JIDT’s discrete-variable implementation.</p>
<p>Calculate the mutual information (MI) between two variables. Call JIDT via
jpype and use the discrete estimator. See parent class for references.</p>
<p>Results are returned in bits.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>discretise_method : str [optional] - if and how to discretise
incoming continuous data, can be ‘max_ent’ for maximum entropy
binning, ‘equal’ for equal size bins, and ‘none’ if no binning is
required (default=’none’)</p></li>
<li><p>n_discrete_bins : int [optional] - number of discrete bins/
levels or the base of each dimension of the discrete variables
(default=2). If set, this parameter overwrites/sets alph1 and
alph2</p></li>
<li><p>alph1 : int [optional] - number of discrete bins/levels for var1
(default=2, or the value set for n_discrete_bins)</p></li>
<li><p>alph2 : int [optional] - number of discrete bins/levels for var2
(default=2, or the value set for n_discrete_bins)</p></li>
<li><p>lag_mi : int [optional] - time difference in samples to calculate
the lagged MI between processes (default=0)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_calc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>return_calc<span class="classifier">boolean</span></dt><dd><p>return the calculator used here as well as the numeric
calculated value(s)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average MI over all samples or local MI for individual
samples if ‘local_values’=True</p>
</dd>
<dt>Java object</dt><dd><p>JIDT calculator that was used here. Only returned if
return_calc was set.</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.JidtOutOfMemoryError</dt><dd><p>Raised when JIDT object cannot be instantiated due to mem error</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_analytic_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteMI.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtDiscreteTE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate TE with JIDT’s implementation for discrete variables.</p>
<p>Calculate the transfer entropy between two time series processes.
Call JIDT via jpype and use the discrete estimator. Transfer entropy is
defined as the conditional mutual information between the source’s past
state and the target’s current value, conditional on the target’s past.
See parent class for references.</p>
<p>Results are returned in bits.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>history_target : int - number of samples in the target’s past
used as embedding. (&gt;= 0)</p></li>
<li><p>history_source  : int [optional] - number of samples in the
source’s past used as embedding (default=same as the target
history). (&gt;= 1)</p></li>
<li><p>tau_source : int [optional] - source’s embedding delay
(default=1). (&gt;= 1)</p></li>
<li><p>tau_target : int [optional] - target’s embedding delay
(default=1). (&gt;= 1)</p></li>
<li><p>source_target_delay : int [optional] - information transfer delay
between source and target (default=1) (&gt;= 0)</p></li>
<li><p>discretise_method : str [optional] - if and how to discretise
incoming continuous data, can be ‘max_ent’ for maximum entropy
binning, ‘equal’ for equal size bins, and ‘none’ if no binning is
required (default=’none’)</p></li>
<li><p>n_discrete_bins : int [optional] - number of discrete bins/
levels or the base of each dimension of the discrete variables
(default=2). If set, this parameter overwrites/sets alph1 and
alph2. (&gt;= 2)</p></li>
<li><p>alph1 : int [optional] - number of discrete bins/levels for
source (default=2, or the value set for n_discrete_bins). (&gt;= 2)</p></li>
<li><p>alph2 : int [optional] - number of discrete bins/levels for
target (default=2, or the value set for n_discrete_bins). (&gt;= 2)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_calc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteTE.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate transfer entropy from a source to a target variable.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>source<span class="classifier">numpy array</span></dt><dd><p>realisations of source variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>target<span class="classifier">numpy array</span></dt><dd><p>realisations of target variable (similar to var1)</p>
</dd>
<dt>return_calc<span class="classifier">boolean</span></dt><dd><p>return the calculator used here as well as the numeric
calculated value(s)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average TE over all samples or local TE for individual
samples if ‘local_values’=True</p>
</dd>
<dt>Java object</dt><dd><p>JIDT calculator that was used here. Only returned if
return_calc was set.</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.JidtOutOfMemoryError</dt><dd><p>Raised when JIDT object cannot be instantiated due to mem error</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_analytic_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteTE.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>source<span class="classifier">numpy array</span></dt><dd><p>realisations of source variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>target<span class="classifier">numpy array</span></dt><dd><p>realisations of target variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtEstimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Abstract class for implementation of JIDT estimators.</p>
<p>Abstract class for implementation of JIDT estimators, child classes
implement estimators for mutual information (MI), conditional mutual
information (CMI), active information storage (AIS), transfer entropy (TE)
using the Kraskov-Grassberger-Stoegbauer estimator for continuous data,
plug-in estimators for discrete data, and Gaussian estimators for
continuous Gaussian data.</p>
<p>References:</p>
<ul class="simple">
<li><p>Lizier, Joseph T. (2014). JIDT: an information-theoretic toolkit for
studying the dynamics of complex systems. Front Robot AI, 1(11).</p></li>
<li><p>Kraskov, A., Stoegbauer, H., &amp; Grassberger, P. (2004). Estimating mutual
information. Phys Rev E, 69(6), 066138.</p></li>
<li><p>Lizier, Joseph T., Mikhail Prokopenko, and Albert Y. Zomaya. (2012).
Local measures of information storage in complex distributed computation.
Inform Sci, 208, 39-54.</p></li>
<li><p>Schreiber, T. (2000). Measuring information transfer. Phys Rev Lett,
85(2), 461.</p></li>
</ul>
<p>Set common estimation parameters for JIDT estimators. For usage of these
estimators see documentation for the child classes.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtEstimator.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtGaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">CalcClass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussian"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Abstract class for implementation of JIDT Gaussian-estimators.</p>
<p>Abstract class for implementation of JIDT Gaussian-estimators, child
classes implement estimators for mutual information (MI), conditional
mutual information (CMI), actice information storage (AIS), transfer
entropy (TE) using JIDT’s Gaussian estimator for continuous data. See
parent class for references.</p>
<p>Set common estimation parameters for JIDT Kraskov-estimators. For usage of
these estimators see documentation for the child classes.</p>
<p>Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>CalcClass<span class="classifier">JAVA class</span></dt><dd><p>JAVA class returned by jpype.JPackage</p>
</dd>
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate_surrogates_analytic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_perm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussian.estimate_surrogates_analytic"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate the surrogate distribution analytically.
This method must be implemented because this class’
is_analytic_null_estimator() method returns true</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>n_perms<span class="classifier">int</span></dt><dd><p>number of permutations (default=200)</p>
</dd>
<dt>data<span class="classifier">numpy arrays</span></dt><dd><p>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for
CMI). Formatted as per estimate_parallel for this estimator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>n_perm surrogates of the average MI/CMI/TE over all samples
under the null hypothesis of no relationship between var1 and
var2 (in the context of conditional)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_analytic_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussian.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">numpy arrays</span></dt><dd><p>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for
CMI). Formatted as per the estimate method for this estimator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussian.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtGaussianAIS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianAIS"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate active information storage with JIDT’s Gaussian implementation.</p>
<p>Calculate active information storage (AIS) for some process using JIDT’s
implementation of the Gaussian estimator. AIS is defined as the
mutual information between the processes’ past state and current value.</p>
<p>The past state needs to be defined in the settings dictionary, where a past
state is defined as a uniform embedding with parameters history and tau.
The history describes the number of samples taken from a processes’ past,
tau describes the embedding delay, i.e., the spacing between every two
samples from the processes’ past.</p>
<p>See parent class for references.Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>history : int - number of samples in the processes’ past used as
embedding</p></li>
<li><p>tau : int [optional] - the processes’ embedding delay (default=1)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the AIS estimator to save
computation time. The Theiler window ignores trial boundaries. The
AIS estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianAIS.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate active information storage.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>process<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average AIS over all samples or local AIS for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtGaussianCMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianCMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate conditional mutual infor with JIDT’s Gaussian implementation.</p>
<p>Computes the differential conditional mutual information of two
multivariate sets of observations, conditioned on another, assuming that
the probability distribution function for these observations is a
multivariate Gaussian distribution.
Call JIDT via jpype and use
ConditionalMutualInfoCalculatorMultiVariateGaussian estimator.
If no conditional is given (is None), the function returns the mutual
information between var1 and var2.</p>
<p>See parent class for references. Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI estimator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianCMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate conditional mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average CMI over all samples or local CMI for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_analytic_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianCMI.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtGaussianMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate mutual information with JIDT’s Gaussian implementation.</p>
<p>Calculate the mutual information between two variables. Call JIDT via jpype
and use the Gaussian estimator. See parent class for references.</p>
<p>Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>lag_mi : int [optional] - time difference in samples to calculate
the lagged MI between processes (default=0)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the MI estimator to save
computation time. The Theiler window ignores trial boundaries. The
MI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average MI over all samples or local MI for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtGaussianTE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate transfer entropy with JIDT’s Gaussian implementation.</p>
<p>Calculate transfer entropy between a source and a target variable using
JIDT’s implementation of the Gaussian estimator. Transfer entropy is
defined as the conditional mutual information between the source’s past
state and the target’s current value, conditional on the target’s past.</p>
<p>Past states need to be defined in the settings dictionary, where a past
state is defined as a uniform embedding with parameters history and tau.
The history describes the number of samples taken from a variable’s past,
tau descrices the embedding delay, i.e., the spacing between every two
samples from the processes’ past.</p>
<p>See parent class for references. Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>history_target : int - number of samples in the target’s past
used as embedding</p></li>
<li><p>history_source  : int [optional] - number of samples in the
source’s past used as embedding (default=same as the target
history)</p></li>
<li><p>tau_source : int [optional] - source’s embedding delay
(default=1)</p></li>
<li><p>tau_target : int [optional] - target’s embedding delay
(default=1)</p></li>
<li><p>source_target_delay : int [optional] - information transfer delay
between source and target (default=1)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI estimator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianTE.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate transfer entropy from a source to a target variable.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>source<span class="classifier">numpy array</span></dt><dd><p>realisations of source variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of target variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average TE over all samples or local TE for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtKraskov</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">CalcClass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskov"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Abstract class for implementation of JIDT Kraskov-estimators.</p>
<p>Abstract class for implementation of JIDT Kraskov-estimators, child classes
implement estimators for mutual information (MI), conditional mutual
information (CMI), actice information storage (AIS), transfer entropy (TE)
using the Kraskov-Grassberger-Stoegbauer estimator for continuous data.
See parent class for references.</p>
<p>Set common estimation parameters for JIDT Kraskov-estimators. For usage of
these estimators see documentation for the child classes.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>CalcClass<span class="classifier">JAVA class</span></dt><dd><p>JAVA class returned by jpype.JPackage</p>
</dd>
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>num_threads : int | str [optional] - number of threads used for
estimation (default=’USE_ALL’, note that this uses <em>all</em>
available threads on the current machine)</p></li>
<li><p>algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)
to use (default=1). Only applied at this method for TE and AIS
(is already applied for MI/CMI). Note that default algorithm of 1
here is different to the default ALG_NUM argument for the JIDT
AIS KSG estimator.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskov.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtKraskovAIS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovAIS"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate active information storage with JIDT’s Kraskov implementation.</p>
<p>Calculate active information storage (AIS) for some process using JIDT’s
implementation of the Kraskov type 1 estimator. AIS is defined as the
mutual information between the processes’ past state and current value.</p>
<p>The past state needs to be defined in the settings dictionary, where a past
state is defined as a uniform embedding with parameters history and tau.
The history describes the number of samples taken from a processes’ past,
tau describes the embedding delay, i.e., the spacing between every two
samples from the processes’ past.</p>
<p>See parent class for references. Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>history : int - number of samples in the processes’ past used as
embedding</p></li>
<li><p>tau : int [optional] - the processes’ embedding delay (default=1)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>num_threads : int | str [optional] - number of threads used for
estimation (default=’USE_ALL’, note that this uses <em>all</em>
available threads on the current machine)</p></li>
<li><p>algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)
to use (default=1)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the AIS estimator to save
computation time. The Theiler window ignores trial boundaries. The
AIS estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovAIS.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate active information storage.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>process<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average AIS over all samples or local AIS for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtKraskovCMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovCMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate conditional mutual inform with JIDT’s Kraskov implementation.</p>
<p>Calculate the conditional mutual information (CMI) between three variables.
Call JIDT via jpype and use the Kraskov 1 estimator. If no conditional is
given (is None), the function returns the mutual information between var1
and var2. See parent class for references.</p>
<blockquote>
<div><p>Results are returned in nats.</p>
</div></blockquote>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>num_threads : int | str [optional] - number of threads used for
estimation (default=’USE_ALL’, note that this uses <em>all</em>
available threads on the current machine)</p></li>
<li><p>algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)
to use (default=1)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI estimator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovCMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate conditional mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average CMI over all samples or local CMI for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtKraskovMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate mutual information with JIDT’s Kraskov implementation.</p>
<p>Calculate the mutual information between two variables. Call JIDT via jpype
and use the Kraskov 1 estimator. See parent class for references.</p>
<p>Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>num_threads : int | str [optional] - number of threads used for
estimation (default=’USE_ALL’, note that this uses <em>all</em>
available threads on the current machine)</p></li>
<li><p>algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)
to use (default=1)</p></li>
<li><p>lag_mi : int [optional] - time difference in samples to calculate
the lagged MI between processes (default=0)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the MI estimator to save
computation time. The Theiler window ignores trial boundaries. The
MI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average MI over all samples or local MI for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtKraskovTE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate transfer entropy with JIDT’s Kraskov implementation.</p>
<p>Calculate transfer entropy between a source and a target variable using
JIDT’s implementation of the Kraskov type 1 estimator. Transfer entropy is
defined as the conditional mutual information between the source’s past
state and the target’s current value, conditional on the target’s past.</p>
<p>Past states need to be defined in the settings dictionary, where a past
state is defined as a uniform embedding with parameters history and tau.
The history describes the number of samples taken from a variable’s past,
tau descrices the embedding delay, i.e., the spacing between every two
samples from the processes’ past.</p>
<p>See parent class for references. Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>history_target : int - number of samples in the target’s past
used as embedding</p></li>
<li><p>history_source  : int [optional] - number of samples in the
source’s past used as embedding (default=same as the target
history)</p></li>
<li><p>tau_source : int [optional] - source’s embedding delay
(default=1)</p></li>
<li><p>tau_target : int [optional] - target’s embedding delay
(default=1)</p></li>
<li><p>source_target_delay : int [optional] - information transfer delay
between source and target (default=1)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)
to use (default=1)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI estimator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovTE.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate transfer entropy from a source to a target variable.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>source<span class="classifier">numpy array</span></dt><dd><p>realisations of source variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of target variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average TE over all samples or local TE for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">common_estimate_surrogates_analytic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_perm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#common_estimate_surrogates_analytic"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate the surrogate distribution analytically for JidtEstimator.</p>
<p>Estimate the surrogate distribution analytically for a JidtEstimator
which is_analytic_null_estimator(), by sampling estimates at random
p-values in the analytic distribution.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>estimator<span class="classifier">a JidtEstimator object, which returns True to a call to</span></dt><dd><p>its is_analytic_null_estimator() method</p>
</dd>
<dt>n_perms<span class="classifier">int</span></dt><dd><p>number of permutations (default=200)</p>
</dd>
<dt>data<span class="classifier">numpy arrays</span></dt><dd><p>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for CMI)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>n_perm surrogates of the average MI/CMI/TE over all samples
under the null hypothesis of no relationship between var1 and
var2 (in the context of conditional)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="python-estimators-cpu">
<h2>Python Estimators (CPU)<a class="headerlink" href="#python-estimators-cpu" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_python.</span></span><span class="sig-name descname"><span class="pre">PythonKraskovCMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_python.html#PythonKraskovCMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate conditional mutual information using Kraskov’s first estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>base : float - base of returned values (default=np=e)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>rng_seed : int | None [optional] - random seed if noise level &gt; 0</p></li>
<li><p>num_threads : int | str [optional] - number of threads used for
estimation (default=’USE_ALL’, note that this uses <em>all</em>
available threads on the current machine)</p></li>
<li><p>knn_finder : str [optional] - knn algorithm to use, can be
‘scipy_kdtree’ (default), ‘sklearn_kdtree’, or ‘sklearn_balltree’</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_python.html#PythonKraskovCMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate conditional mutual information between var1 and var2, given
conditional.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_python.html#PythonKraskovCMI.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_python.html#PythonKraskovCMI.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="opencl-estimators-gpu">
<h2>OpenCL Estimators (GPU)<a class="headerlink" href="#opencl-estimators-gpu" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_opencl.</span></span><span class="sig-name descname"><span class="pre">OpenCLKraskov</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskov"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Abstract class for implementation of OpenCL estimators.</p>
<p>Abstract class for implementation of OpenCL estimators, child classes
implement estimators for mutual information (MI) and conditional mutual
information (CMI) using the Kraskov-Grassberger-Stoegbauer estimator for
continuous data.</p>
<p>References:</p>
<ul class="simple">
<li><p>Kraskov, A., Stoegbauer, H., &amp; Grassberger, P. (2004). Estimating mutual
information. Phys Rev E, 69(6), 066138.</p></li>
<li><p>Lizier, Joseph T., Mikhail Prokopenko, and Albert Y. Zomaya. (2012).
Local measures of information storage in complex distributed computation.
Inform Sci, 208, 39-54.</p></li>
<li><p>Schreiber, T. (2000). Measuring information transfer. Phys Rev Lett,
85(2), 461.</p></li>
</ul>
<p>Estimators can be used to perform multiple, independent searches in
parallel. Each of these parallel searches is called a ‘chunk’. To search
multiple chunks, provide point sets as 2D arrays, where the first
dimension represents samples or points, and the second dimension
represents the points’ dimensions. Concatenate chunk data in the first
dimension and pass the number of chunks to the estimators. Chunks must be
of equal size.</p>
<p>Set common estimation parameters for OpenCL estimators. For usage of these
estimators see documentation for the child classes.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>gpuid : int [optional] - device ID used for estimation (if more
than one device is available on the current platform) (default=0)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>padding : bool [optional] - pad data to a length that is a
multiple of 1024, workaround for a</p></li>
<li><p>debug : bool [optional] - calculate intermediate results, i.e.
neighbour counts from range searches and KNN distances, print
debug output to console (default=False)</p></li>
<li><p>return_counts : bool [optional] - return intermediate results,
i.e. neighbour counts from range searches and KNN distances
(default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskov.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskov.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_opencl.</span></span><span class="sig-name descname"><span class="pre">OpenCLKraskovCMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskovCMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate conditional mutual inform with OpenCL Kraskov implementation.</p>
<p>Calculate the conditional mutual information (CMI) between three variables
using OpenCL GPU-code. If no conditional is given (is None), the function
returns the mutual information between var1 and var2. See parent class for
references.</p>
<p>Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>gpuid : int [optional] - device ID used for estimation (if more
than one device is available on the current platform) (default=0)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>debug : bool [optional] - return intermediate results, i.e.
neighbour counts from range searches and KNN distances
(default=False)</p></li>
<li><p>return_counts : bool [optional] - return intermediate results,
i.e. neighbour counts from range searches and KNN distances
(default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_chunks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskovCMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate conditional mutual information.</p>
<p>If conditional is None, the mutual information between var1 and var2 is
calculated.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [(realisations * n_chunks) x
variable dimension] or a 1D array representing [realisations],
array type should be int32</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array</span></dt><dd><p>realisations of conditioning variable (similar to var1)</p>
</dd>
<dt>n_chunks<span class="classifier">int</span></dt><dd><p>number of data chunks, no. data points has to be the same for
each chunk</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average CMI over all samples or local CMI for individual
samples if ‘local_values’=True</p>
</dd>
<dt>numpy arrays</dt><dd><p>distances and neighborhood counts for var1 and var2 if
debug=True and return_counts=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_opencl.</span></span><span class="sig-name descname"><span class="pre">OpenCLKraskovMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskovMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate mutual information with OpenCL Kraskov implementation.</p>
<p>Calculate the mutual information (MI) between two variables using OpenCL
GPU-code. See parent class for references.</p>
<p>Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>gpuid : int [optional] - device ID used for estimation (if more
than one device is available on the current platform) (default=0)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>debug : bool [optional] - return intermediate results, i.e.
neighbour counts from range searches and KNN distances
(default=False)</p></li>
<li><p>return_counts : bool [optional] - return intermediate results,
i.e. neighbour counts from range searches and KNN distances
(default=False)</p></li>
<li><p>lag_mi : int [optional] - time difference in samples to calculate
the lagged MI between processes (default=0)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_chunks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskovMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [(realisations * n_chunks) x
variable dimension] or a 1D array representing [realisations],
array type should be int32</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>n_chunks<span class="classifier">int</span></dt><dd><p>number of data chunks, no. data points has to be the same for
each chunk</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average MI over all samples or local MI for individual
samples if ‘local_values’=True</p>
</dd>
<dt>numpy arrays</dt><dd><p>distances and neighborhood counts for var1 and var2 if
debug=True and return_counts=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="mpi-estimators-cpu">
<h2>MPI Estimators (CPU)<a class="headerlink" href="#mpi-estimators-cpu" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_mpi.</span></span><span class="sig-name descname"><span class="pre">MPIEstimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">est</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_mpi.html#MPIEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>MPI Wrapper for arbitrary Estimator implementations</p>
<p>Make sure to have an “if __name__==’__main__’:” guard in your main script
to avoid infinite recursion!</p>
<p>To use MPI, add MPI=True to the Estimator settings dictionary and
optionally provide max_workers</p>
<dl>
<dt>Call using mpiexec:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mpiexec</span> <span class="o">-</span><span class="n">n</span> <span class="mi">1</span> <span class="o">-</span><span class="n">usize</span> <span class="o">&lt;</span><span class="nb">max</span> <span class="n">workers</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">python</span> <span class="o">&lt;</span><span class="n">python</span> <span class="n">script</span><span class="o">&gt;</span>
</pre></div>
</div>
</dd>
<dt>or, if MPI does not support spawning new workers (i.e. MPI version &lt; 2)</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mpiexec</span> <span class="o">-</span><span class="n">n</span> <span class="o">&lt;</span><span class="nb">max</span> <span class="n">workers</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">mpi4py</span><span class="o">.</span><span class="n">futures</span> <span class="o">&lt;</span><span class="n">python</span> <span class="n">script</span><span class="o">&gt;</span>
</pre></div>
</div>
</dd>
<dt>Call using slurm:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; srun -n $SLURM_NTASKS --mpi=pmi2 python -m mpi4py.futures &lt;python script&gt;
</pre></div>
</div>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_chunks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_mpi.html#MPIEstimator.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Distributes the given chunks of a task to Estimators on worker ranks using MPI.</p>
<p>Needs to be called with kwargs only.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>n_chunks<span class="classifier">int  [optional]</span></dt><dd><p>Number of chunks to split the data into, default=1.</p>
</dd>
<dt>data<span class="classifier">dict[str, Sequence]</span></dt><dd><p>Dictionary of random variable realizations</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>Estimates of information-theoretic quantities as np.double
values</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate_surrogates_analytic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_mpi.html#MPIEstimator.estimate_surrogates_analytic"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Forward analytic estimation to the base Estimator.</p>
<p>Analytic estimation is assumed to have shorter runtime and is thus
performed on rank 0 alone for now.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_mpi.html#MPIEstimator.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Test if the base Estimator is an analytic null estimator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_mpi.html#MPIEstimator.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="pid-estimators">
<h2>PID Estimators<a class="headerlink" href="#pid-estimators" title="Permalink to this headline">¶</a></h2>
<p>Partical information decomposition for discrete random variables.</p>
<p>This module provides an estimator for partial information decomposition
as proposed in</p>
<p>Bertschinger, N., Rauh, J., Olbrich, E., Jost, J., &amp; Ay, N. (2014). Quantifying
Unique Information. Entropy, 16(4), 2161–2183. <a class="reference external" href="http://doi.org/10.3390/e16042161">http://doi.org/10.3390/e16042161</a></p>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_pid.</span></span><span class="sig-name descname"><span class="pre">SydneyPID</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#SydneyPID"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate partial information decomposition of discrete variables.</p>
<p>Fast implementation of the BROJA partial information decomposition (PID)
estimator for discrete data (Bertschinger, 2014). The estimator does not
require JAVA or GPU modules to run.</p>
<p>The estimator finds shared information, unique information and
synergistic information between the two inputs s1 and s2 with respect to
the output t.</p>
<p>Improved version with larger initial swaps and checking for convergence of
both the unique information from sources 1 and 2. The function counts the
empirical observations, calculates probabilities and the initial CMI, then
does the vitrualised swaps until it has converged, and finally calculates
the PID. The virtualised swaps stage contains two loops. An inner loop
which actually does the virtualised swapping, keeping the changes if the
CMI decreases; and an outer loop which decreases the size of the
probability mass increment the virtualised swapping utilises.</p>
<p>References</p>
<ul class="simple">
<li><p>Bertschinger, N., Rauh, J., Olbrich, E., Jost, J., &amp; Ay, N. (2014).
Quantifying unique information. Entropy, 16(4), 2161–2183.
<a class="reference external" href="http://doi.org/10.3390/e16042161">http://doi.org/10.3390/e16042161</a></p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>estimation parameters</p>
<ul class="simple">
<li><p>alph_s1 : int - alphabet size of s1</p></li>
<li><p>alph_s2 : int - alphabet size of s2</p></li>
<li><p>alph_t : int - alphabet size of t</p></li>
<li><p>max_unsuc_swaps_row_parm : int - soft limit for virtualised swaps
based on the number of unsuccessful swaps attempted in a row.
If there are too many unsuccessful swaps in a row, then it
will break the inner swap loop; the outer loop decrements the
size of the probability mass increment and then attemps
virtualised swaps again with the smaller probability increment.
The exact number of unsuccessful swaps allowed before breaking
is the total number of possible swaps (given our alphabet
sizes) times the control parameter max_unsuc_swaps_row_parm,
e.g., if the parameter is set to 3, this gives a high degree of
confidence that nearly (if not) all of the possible swaps have
been attempted before this soft limit breaks the swap loop.</p></li>
<li><p>num_reps : int -  number of times the outer loop will halve the
size of the probability increment used for the virtualised
swaps. This is in direct correspondence with the number of times
the empirical data was replicated in your original
implementation.</p></li>
<li><p>max_iters : int - provides a hard upper bound on the number of
times it will attempt to perform virtualised swaps in the inner
loop. However, this hard limit is (practically) never used as it
should always hit the soft limit defined above (parameter may be
removed in the future).</p></li>
<li><p>verbose : bool [optional] - print output to console
(default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#SydneyPID.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>s1<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
<dt>s2<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
<dt>t<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>estimated decomposition, contains the joint distribution,
unique, shared, and synergistic information</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#SydneyPID.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#SydneyPID.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_pid.</span></span><span class="sig-name descname"><span class="pre">TartuPID</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#TartuPID"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Estimate partial information decomposition for two inputs and one output</p>
<p>Implementation of the partial information decomposition (PID) estimator for
discrete data. The estimator finds shared information, unique information
and synergistic information between the two inputs s1 and s2 with respect
to the output t.</p>
<p>The algorithm uses exponential cone programming and requires the Python
package for ECOS: Embedded Cone Solver (<a class="reference external" href="https://pypi.python.org/pypi/ecos">https://pypi.python.org/pypi/ecos</a>).</p>
<p>References:</p>
<ul class="simple">
<li><p>Makkeh, A., Theis, D.O., &amp; Vicente, R. (2017). Bivariate Partial
Information Decomposition: The Optimization Perspective. Entropy, 19(10),
530.</p></li>
<li><p>Makkeh, A., Theis, D.O., &amp; Vicente, R. (2018). BROJA-2PID: A cone
programming based Partial Information Decomposition estimator. Entropy,
20(271), <a class="reference external" href="https://github.com/Abzinger/BROJA_2PID">https://github.com/Abzinger/BROJA_2PID</a>.</p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>estimation parameters (with default parameters)</p>
<ul class="simple">
<li><p>verbose : bool [optional] - print output to console
(default=False)</p></li>
<li><p>cone_solver : str [optional] - which cone solver to use
(default=’ECOS’)</p></li>
<li><p>solver_args : dict [optional] - solver arguments (default={})</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#TartuPID.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>s1<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
<dt>s2<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
<dt>t<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>estimated decomposition, solver used, numerical error</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#TartuPID.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#TartuPID.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Information theoretic estimators</a><ul>
<li><a class="reference internal" href="#jidt-estimators-cpu">JIDT Estimators (CPU)</a></li>
<li><a class="reference internal" href="#python-estimators-cpu">Python Estimators (CPU)</a></li>
<li><a class="reference internal" href="#opencl-estimators-gpu">OpenCL Estimators (GPU)</a></li>
<li><a class="reference internal" href="#mpi-estimators-cpu">MPI Estimators (CPU)</a></li>
<li><a class="reference internal" href="#pid-estimators">PID Estimators</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="idtxl_results_class.html"
                          title="previous chapter">The Results Class</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="idtxl_postprocessing.html"
                          title="next chapter">Postprocessing of inferred networks</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/idtxl_estimators.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="idtxl_postprocessing.html" title="Postprocessing of inferred networks"
             >next</a> |</li>
        <li class="right" >
          <a href="idtxl_results_class.html" title="The Results Class"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">IDTxl 1.5.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Information theoretic estimators</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Patricia Wollstadt, Joseph T. Lizier, Raul Vicente, Conor Finn, Mario Martinez-Zarzuela, Pedro Mediano, Leonardo Novelli, Michael Wibral.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>