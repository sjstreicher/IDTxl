
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>idtxl package &#8212; IDTxl 1.5.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/pyramid.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Helper functions" href="idtxl_helper.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="idtxl_helper.html" title="Helper functions"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">IDTxl 1.5.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">idtxl package</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="idtxl-package">
<h1>idtxl package<a class="headerlink" href="#idtxl-package" title="Permalink to this headline">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</section>
<section id="module-idtxl.data">
<span id="idtxl-data-module"></span><h2>idtxl.data module<a class="headerlink" href="#module-idtxl.data" title="Permalink to this headline">¶</a></h2>
<p>Provide data structures for IDTxl analysis.</p>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.data.Data">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.data.</span></span><span class="sig-name descname"><span class="pre">Data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'psr'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Store data for information dynamics estimation.</p>
<p>Data takes a 1- to 3-dimensional array representing realisations of random
variables in dimensions: processes, samples (over time), and replications.
If necessary, data reshapes provided realisations to fit the format
expected by IDTxl, which is a 3-dimensional array with axes representing
(process index, sample index, replication index). Indicate the actual order
of dimensions in the provided array in a three-character string, e.g. ‘spr’
for an array with realisations over (1) samples in time, (2) processes, (3)
replications.</p>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data_mute</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>              <span class="c1"># initialise empty data object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_mute</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">()</span>  <span class="c1"># simulate data from MuTE paper</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create data objects with data of various sizes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>  <span class="c1"># 2 procs.,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_1</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dim_order</span><span class="o">=</span><span class="s1">&#39;psr&#39;</span><span class="p">)</span>           <span class="c1"># 1000 samples, 5 repl.</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span>  <span class="c1"># 3 procs.,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_2</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dim_order</span><span class="o">=</span><span class="s1">&#39;ps&#39;</span><span class="p">)</span>        <span class="c1"># 1000 samples</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Overwrite data in existing object with random data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_2</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">data_new</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Note:</dt><dd><p>Realisations are stored as attribute ‘data’. This can only be set via
the ‘set_data()’ method.</p>
</dd>
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">numpy array [optional]</span></dt><dd><p>1/2/3-dimensional array with raw data</p>
</dd>
<dt>dim_order<span class="classifier">string [optional]</span></dt><dd><p>order of dimensions, accepts any combination of the characters
‘p’, ‘s’, and ‘r’ for processes, samples, and replications; must
have the same length as the data dimensionality, e.g., ‘ps’ for a
two-dimensional array of data from several processes over time
(default=’psr’)</p>
</dd>
<dt>normalise<span class="classifier">bool [optional]</span></dt><dd><p>if True, data gets normalised per process (default=True)</p>
</dd>
<dt>seed<span class="classifier">int [optional]</span></dt><dd><p>can be set to a fixed integer to get repetitive results on the
same data with multiple runs of analyses. Otherwise a random
seed is set as default.</p>
</dd>
</dl>
</dd>
<dt>Attributes:</dt><dd><dl class="simple">
<dt>data<span class="classifier">numpy array</span></dt><dd><p>realisations, can only be set via ‘set_data’ method</p>
</dd>
<dt>n_processes<span class="classifier">int</span></dt><dd><p>number of processes</p>
</dd>
<dt>n_replications<span class="classifier">int</span></dt><dd><p>number of replications</p>
</dd>
<dt>n_samples<span class="classifier">int</span></dt><dd><p>number of samples in time</p>
</dd>
<dt>normalise<span class="classifier">bool</span></dt><dd><p>if true, all data gets z-standardised per process</p>
</dd>
<dt>initial_state<span class="classifier">array</span></dt><dd><p>initial state of the seed for shuffled permutations</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="idtxl.data.Data.data">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">data</span></span><a class="headerlink" href="#idtxl.data.Data.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return data array.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.data.Data.generate_logistic_maps_data">
<span class="sig-name descname"><span class="pre">generate_logistic_maps_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_replications</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coefficient_matrices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([[[0.5,</span> <span class="pre">0.],</span> <span class="pre">[0.4,</span> <span class="pre">0.5]]])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.generate_logistic_maps_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.generate_logistic_maps_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate discrete-time coupled-logistic-maps time series.</p>
<p>Generate data and overwrite the instance’s current data.</p>
<p>The implemented logistic map function is f(x) = 4 * x * (1 - x).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>n_samples<span class="classifier">int [optional]</span></dt><dd><p>number of samples simulated for each process and replication</p>
</dd>
<dt>n_replications<span class="classifier">int [optional]</span></dt><dd><p>number of replications</p>
</dd>
<dt>coefficient_matrices<span class="classifier">numpy array [optional]</span></dt><dd><p>coefficient matrices: numpy array with dimensions
(order, number of processes, number of processes). Each
square coefficient matrix corresponds to a lag, starting from
lag=1. The total number of provided matrices implicitly
determines the order of the stochastic process.
(default = np.array([[[0.5, 0], [0.4, 0.5]]]))</p>
</dd>
<dt>noise_std<span class="classifier">float [optional]</span></dt><dd><p>standard deviation of uncorrelated Gaussian noise
(default = 0.1)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.data.Data.generate_mute_data">
<span class="sig-name descname"><span class="pre">generate_mute_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_replications</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.generate_mute_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.generate_mute_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate example data for a 5-process network.</p>
<p>Generate example data and overwrite the instance’s current data. The
network is used as an example the paper on the MuTE toolbox (Montalto,
PLOS ONE, 2014, eq. 14) and was orginally proposed by Baccala &amp;
Sameshima (2001). The network consists of five auto-regressive (AR)
processes with model orders 2 and the following (non-linear) couplings:</p>
<p>0 -&gt; 1, u = 2 (non-linear)
0 -&gt; 2, u = 3
0 -&gt; 3, u = 2 (non-linear)
3 -&gt; 4, u = 1
4 -&gt; 3, u = 1</p>
<p>References:</p>
<ul class="simple">
<li><p>Montalto, A., Faes, L., &amp; Marinazzo, D. (2014) MuTE: A MATLAB toolbox
to compare established and novel estimators of the multivariate
transfer entropy. PLoS ONE 9(10): e109462.
<a class="reference external" href="https://doi.org/10.1371/journal.pone.0109462">https://doi.org/10.1371/journal.pone.0109462</a></p></li>
<li><p>Baccala, L.A. &amp; Sameshima, K. (2001). Partial directed coherence: a
new concept in neural structure determination. Biol Cybern 84:
463–474. <a class="reference external" href="https://doi.org/10.1007/PL00007990">https://doi.org/10.1007/PL00007990</a></p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>n_samples<span class="classifier">int</span></dt><dd><p>number of samples simulated for each process and replication</p>
</dd>
<dt>n_replications<span class="classifier">int</span></dt><dd><p>number of replications</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.data.Data.generate_var_data">
<span class="sig-name descname"><span class="pre">generate_var_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_replications</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coefficient_matrices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([[[0.5,</span> <span class="pre">0.],</span> <span class="pre">[0.4,</span> <span class="pre">0.5]]])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.generate_var_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.generate_var_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate discrete-time VAR (vector auto-regressive) time series.</p>
<p>Generate data and overwrite the instance’s current data.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>n_samples<span class="classifier">int [optional]</span></dt><dd><p>number of samples simulated for each process and replication</p>
</dd>
<dt>n_replications<span class="classifier">int [optional]</span></dt><dd><p>number of replications</p>
</dd>
<dt>coefficient_matrices<span class="classifier">numpy array [optional]</span></dt><dd><p>coefficient matrices: numpy array with dimensions
(VAR order, number of processes, number of processes). Each
square coefficient matrix corresponds to a lag, starting from
lag=1. The total number of provided matrices implicitly
determines the order of the VAR process.
(default = np.array([[[0.5, 0], [0.4, 0.5]]]))</p>
</dd>
<dt>noise_std<span class="classifier">float [optional]</span></dt><dd><p>standard deviation of uncorrelated Gaussian noise
(default = 0.1)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.data.Data.get_realisations">
<span class="sig-name descname"><span class="pre">get_realisations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shuffle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.get_realisations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.get_realisations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return realisations for a list of indices.</p>
<p>Return realisations for indices in list. Optionally, realisations can
be shuffled to create surrogate data for statistical testing. For
shuffling, data blocks are permuted over replications while their
temporal order stays intact within replications:</p>
<dl>
<dt>Original data:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 8%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1</p></td>
<td><p>2 2 2 2</p></td>
<td><p>3 3 3 3</p></td>
<td><p>4 4 4 4</p></td>
<td><p>5 5 5 5</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Shuffled data:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 8%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>3 3 3 3</p></td>
<td><p>1 1 1 1</p></td>
<td><p>4 4 4 4</p></td>
<td><p>2 2 2 2</p></td>
<td><p>5 5 5 5</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Args:</dt><dd><dl class="simple">
<dt>idx_list: list of tuples</dt><dd><p>variable indices</p>
</dd>
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current value in current analysis, has to have the
form (idx process, idx sample); if current_value == idx, all
samples for a process are returned</p>
</dd>
<dt>shuffle: bool</dt><dd><p>if true permute blocks of replications over trials</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>realisations with dimensions (no. samples * no.replications) x
number of indices</p>
</dd>
<dt>numpy array</dt><dd><p>replication index for each realisation with dimensions (no.
samples * no.replications) x number of indices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.data.Data.get_seed">
<span class="sig-name descname"><span class="pre">get_seed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.get_seed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.get_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>return the initial seed of the data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.data.Data.get_state">
<span class="sig-name descname"><span class="pre">get_state</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.get_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.get_state" title="Permalink to this definition">¶</a></dt>
<dd><p>return the current state of the random seed</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.data.Data.n_realisations">
<span class="sig-name descname"><span class="pre">n_realisations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.n_realisations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.n_realisations" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of realisations over samples and replications.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>current_value<span class="classifier">tuple [optional]</span></dt><dd><p>reference point for calculation of number of realisations
(e.g. when using an embedding of length k, we count
realisations from the k+1th sample because we loose the first k
samples to the embedding); if no current_value is provided, the
number of all samples is used</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.data.Data.n_realisations_repl">
<span class="sig-name descname"><span class="pre">n_realisations_repl</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.n_realisations_repl"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.n_realisations_repl" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of realisations over replications.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.data.Data.n_realisations_samples">
<span class="sig-name descname"><span class="pre">n_realisations_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.n_realisations_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.n_realisations_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of realisations over samples.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>current_value<span class="classifier">tuple [optional]</span></dt><dd><p>reference point for calculation of number of realisations
(e.g. when using an embedding of length k, the current value is
at sample k + 1; we thus count realisations from the k + 1st
sample because we loose the first k samples to the embedding)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.data.Data.permute_replications">
<span class="sig-name descname"><span class="pre">permute_replications</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.permute_replications"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.permute_replications" title="Permalink to this definition">¶</a></dt>
<dd><p>Return realisations with permuted replications (time stays intact).</p>
<p>Create surrogate data by permuting realisations over replications while
keeping the temporal structure (order of samples) intact. Return
realisations for all indices in the list, where an index is expected to
have the form (process index, sample index). Realisations are permuted
block-wise by permuting the order of replications:</p>
<dl>
<dt>Original data:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 8%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1</p></td>
<td><p>2 2 2 2</p></td>
<td><p>3 3 3 3</p></td>
<td><p>4 4 4 4</p></td>
<td><p>5 5 5 5</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Permuted data:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 8%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>3 3 3 3</p></td>
<td><p>1 1 1 1</p></td>
<td><p>4 4 4 4</p></td>
<td><p>2 2 2 2</p></td>
<td><p>5 5 5 5</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Args:</dt><dd><dl class="simple">
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current_value in the data</p>
</dd>
<dt>idx_list<span class="classifier">list of tuples</span></dt><dd><p>indices of variables</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>permuted realisations with dimensions replications x number of
indices</p>
</dd>
<dt>numpy array</dt><dd><p>replication index for each realisation</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><p>TypeError if idx_realisations is not a list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.data.Data.permute_samples">
<span class="sig-name descname"><span class="pre">permute_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perm_settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.permute_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.permute_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Return realisations with permuted samples (repl. stays intact).</p>
<p>Create surrogate data by permuting realisations over samples (time)
while keeping the order of replications intact. Surrogates can be
created for multiple variables in parallel, where variables are
provided as a list of indices. An index is expected to have the form
(process index, sample index).</p>
<p>Permuting samples in time is the fall-back option for surrogate data
creation. The default method for surrogate data creation is the
permutation of replications, while keeping the order of samples in time
intact. If the number of replications is too small to allow for a
sufficient number of permutations for the generation of surrogate data,
permutation of samples in time is chosen instead.</p>
<p>Different permutation strategies can be chosen to permute realisations
in time. Note that if data consists of multiple replications, within
each replication, samples are shuffled following the same permutation
pattern:</p>
<dl>
<dt>Original data:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>1 2 3 4 5 6 7 8</p></td>
<td><p>1 2 3 4 5 6 7 8</p></td>
<td><p>1 2 3 4 5 6 7 8</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Circular shift by a random number of samples, e.g. 4 samples:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>5 6 7 8 1 2 3 4</p></td>
<td><p>5 6 7 8 1 2 3 4</p></td>
<td><p>5 6 7 8 1 2 3 4</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Permute blocks of 3 samples:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>4 5 6 7 8 1 2 3</p></td>
<td><p>4 5 6 7 8 1 2 3</p></td>
<td><p>4 5 6 7 8 1 2 3</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Permute data locally within a range of 4 samples:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>1 2 4 3 8 5 6 7</p></td>
<td><p>1 2 4 3 8 5 6 7</p></td>
<td><p>1 2 4 3 8 5 6 7</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Random permutation:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>4 2 5 7 1 3 2 6</p></td>
<td><p>4 2 5 7 1 3 2 6</p></td>
<td><p>4 2 5 7 1 3 2 6</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Args:</dt><dd><dl>
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current_value in the data</p>
</dd>
<dt>idx_list<span class="classifier">list of tuples</span></dt><dd><p>indices of variables</p>
</dd>
<dt>perm_settings<span class="classifier">dict</span></dt><dd><p>settings specifying the allowed permutations:</p>
<ul>
<li><p>perm_type : str
permutation type, can be</p>
<blockquote>
<div><ul class="simple">
<li><p>‘random’: swaps samples at random,</p></li>
<li><p>‘circular’: shifts time series by a random number of
samples</p></li>
<li><p>‘block’: swaps blocks of samples,</p></li>
<li><p>‘local’: swaps samples within a given range, or</p></li>
</ul>
</div></blockquote>
</li>
<li><p>additional settings depending on the perm_type (n is the
number of samples):</p>
<blockquote>
<div><ul>
<li><p>if perm_type == ‘circular’:</p>
<dl class="simple">
<dt>‘max_shift’<span class="classifier">int</span></dt><dd><p>the maximum number of samples for shifting
(e.g., number of samples / 2)</p>
</dd>
</dl>
</li>
<li><p>if perm_type == ‘block’:</p>
<dl class="simple">
<dt>‘block_size’<span class="classifier">int</span></dt><dd><p>no. samples per block (e.g., number of samples / 10)</p>
</dd>
<dt>‘perm_range’<span class="classifier">int</span></dt><dd><p>range in which blocks can be swapped (e.g., number
of samples / block_size)</p>
</dd>
</dl>
</li>
<li><p>if perm_type == ‘local’:</p>
<dl class="simple">
<dt>‘perm_range’<span class="classifier">int</span></dt><dd><p>range in samples over which realisations can be
permuted (e.g., number of samples / 10)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>permuted realisations with dimensions replications x number of
indices</p>
</dd>
<dt>numpy array</dt><dd><p>sample index for each realisation</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><p>TypeError if idx_realisations is not a list</p>
</dd>
<dt>Note:</dt><dd><p>This permutation scheme is the fall-back option if surrogate data
can not be created by shuffling replications because the number of
replications is too small to generate the requested number of
permutations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.data.Data.set_data">
<span class="sig-name descname"><span class="pre">set_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_order</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.set_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite data in an existing Data object.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">numpy array</span></dt><dd><p>1- to 3-dimensional array of realisations</p>
</dd>
<dt>dim_order<span class="classifier">string</span></dt><dd><p>order of dimensions, accepts any combination of the characters
‘p’, ‘s’, and ‘r’ for processes, samples, and replications;
must have the same length as number of dimensions in data</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.data.Data.slice_permute_replications">
<span class="sig-name descname"><span class="pre">slice_permute_replications</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.slice_permute_replications"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.slice_permute_replications" title="Permalink to this definition">¶</a></dt>
<dd><p>Return data slice with permuted replications (time stays intact).</p>
<p>Create surrogate data by permuting realisations over replications while
keeping the temporal structure (order of samples) intact. Return
realisations for all indices in the list, where an index is expected to
have the form (process index, sample index). Realisations are permuted
block-wise by permuting the order of replications</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.data.Data.slice_permute_samples">
<span class="sig-name descname"><span class="pre">slice_permute_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perm_settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.slice_permute_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.slice_permute_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Return slice of data with permuted samples (repl. stays intact).</p>
<p>Create surrogate data by permuting data in a slice over samples (time)
while keeping the order of replications intact. Return slice for the
entry specified by ‘process’. Realisations are permuted according to
the settings specified in perm_settings:</p>
<dl>
<dt>Original data:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>1 2 3 4 5 6 7 8</p></td>
<td><p>1 2 3 4 5 6 7 8</p></td>
<td><p>1 2 3 4 5 6 7 8</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Circular shift by 2, 6, and 4 samples:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>7 8 1 2 3 4 5 6</p></td>
<td><p>3 4 5 6 7 8 1 2</p></td>
<td><p>5 6 7 8 1 2 3 4</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Permute blocks of 3 samples:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>4 5 6 7 8 1 2 3</p></td>
<td><p>1 2 3 7 8 4 5 6</p></td>
<td><p>7 8 4 5 6 1 2 3</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Permute data locally within a range of 4 samples:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>1 2 4 3 8 5 6 7</p></td>
<td><p>4 1 2 3 5 7 8 6</p></td>
<td><p>3 1 2 4 8 5 6 7</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Random permutation:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>4 2 5 7 1 3 2 6</p></td>
<td><p>7 5 3 4 2 1 8 5</p></td>
<td><p>1 2 4 3 6 8 7 5</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>Permuting samples is the fall-back option for surrogate creation if the
number of replications is too small to allow for a sufficient number of
permutations for the generation of surrogate data.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>process<span class="classifier">int</span></dt><dd><p>process for which to return data slice</p>
</dd>
<dt>perm_settings<span class="classifier">dict</span></dt><dd><p>settings specifying the allowed permutations:</p>
<ul>
<li><p>perm_type : str
permutation type, can be</p>
<blockquote>
<div><ul class="simple">
<li><p>‘circular’: shifts time series by a random
number of samples</p></li>
<li><p>‘block’: swaps blocks of samples,</p></li>
<li><p>‘local’: swaps samples within a given range, or</p></li>
<li><p>‘random’: swaps samples at random,</p></li>
</ul>
</div></blockquote>
</li>
<li><p>additional settings depending on the perm_type (n is the
number of samples):</p>
<blockquote>
<div><ul>
<li><p>if perm_type == ‘circular’:</p>
<dl class="simple">
<dt>‘max_shift’<span class="classifier">int</span></dt><dd><p>the maximum number of samples for shifting
(default=n/2)</p>
</dd>
</dl>
</li>
<li><p>if perm_type == ‘block’:</p>
<dl class="simple">
<dt>‘block_size’<span class="classifier">int</span></dt><dd><p>no. samples per block (default=n/10)</p>
</dd>
<dt>‘perm_range’<span class="classifier">int</span></dt><dd><p>range in which blocks can be swapped (default=max)</p>
</dd>
</dl>
</li>
<li><p>if perm_type == ‘local’:</p>
<dl class="simple">
<dt>‘perm_range’<span class="classifier">int</span></dt><dd><p>range in samples over which realisations can be
permuted (default=n/10)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>data slice with data permuted over samples with dimensions
samples x number of replications</p>
</dd>
<dt>numpy array</dt><dd><p>index of permuted samples</p>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>This permutation scheme is the fall-back option if the number of
replications is too small to allow a sufficient number of
permutations for the generation of surrogate data.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.bivariate_te">
<span id="idtxl-bivariate-te-module"></span><h2>idtxl.bivariate_te module<a class="headerlink" href="#module-idtxl.bivariate_te" title="Permalink to this headline">¶</a></h2>
<p>Perform network inference using multivarate transfer entropy.</p>
<p>Estimate multivariate transfer entropy (TE) for network inference using a
greedy approach with maximum statistics to generate a non-uniform embedding
(Faes, 2011; Lizier, 2012).</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Written for Python 3.4+</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.bivariate_te.BivariateTE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.bivariate_te.</span></span><span class="sig-name descname"><span class="pre">BivariateTE</span></span><a class="reference internal" href="_modules/idtxl/bivariate_te.html#BivariateTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_te.BivariateTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInferenceTE" title="idtxl.network_inference.NetworkInferenceTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInferenceTE</span></code></a>, <a class="reference internal" href="#idtxl.network_inference.NetworkInferenceBivariate" title="idtxl.network_inference.NetworkInferenceBivariate"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInferenceBivariate</span></code></a></p>
<p>Perform network inference using bivariate transfer entropy.</p>
<p>Perform network inference using bivariate transfer entropy (TE). To
perform network inference call analyse_network() on the whole network or a
set of nodes or call analyse_single_target() to estimate TE for a single
target. See docstrings of the two functions for more information.</p>
<p>References:</p>
<ul class="simple">
<li><p>Schreiber, T. (2000). Measuring Information Transfer. Phys Rev Lett,
85(2), 461–464. <a class="reference external" href="http://doi.org/10.1103/PhysRevLett.85.461">http://doi.org/10.1103/PhysRevLett.85.461</a></p></li>
<li><p>Vicente, R., Wibral, M., Lindner, M., &amp; Pipa, G. (2011). Transfer
entropy-a model-free measure of effective connectivity for the
neurosciences. J Comp Neurosci, 30(1), 45–67.
<a class="reference external" href="http://doi.org/10.1007/s10827-010-0262-3">http://doi.org/10.1007/s10827-010-0262-3</a></p></li>
<li><p>Lizier, J. T., &amp; Rubinov, M. (2012). Multivariate construction of
effective computational networks from observational data. Max Planck
Institute: Preprint. Retrieved from
<a class="reference external" href="http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf">http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf</a></p></li>
<li><p>Faes, L., Nollo, G., &amp; Porta, A. (2011). Information-based detection
of nonlinear Granger causality in multivariate processes via a
nonuniform embedding technique. Phys Rev E, 83, 1–15.
<a class="reference external" href="http://doi.org/10.1103/PhysRevE.83.051112">http://doi.org/10.1103/PhysRevE.83.051112</a></p></li>
</ul>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>source_set<span class="classifier">list</span></dt><dd><p>indices of source processes tested for their influence on the
target</p>
</dd>
<dt>target<span class="classifier">list</span></dt><dd><p>index of target process</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>analysis settings</p>
</dd>
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current value in TE estimation, (idx process,
idx sample)</p>
</dd>
<dt>selected_vars_full<span class="classifier">list of tuples</span></dt><dd><p>samples in the full conditional set, (idx process, idx sample)</p>
</dd>
<dt>selected_vars_sources<span class="classifier">list of tuples</span></dt><dd><p>source samples in the conditional set, (idx process, idx sample)</p>
</dd>
<dt>selected_vars_target<span class="classifier">list of tuples</span></dt><dd><p>target samples in the conditional set, (idx process, idx sample)</p>
</dd>
<dt>pvalue_omnibus<span class="classifier">float</span></dt><dd><p>p-value of the omnibus test</p>
</dd>
<dt>pvalues_sign_sources<span class="classifier">numpy array</span></dt><dd><p>array of p-values for TE from individual sources to the target</p>
</dd>
<dt>statistic_omnibus<span class="classifier">float</span></dt><dd><p>joint TE from all sources to the target</p>
</dd>
<dt>statistic_sign_sources<span class="classifier">numpy array</span></dt><dd><p>raw TE values from individual sources to the target</p>
</dd>
<dt>sign_ominbus<span class="classifier">bool</span></dt><dd><p>statistical significance of the over-all TE</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.bivariate_te.BivariateTE.analyse_network">
<span class="sig-name descname"><span class="pre">analyse_network</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/bivariate_te.html#BivariateTE.analyse_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_te.BivariateTE.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Find bivariate transfer entropy between all nodes in the network.</p>
<p>Estimate bivariate transfer entropy (TE) between all nodes in the
network or between selected sources and targets.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a detailed description of the algorithm and settings see
documentation of the analyse_single_target() method and references
in the class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag&#39;</span><span class="p">:</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">BivariateTE</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, settings
can further contain</p>
<ul class="simple">
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>targets<span class="classifier">list of int | ‘all’ [optional]</span></dt><dd><p>index of target processes (default=’all’)</p>
</dd>
<dt>sources<span class="classifier">list of int | list of list | ‘all’  [optional]</span></dt><dd><p>indices of source processes for each target (default=’all’);
if ‘all’, all network nodes excluding the target node are
considered as potential sources and tested;
if list of int, the source specified by each int is tested as
a potential source for the target with the same index or a
single target;
if list of list, sources specified in each inner list are
tested for the target with the same index</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsNetworkInference instance</dt><dd><p>results of network inference, see documentation of
ResultsNetworkInference()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.bivariate_te.BivariateTE.analyse_single_target">
<span class="sig-name descname"><span class="pre">analyse_single_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/bivariate_te.html#BivariateTE.analyse_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_te.BivariateTE.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Find bivariate transfer entropy between sources and a target.</p>
<p>Find bivariate transfer entropy (TE) between all potential source
processes and the target process. Uses bivariate, non-uniform embedding
found through information maximisation.</p>
<p>Bivariate TE is calculated in four steps:</p>
<ol class="arabic simple">
<li><p>find all relevant variables in the target processes’ own past, by
iteratively adding candidate variables that have significant
conditional mutual information (CMI) with the current value
(conditional on all variables that were added previously)</p></li>
<li><p>find all relevant variables in the single source processes’ pasts
(again by finding all candidates with significant CMI); treat each
potential source process separately, i.e., the CMI is calculated
with respect to already selected variables from the target’s past
and from the current processes’ past only</p></li>
<li><p>prune the final conditional set for each link (i.e., each
process-target pairing): test the CMI between each variable in
the final set and the current value, conditional on all other
variables in the final set of the current link</p></li>
<li><p>statistics on the final set of sources (test for over-all transfer
between the final conditional set and the current value, and for
significant transfer of all individual variables in the set)</p></li>
</ol>
<dl class="simple">
<dt>Note:</dt><dd><p>For a further description of the algorithm see references in the
class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag&#39;</span><span class="p">:</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">BivariateTE</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                 <span class="n">data</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                 <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing:</p>
<ul class="simple">
<li><p>cmi_estimator : str - estimator to be used for CMI
calculation (for estimator settings see the documentation in
the estimators_* modules)</p></li>
<li><p>max_lag_sources : int - maximum temporal search depth for
candidates in the sources’ past in samples</p></li>
<li><p>min_lag_sources : int - minimum temporal search depth for
candidates in the sources’ past in samples</p></li>
<li><p>max_lag_target : int [optional] - maximum temporal search
depth for candidates in the target’s past in samples
(default=same as max_lag_sources)</p></li>
<li><p>tau_sources : int [optional] - spacing between candidates in
the sources’ past in samples (default=1)</p></li>
<li><p>tau_target : int [optional] - spacing between candidates in
the target’s past in samples (default=1)</p></li>
<li><p>n_perm_* : int - number of permutations, where * can be
‘max_stat’, ‘min_stat’, ‘omnibus’, and ‘max_seq’
(default=500)</p></li>
<li><p>alpha_* : float - critical alpha level for statistical
significance, where * can be ‘max_stats’,  ‘min_stats’, and
‘omnibus’ (default=0.05)</p></li>
<li><p>add_conditionals : list of tuples | str [optional] - force
the estimator to add these conditionals when estimating TE;
can either be a list of variables, where each variable is
described as (idx process, lag wrt to current value) or can
be a string: ‘faes’ for Faes-Method (see references)</p></li>
<li><p>permute_in_time : bool [optional] - force surrogate creation
by shuffling realisations in time instead of shuffling
replications; see documentation of Data.permute_samples() for
further settings (default=False)</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>write_ckp : bool [optional] - enable checkpointing, writes
analysis state to disk every time a variable is selected;
resume crashed analysis using
network_analysis.resume_checkpoint() (default=False)</p></li>
<li><p>filename_ckp : str [optional] - checkpoint file name (without
extension) (default=’./idtxl_checkpoint’)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sources<span class="classifier">list of int | int | ‘all’ [optional]</span></dt><dd><p>single index or list of indices of source processes
(default=’all’), if ‘all’, all network nodes excluding the
target node are considered as potential sources</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsNetworkInference instance</dt><dd><p>results of network inference, see documentation of
ResultsNetworkInference()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.bivariate_mi">
<span id="idtxl-bivariate-mi-module"></span><h2>idtxl.bivariate_mi module<a class="headerlink" href="#module-idtxl.bivariate_mi" title="Permalink to this headline">¶</a></h2>
<p>Perform network inference using bivarate mutual information.</p>
<p>Estimate bivariate mutual information (MI) for network inference using a
greedy approach with maximum statistics to generate a non-uniform embedding
(Faes, 2011; Lizier, 2012).</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Written for Python 3.4+</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.bivariate_mi.BivariateMI">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.bivariate_mi.</span></span><span class="sig-name descname"><span class="pre">BivariateMI</span></span><a class="reference internal" href="_modules/idtxl/bivariate_mi.html#BivariateMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_mi.BivariateMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInferenceMI" title="idtxl.network_inference.NetworkInferenceMI"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInferenceMI</span></code></a>, <a class="reference internal" href="#idtxl.network_inference.NetworkInferenceBivariate" title="idtxl.network_inference.NetworkInferenceBivariate"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInferenceBivariate</span></code></a></p>
<p>Perform network inference using bivariate mutual information.</p>
<p>Perform network inference using bivariate mutual information (MI). To
perform network inference call analyse_network() on the whole network or a
set of nodes or call analyse_single_target() to estimate MI for a single
target. See docstrings of the two functions for more information.</p>
<p>References:</p>
<ul class="simple">
<li><p>Lizier, J. T., &amp; Rubinov, M. (2012). Multivariate construction of
effective computational networks from observational data. Max Planck
Institute: Preprint. Retrieved from
<a class="reference external" href="http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf">http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf</a></p></li>
<li><p>Faes, L., Nollo, G., &amp; Porta, A. (2011). Information-based detection
of nonlinear Granger causality in multivariate processes via a
nonuniform embedding technique. Phys Rev E, 83, 1–15.
<a class="reference external" href="http://doi.org/10.1103/PhysRevE.83.051112">http://doi.org/10.1103/PhysRevE.83.051112</a></p></li>
</ul>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>source_set<span class="classifier">list</span></dt><dd><p>indices of source processes tested for their influence on the
target</p>
</dd>
<dt>target<span class="classifier">list</span></dt><dd><p>index of target process</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>analysis settings</p>
</dd>
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current value in MI estimation, (idx process,
idx sample)</p>
</dd>
<dt>selected_vars_full<span class="classifier">list of tuples</span></dt><dd><p>samples in the full conditional set, (idx process, idx sample)</p>
</dd>
<dt>selected_vars_sources<span class="classifier">list of tuples</span></dt><dd><p>source samples in the conditional set, (idx process, idx sample)</p>
</dd>
<dt>selected_vars_target<span class="classifier">list of tuples</span></dt><dd><p>target samples in the conditional set, (idx process, idx sample)</p>
</dd>
<dt>pvalue_omnibus<span class="classifier">float</span></dt><dd><p>p-value of the omnibus test</p>
</dd>
<dt>pvalues_sign_sources<span class="classifier">numpy array</span></dt><dd><p>array of p-values for MI from individual sources to the target</p>
</dd>
<dt>mi_omnibus<span class="classifier">float</span></dt><dd><p>joint MI from all sources to the target</p>
</dd>
<dt>mi_sign_sources<span class="classifier">numpy array</span></dt><dd><p>raw MI values from individual sources to the target</p>
</dd>
<dt>sign_ominbus<span class="classifier">bool</span></dt><dd><p>statistical significance of the over-all MI</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.bivariate_mi.BivariateMI.analyse_network">
<span class="sig-name descname"><span class="pre">analyse_network</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/bivariate_mi.html#BivariateMI.analyse_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_mi.BivariateMI.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Find bivariate mutual information between all nodes in the network.</p>
<p>Estimate bivariate mutual information (MI) between all nodes in the
network or between selected sources and targets.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a detailed description of the algorithm and settings see
documentation of the analyse_single_target() method and references
in the class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The algorithm uses a conditional mutual information to</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># construct a non-uniform embedding, hence a CMI- not MI-</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimator has to be specified:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag&#39;</span><span class="p">:</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">BivariateMI</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, settings
can further contain</p>
<ul class="simple">
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>targets<span class="classifier">list of int | ‘all’ [optional]</span></dt><dd><p>index of target processes (default=’all’)</p>
</dd>
<dt>sources<span class="classifier">list of int | list of list | ‘all’  [optional]</span></dt><dd><p>indices of source processes for each target (default=’all’);
if ‘all’, all network nodes excluding the target node are
considered as potential sources and tested;
if list of int, the source specified by each int is tested as
a potential source for the target with the same index or a
single target;
if list of list, sources specified in each inner list are
tested for the target with the same index</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>results for each target, see documentation of
analyse_single_target()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.bivariate_mi.BivariateMI.analyse_single_target">
<span class="sig-name descname"><span class="pre">analyse_single_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/bivariate_mi.html#BivariateMI.analyse_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_mi.BivariateMI.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Find bivariate mutual information between sources and a target.</p>
<p>Find bivariate mutual information (MI) between all potential source
processes and the target process. Uses bivariate, non-uniform embedding
found through information maximisation</p>
<p>MI is calculated in three steps:</p>
<ol class="arabic simple">
<li><p>find all relevant variables in a single source processes’ past, by
iteratively adding candidate variables that have significant
conditional mutual information (CMI) with the current value
(conditional on all variables that were added previously)</p></li>
<li><p>prune the final conditional set for each link (i.e., each
process-target pairing): test the CMI between each variable in
the final set and the current value, conditional on all other
variables in the final set of the current link; treat each
potential source process separately, i.e., the CMI is calculated
with respect to already selected variables the current processes’
past only</p></li>
<li><p>statistics on the final set of sources (test for over-all transfer
between the final conditional set and the current value, and for
significant transfer of all individual variables in the set)</p></li>
</ol>
<dl class="simple">
<dt>Note:</dt><dd><p>For a further description of the algorithm see references in the
class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The algorithm uses a conditional mutual information to</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># construct a non-uniform embedding, hence a CMI- not MI-</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimator has to be specified:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag&#39;</span><span class="p">:</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">BivariateMI</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                 <span class="n">data</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                 <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing:</p>
<ul class="simple">
<li><p>cmi_estimator : str - estimator to be used for CMI
calculation (for estimator settings see the documentation in
the estimators_* modules)</p></li>
<li><p>max_lag_sources : int - maximum temporal search depth for
candidates in the sources’ past in samples</p></li>
<li><p>min_lag_sources : int - minimum temporal search depth for
candidates in the sources’ past in samples</p></li>
<li><p>tau_sources : int [optional] - spacing between candidates in
the sources’ past in samples (default=1)</p></li>
<li><p>n_perm_* : int - number of permutations, where * can be
‘max_stat’, ‘min_stat’, ‘omnibus’, and ‘max_seq’
(default=500)</p></li>
<li><p>alpha_* : float - critical alpha level for statistical
significance, where * can be ‘max_stats’,  ‘min_stats’, and
‘omnibus’ (default=0.05)</p></li>
<li><p>add_conditionals : list of tuples | str [optional] - force
the estimator to add these conditionals when estimating MI;
can either be a list of variables, where each variable is
described as (idx process, lag wrt to current value) or can
be a string: ‘faes’ for Faes-Method (see references)</p></li>
<li><p>permute_in_time : bool [optional] - force surrogate creation
by shuffling realisations in time instead of shuffling
replications; see documentation of Data.permute_samples() for
further settings (default=False)</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>write_ckp : bool [optional] - enable checkpointing, writes
analysis state to disk every time a variable is selected;
resume crashed analysis using
network_analysis.resume_checkpoint() (default=False)</p></li>
<li><p>filename_ckp : str [optional] - checkpoint file name (without
extension) (default=’./idtxl_checkpoint’)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sources<span class="classifier">list of int | int | ‘all’ [optional]</span></dt><dd><p>single index or list of indices of source processes
(default=’all’), if ‘all’, all network nodes excluding the
target node are considered as potential sources</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>results consisting of sets of selected variables as (full set,
variables from the sources’ past), pvalues and MI for each
selected variable, the current value for this analysis, results
for omnibus test (joint MI between all selected source
variables and the target, omnibus MI, p-value, and
significance); NOTE that all variables are listed as tuples
(process, lag wrt. current value)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.bivariate_pid">
<span id="idtxl-bivariate-pid-module"></span><h2>idtxl.bivariate_pid module<a class="headerlink" href="#module-idtxl.bivariate_pid" title="Permalink to this headline">¶</a></h2>
<p>Estimate partial information decomposition (PID).</p>
<p>Estimate PID for two source and one target process using different estimators.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Written for Python 3.4+</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.bivariate_pid.BivariatePID">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.bivariate_pid.</span></span><span class="sig-name descname"><span class="pre">BivariatePID</span></span><a class="reference internal" href="_modules/idtxl/bivariate_pid.html#BivariatePID"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_pid.BivariatePID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.single_process_analysis.SingleProcessAnalysis" title="idtxl.single_process_analysis.SingleProcessAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.single_process_analysis.SingleProcessAnalysis</span></code></a></p>
<p>Perform partial information decomposition for individual processes.</p>
<p>Perform partial information decomposition (PID) for two source processes
and one target process in the network. Estimate unique, shared, and
synergistic information in the two sources about the target. Call
analyse_network() on the whole network or a set of nodes or call
analyse_single_target() to estimate PID for a single process. See
docstrings of the two functions for more information.</p>
<p>References:</p>
<ul class="simple">
<li><p>Williams, P. L., &amp; Beer, R. D. (2010). Nonnegative Decomposition of
Multivariate Information, 1–14. Retrieved from
<a class="reference external" href="http://arxiv.org/abs/1004.2515">http://arxiv.org/abs/1004.2515</a></p></li>
<li><p>Bertschinger, N., Rauh, J., Olbrich, E., Jost, J., &amp; Ay, N. (2014).
Quantifying Unique Information. Entropy, 16(4), 2161–2183.
<a class="reference external" href="http://doi.org/10.3390/e16042161">http://doi.org/10.3390/e16042161</a></p></li>
</ul>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sources<span class="classifier">array type</span></dt><dd><p>pair of indices of source processes</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>analysis settings</p>
</dd>
<dt>results<span class="classifier">dict</span></dt><dd><p>estimated PID</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.bivariate_pid.BivariatePID.analyse_network">
<span class="sig-name descname"><span class="pre">analyse_network</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/bivariate_pid.html#BivariatePID.analyse_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_pid.BivariatePID.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate partial information decomposition for network nodes.</p>
<p>Estimate partial information decomposition (PID) for multiple nodes in
the network.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a detailed description of the algorithm and settings see
documentation of the analyse_single_target() method and
references in the class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alph</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)),</span> <span class="s1">&#39;ps&#39;</span><span class="p">,</span> <span class="n">normalise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;lags_pid&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_s1&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_s2&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_t&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_unsuc_swaps_row_parm&#39;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;num_reps&#39;</span><span class="p">:</span> <span class="mi">63</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_iters&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;pid_estimator&#39;</span><span class="p">:</span> <span class="s1">&#39;SydneyPID&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">targets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pid_analysis</span> <span class="o">=</span> <span class="n">BivariatePID</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">pid_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                       <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, can
contain</p>
<ul class="simple">
<li><p>lags_pid : list of lists of ints [optional] - lags in samples
between sources and target (default=[[1, 1], [1, 1] …])</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>targets<span class="classifier">list of int</span></dt><dd><p>index of target processes</p>
</dd>
<dt>sources<span class="classifier">list of lists</span></dt><dd><p>indices of the two source processes for each target, e.g.,
[[0, 2], [1, 0]], must have the same length as targets</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsPID instance</dt><dd><p>results of network inference, see documentation of
ResultsPID()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.bivariate_pid.BivariatePID.analyse_single_target">
<span class="sig-name descname"><span class="pre">analyse_single_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/bivariate_pid.html#BivariatePID.analyse_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_pid.BivariatePID.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate partial information decomposition for a network node.</p>
<p>Estimate partial information decomposition (PID) for a target node in
the network.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a description of the algorithm and the method see references in
the class and estimator docstrings.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alph</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)),</span> <span class="s1">&#39;ps&#39;</span><span class="p">,</span> <span class="n">normalise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_s1&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_s2&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_t&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_unsuc_swaps_row_parm&#39;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;num_reps&#39;</span><span class="p">:</span> <span class="mi">63</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_iters&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;pid_calc_name&#39;</span><span class="p">:</span> <span class="s1">&#39;SydneyPID&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;lags_pid&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pid_analysis</span> <span class="o">=</span> <span class="n">BivariatePID</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">pid_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">settings</span><span class="o">=</span><span class="n">settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>Args: settings : dict parameters for estimator use and statistics:</p>
<blockquote>
<div><blockquote>
<div><ul class="simple">
<li><p>pid_estimator : str - estimator to be used for PID estimation
(for estimator settings see the documentation in the
estimators_pid modules)</p></li>
<li><p>lags_pid : list of ints [optional] - lags in samples between
sources and target (default=[1, 1])</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target processes</p>
</dd>
<dt>sources<span class="classifier">list of ints</span></dt><dd><p>indices of the two source processes for the target</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns: ResultsPID instance results of</dt><dd><p>network inference, see documentation of
ResultsPID()</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.multivariate_te">
<span id="idtxl-multivariate-te-module"></span><h2>idtxl.multivariate_te module<a class="headerlink" href="#module-idtxl.multivariate_te" title="Permalink to this headline">¶</a></h2>
<p>Perform network inference using multivarate transfer entropy.</p>
<p>Estimate multivariate transfer entropy (TE) for network inference using a
greedy approach with maximum statistics to generate a non-uniform embedding
(Faes, 2011; Lizier, 2012).</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Written for Python 3.4+</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.multivariate_te.MultivariateTE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.multivariate_te.</span></span><span class="sig-name descname"><span class="pre">MultivariateTE</span></span><a class="reference internal" href="_modules/idtxl/multivariate_te.html#MultivariateTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_te.MultivariateTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInferenceTE" title="idtxl.network_inference.NetworkInferenceTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInferenceTE</span></code></a>, <a class="reference internal" href="#idtxl.network_inference.NetworkInferenceMultivariate" title="idtxl.network_inference.NetworkInferenceMultivariate"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInferenceMultivariate</span></code></a></p>
<p>Perform network inference using multivariate transfer entropy.</p>
<p>Perform network inference using multivariate transfer entropy (TE). To
perform network inference call analyse_network() on the whole network or a
set of nodes or call analyse_single_target() to estimate TE for a single
target. See docstrings of the two functions for more information.</p>
<p>References:</p>
<ul class="simple">
<li><p>Schreiber, T. (2000). Measuring Information Transfer. Phys Rev Lett,
85(2), 461–464. <a class="reference external" href="http://doi.org/10.1103/PhysRevLett.85.461">http://doi.org/10.1103/PhysRevLett.85.461</a></p></li>
<li><p>Vicente, R., Wibral, M., Lindner, M., &amp; Pipa, G. (2011). Transfer
entropy-a model-free measure of effective connectivity for the
neurosciences. J Comp Neurosci, 30(1), 45–67.
<a class="reference external" href="http://doi.org/10.1007/s10827-010-0262-3">http://doi.org/10.1007/s10827-010-0262-3</a></p></li>
<li><p>Lizier, J. T., &amp; Rubinov, M. (2012). Multivariate construction of
effective computational networks from observational data. Max Planck
Institute: Preprint. Retrieved from
<a class="reference external" href="http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf">http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf</a></p></li>
<li><p>Faes, L., Nollo, G., &amp; Porta, A. (2011). Information-based detection
of nonlinear Granger causality in multivariate processes via a
nonuniform embedding technique. Phys Rev E, 83, 1–15.
<a class="reference external" href="http://doi.org/10.1103/PhysRevE.83.051112">http://doi.org/10.1103/PhysRevE.83.051112</a></p></li>
</ul>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>source_set<span class="classifier">list</span></dt><dd><p>indices of source processes tested for their influence on the
target</p>
</dd>
<dt>target<span class="classifier">list</span></dt><dd><p>index of target process</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>analysis settings</p>
</dd>
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current value in TE estimation, (idx process,
idx sample)</p>
</dd>
<dt>selected_vars_full<span class="classifier">list of tuples</span></dt><dd><p>samples in the full conditional set, (idx process, idx sample)</p>
</dd>
<dt>selected_vars_sources<span class="classifier">list of tuples</span></dt><dd><p>source samples in the conditional set, (idx process, idx sample)</p>
</dd>
<dt>selected_vars_target<span class="classifier">list of tuples</span></dt><dd><p>target samples in the conditional set, (idx process, idx sample)</p>
</dd>
<dt>pvalue_omnibus<span class="classifier">float</span></dt><dd><p>p-value of the omnibus test</p>
</dd>
<dt>pvalues_sign_sources<span class="classifier">numpy array</span></dt><dd><p>array of p-values for TE from individual sources to the target</p>
</dd>
<dt>statistic_omnibus<span class="classifier">float</span></dt><dd><p>joint TE from all sources to the target</p>
</dd>
<dt>statistic_sign_sources<span class="classifier">numpy array</span></dt><dd><p>raw TE values from individual sources to the target</p>
</dd>
<dt>sign_ominbus<span class="classifier">bool</span></dt><dd><p>statistical significance of the over-all TE</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.multivariate_te.MultivariateTE.analyse_network">
<span class="sig-name descname"><span class="pre">analyse_network</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_te.html#MultivariateTE.analyse_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_te.MultivariateTE.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Find multivariate transfer entropy between all nodes in the network.</p>
<p>Estimate multivariate transfer entropy (TE) between all nodes in the
network or between selected sources and targets.</p>
<dl>
<dt>Note:</dt><dd><p>For a detailed description of the algorithm and settings see
documentation of the analyse_single_target() method and references
in the class docstring.</p>
</dd>
<dt>Example:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag_sources&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag_sources&#39;</span><span class="p">:</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">MultivariateTE</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, settings
can further contain</p>
<ul class="simple">
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>fdr_correction : bool [optional] - correct results on the
network level, see documentation of stats.network_fdr() for
details (default=True)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>targets<span class="classifier">list of int | ‘all’ [optional]</span></dt><dd><p>index of target processes (default=’all’)</p>
</dd>
<dt>sources<span class="classifier">list of int | list of list | ‘all’ [optional]</span></dt><dd><p>indices of source processes for each target (default=’all’);
if ‘all’, all network nodes excluding the target node are
considered as potential sources and tested;
if list of int, the source specified by each int is tested as
a potential source for the target with the same index or a
single target;
if list of list, sources specified in each inner list are
tested for the target with the same index</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsNetworkInference instance</dt><dd><p>results of network inference, see documentation of
ResultsNetworkInference()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.multivariate_te.MultivariateTE.analyse_single_target">
<span class="sig-name descname"><span class="pre">analyse_single_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_te.html#MultivariateTE.analyse_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_te.MultivariateTE.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Find multivariate transfer entropy between sources and a target.</p>
<p>Find multivariate transfer entropy (TE) between all source processes
and the target process. Uses multivariate, non-uniform embedding found
through information maximisation. Multivariate TE is calculated in four
steps:</p>
<ol class="arabic simple">
<li><p>find all relevant variables in the target processes’ own past, by
iteratively adding candidate variables that have significant
conditional mutual information (CMI) with the current value
(conditional on all variables that were added previously)</p></li>
<li><p>find all relevant variables in the source processes’ pasts (again
by finding all candidates with significant CMI)</p></li>
<li><p>prune the final conditional set by testing the CMI between each
variable in the final set and the current value, conditional on all
other variables in the final set</p></li>
<li><p>statistics on the final set of sources (test for over-all transfer
between the final conditional set and the current value, and for
significant transfer of all individual variables in the set)</p></li>
</ol>
<dl class="simple">
<dt>Note:</dt><dd><p>For a further description of the algorithm see references in the
class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag_sources&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag_sources&#39;</span><span class="p">:</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">MultivariateTE</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                 <span class="n">data</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                 <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing:</p>
<ul class="simple">
<li><p>cmi_estimator : str - estimator to be used for CMI
calculation (for estimator settings see the documentation in
the estimators_* modules)</p></li>
<li><p>max_lag_sources : int - maximum temporal search depth for
candidates in the sources’ past in samples</p></li>
<li><p>min_lag_sources : int - minimum temporal search depth for
candidates in the sources’ past in samples</p></li>
<li><p>max_lag_target : int [optional] - maximum temporal search
depth for candidates in the target’s past in samples
(default=same as max_lag_sources)</p></li>
<li><p>tau_sources : int [optional] - spacing between candidates in
the sources’ past in samples (default=1)</p></li>
<li><p>tau_target : int [optional] - spacing between candidates in
the target’s past in samples (default=1)</p></li>
<li><p>n_perm_* : int [optional] - number of permutations, where *
can be ‘max_stat’, ‘min_stat’, ‘omnibus’, and ‘max_seq’
(default=500)</p></li>
<li><p>alpha_* : float [optional] - critical alpha level for
statistical significance, where * can be ‘max_stats’,
‘min_stats’, ‘omnibus’, and ‘max_seq’ (default=0.05)</p></li>
<li><p>add_conditionals : list of tuples | str [optional] - force
the estimator to add these conditionals when estimating TE;
can either be a list of variables, where each variable is
described as (idx process, lag wrt to current value) or can
be a string: ‘faes’ for Faes-Method (see references)</p></li>
<li><p>permute_in_time : bool [optional] - force surrogate
creation by shuffling realisations in time instead of
shuffling replications; see documentation of
Data.permute_samples() for further settings (default=False)</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>write_ckp : bool [optional] - enable checkpointing, writes
analysis state to disk every time a variable is selected;
resume crashed analysis using
network_analysis.resume_checkpoint() (default=False)</p></li>
<li><p>filename_ckp : str [optional] - checkpoint file name (without
extension) (default=’./idtxl_checkpoint’)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sources<span class="classifier">list of int | int | ‘all’ [optional]</span></dt><dd><p>single index or list of indices of source processes
(default=’all’), if ‘all’, all network nodes excluding the
target node are considered as potential sources</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsNetworkInference instance</dt><dd><p>results of network inference, see documentation of
ResultsNetworkInference()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.multivariate_te.MultivariateTE.getit">
<span class="sig-name descname"><span class="pre">getit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_te.html#MultivariateTE.getit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_te.MultivariateTE.getit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.multivariate_mi">
<span id="idtxl-multivariate-mi-module"></span><h2>idtxl.multivariate_mi module<a class="headerlink" href="#module-idtxl.multivariate_mi" title="Permalink to this headline">¶</a></h2>
<p>Perform network inference using multivarate mutual information.</p>
<p>Estimate multivariate mutual information (MI) for network inference using a
greedy approach with maximum statistics to generate a non-uniform embedding
(Faes, 2011; Lizier, 2012).</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Written for Python 3.4+</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.multivariate_mi.MultivariateMI">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.multivariate_mi.</span></span><span class="sig-name descname"><span class="pre">MultivariateMI</span></span><a class="reference internal" href="_modules/idtxl/multivariate_mi.html#MultivariateMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_mi.MultivariateMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInferenceMI" title="idtxl.network_inference.NetworkInferenceMI"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInferenceMI</span></code></a>, <a class="reference internal" href="#idtxl.network_inference.NetworkInferenceMultivariate" title="idtxl.network_inference.NetworkInferenceMultivariate"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInferenceMultivariate</span></code></a></p>
<p>Perform network inference using multivariate mutual information.</p>
<p>Perform network inference using multivariate mutual information (MI). To
perform network inference call analyse_network() on the whole network or a
set of nodes or call analyse_single_target() to estimate MI for a single
target. See docstrings of the two functions for more information.</p>
<p>References:</p>
<ul class="simple">
<li><p>Lizier, J. T., &amp; Rubinov, M. (2012). Multivariate construction of
effective computational networks from observational data. Max Planck
Institute: Preprint. Retrieved from
<a class="reference external" href="http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf">http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf</a></p></li>
<li><p>Faes, L., Nollo, G., &amp; Porta, A. (2011). Information-based detection
of nonlinear Granger causality in multivariate processes via a
nonuniform embedding technique. Phys Rev E, 83, 1–15.
<a class="reference external" href="http://doi.org/10.1103/PhysRevE.83.051112">http://doi.org/10.1103/PhysRevE.83.051112</a></p></li>
</ul>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>source_set<span class="classifier">list</span></dt><dd><p>indices of source processes tested for their influence on the
target</p>
</dd>
<dt>target<span class="classifier">list</span></dt><dd><p>index of target process</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>analysis settings</p>
</dd>
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current value in MI estimation, (idx process,
idx sample)</p>
</dd>
<dt>selected_vars_full<span class="classifier">list of tuples</span></dt><dd><p>samples in the full conditional set, (idx process, idx sample)</p>
</dd>
<dt>selected_vars_sources<span class="classifier">list of tuples</span></dt><dd><p>source samples in the conditional set, (idx process, idx sample)</p>
</dd>
<dt>pvalue_omnibus<span class="classifier">float</span></dt><dd><p>p-value of the omnibus test</p>
</dd>
<dt>pvalues_sign_sources<span class="classifier">numpy array</span></dt><dd><p>array of p-values for MI from individual sources to the target</p>
</dd>
<dt>mi_omnibus<span class="classifier">float</span></dt><dd><p>joint MI from all sources to the target</p>
</dd>
<dt>mi_sign_sources<span class="classifier">numpy array</span></dt><dd><p>raw MI values from individual sources to the target</p>
</dd>
<dt>sign_ominbus<span class="classifier">bool</span></dt><dd><p>statistical significance of the over-all MI</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.multivariate_mi.MultivariateMI.analyse_network">
<span class="sig-name descname"><span class="pre">analyse_network</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_mi.html#MultivariateMI.analyse_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_mi.MultivariateMI.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Find multivariate mutual information between nodes in the network.</p>
<p>Estimate multivariate mutual information (MI) between all nodes in the
network or between selected sources and targets.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a detailed description of the algorithm and settings see
documentation of the analyse_single_target() method and references
in the class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The algorithm uses a conditional mutual information to</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># construct a non-uniform embedding, hence a CMI- not MI-</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimator has to be specified:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag_sources&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag_sources&#39;</span><span class="p">:</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">MultivariateMI</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, settings
can further contain</p>
<ul class="simple">
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>fdr_correction : bool [optional] - correct results on the
network level, see documentation of stats.network_fdr() for
details (default=True)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>targets<span class="classifier">list of int | ‘all’ [optional]</span></dt><dd><p>index of target processes (default=’all’)</p>
</dd>
<dt>sources<span class="classifier">list of int | list of list | ‘all’ [optional]</span></dt><dd><p>indices of source processes for each target (default=’all’);
if ‘all’, all network nodes excluding the target node are
considered as potential sources and tested;
if list of int, the source specified by each int is tested as
a potential source for the target with the same index or a
single target;
if list of list, sources specified in each inner list are
tested for the target with the same index</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>results for each target, see documentation of
analyse_single_target(); results FDR-corrected, see
documentation of stats.network_fdr()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.multivariate_mi.MultivariateMI.analyse_single_target">
<span class="sig-name descname"><span class="pre">analyse_single_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_mi.html#MultivariateMI.analyse_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_mi.MultivariateMI.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Find multivariate mutual information between sources and a target.</p>
<p>Find multivariate mutual information (MI) between all source processes
and the target process. Uses multivariate, non-uniform embedding found
through information maximisation .</p>
<p>Multivariate MI is calculated in four steps (see Lizier and Faes for
details):</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a further description of the algorithm see references in the
class docstring.</p>
</dd>
</dl>
<ol class="arabic simple">
<li><p>Find all relevant samples in the source processes’ past, by
iteratively adding candidate samples that have significant
conditional mutual information (CMI) with the current value
(conditional on all samples that were added previously)</p></li>
<li><p>Prune the final conditional set by testing the CMI between each
sample in the final set and the current value, conditional on all
other samples in the final set</p></li>
<li><p>Statistics on the final set of sources (test for over-all transfer
between the final conditional set and the current value, and for
significant transfer of all individual samples in the set)</p></li>
</ol>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The algorithm uses a conditional mutual information to</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># construct a non-uniform embedding, hence a CMI- not MI-</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimator has to be specified:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag_sources&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag_sources&#39;</span><span class="p">:</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">MultivariateMI</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                 <span class="n">data</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                 <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing:</p>
<ul class="simple">
<li><p>cmi_estimator : str - estimator to be used for CMI
calculation (for estimator settings see the documentation in
the estimators_* modules)</p></li>
<li><p>max_lag_sources : int - maximum temporal search depth for
candidates in the sources’ past in samples</p></li>
<li><p>min_lag_sources : int - minimum temporal search depth for
candidates in the sources’ past in samples</p></li>
<li><p>tau_sources : int [optional] - spacing between candidates in
the sources’ past in samples (default=1)</p></li>
<li><p>n_perm_* : int [optional] - number of permutations, where *
can be ‘max_stat’, ‘min_stat’, ‘omnibus’, and ‘max_seq’
(default=500)</p></li>
<li><p>alpha_* : float [optional] - critical alpha level for
statistical significance, where * can be ‘max_stats’,
‘min_stats’, ‘omnibus’, and ‘max_seq’ (default=0.05)</p></li>
<li><p>add_conditionals : list of tuples | str [optional] - force
the estimator to add these conditionals when estimating MI;
can either be a list of variables, where each variable is
described as (idx process, lag wrt to current value) or can
be a string: ‘faes’ for Faes-Method (see references)</p></li>
<li><p>permute_in_time : bool [optional] - force surrogate
creation by shuffling realisations in time instead of
shuffling replications; see documentation of
Data.permute_samples() for further settings (default=False)</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>write_ckp : bool [optional] - enable checkpointing, writes
analysis state to disk every time a variable is selected;
resume crashed analysis using
network_analysis.resume_checkpoint() (default=False)</p></li>
<li><p>filename_ckp : str [optional] - checkpoint file name (without
extension) (default=’./idtxl_checkpoint’)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sources<span class="classifier">list of int | int | ‘all’ [optional]</span></dt><dd><p>single index or list of indices of source processes
(default=’all’), if ‘all’, all network nodes excluding the
target node are considered as potential sources</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>results consisting of sets of selected variables as (full set,
variables from the sources’ past), pvalues and MI for each
selected variable, the current value for this analysis, results
for omnibus test (joint MI between all selected source
variables and the target, omnibus MI, p-value, and
significance); NOTE that all variables are listed as tuples
(process, lag wrt. current value)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.multivariate_pid">
<span id="idtxl-multivariate-pid-module"></span><h2>idtxl.multivariate_pid module<a class="headerlink" href="#module-idtxl.multivariate_pid" title="Permalink to this headline">¶</a></h2>
<p>Estimate partial information decomposition (PID).</p>
<p>Estimate PID for multiple sources (up to 4 sources) and one target process
using SxPID estimator.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Written for Python 3.4+</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.multivariate_pid.MultivariatePID">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.multivariate_pid.</span></span><span class="sig-name descname"><span class="pre">MultivariatePID</span></span><a class="reference internal" href="_modules/idtxl/multivariate_pid.html#MultivariatePID"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_pid.MultivariatePID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.single_process_analysis.SingleProcessAnalysis" title="idtxl.single_process_analysis.SingleProcessAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.single_process_analysis.SingleProcessAnalysis</span></code></a></p>
<p>Perform partial information decomposition for individual processes.</p>
<p>Perform partial information decomposition (PID) for multiple source
processes (up to 4 sources) and a target process in the network.
Estimate unique, shared, and synergistic information in the multiple
sources about the target. Call analyse_network() on the whole network
or a set of nodes or call analyse_single_target() to estimate PID for
a single process. See docstrings of the two functions for more information.</p>
<p>References:</p>
<ul class="simple">
<li><p>Williams, P. L., &amp; Beer, R. D. (2010). Nonnegative Decomposition of
Multivariate Information, 1–14. Retrieved from
<a class="reference external" href="http://arxiv.org/abs/1004.2515">http://arxiv.org/abs/1004.2515</a></p></li>
<li><p>Makkeh, A. &amp; Gutknecht, A. &amp; Wibral, M. (2020). A Differentiable measure
for shared information. 1- 27 Retrieved from
<a class="reference external" href="http://arxiv.org/abs/2002.03356">http://arxiv.org/abs/2002.03356</a></p></li>
</ul>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sources<span class="classifier">array type</span></dt><dd><p>multiple of indices of source processes</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>analysis settings</p>
</dd>
<dt>results<span class="classifier">dict</span></dt><dd><p>estimated PID</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.multivariate_pid.MultivariatePID.analyse_network">
<span class="sig-name descname"><span class="pre">analyse_network</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_pid.html#MultivariatePID.analyse_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_pid.MultivariatePID.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate partial information decomposition for network nodes.</p>
<p>Estimate, for multiple nodes (target processes), the partial
information decomposition (PID) for multiple source processes
(up to 4 sources) and each of these target processes
in the network.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a detailed description of the algorithm and settings see
documentation of the analyse_single_target() method and
references in the class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alph</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">target1</span><span class="p">,</span> <span class="n">s3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span><span class="p">,</span> <span class="n">target</span><span class="p">)),</span> <span class="s1">&#39;ps&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normalise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;lags_pid&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">]],</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;verbose&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;pid_estimator&#39;</span><span class="p">:</span> <span class="s1">&#39;SxPID&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">targets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pid_analysis</span> <span class="o">=</span> <span class="n">MultivariatePID</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">pid_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                       <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, can
contain</p>
<ul class="simple">
<li><p>lags_pid : list of lists of ints [optional] - lags in samples
between sources and target
(default=[[1, 1, …, 1], [1, 1, …, 1], …])</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>targets<span class="classifier">list of int</span></dt><dd><p>index of target processes</p>
</dd>
<dt>sources<span class="classifier">list of lists</span></dt><dd><p>indices of the multiple source processes for each target, e.g.,
[[0, 1, 2], [1, 0, 3]], all must lists be of the same lenght and
list of lists must have the same length as targets</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsMultivariatePID instance</dt><dd><p>results of network inference, see documentation of
ResultsMultivariatePID()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.multivariate_pid.MultivariatePID.analyse_single_target">
<span class="sig-name descname"><span class="pre">analyse_single_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_pid.html#MultivariatePID.analyse_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_pid.MultivariatePID.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate partial information decomposition for a network node.</p>
<p>Estimate partial information decomposition (PID) for multiple source
processes (up to 4 sources) and a target process in the network.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a description of the algorithm and the method see references in
the class and estimator docstrings.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alph</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">target1</span><span class="p">,</span> <span class="n">s3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span><span class="p">,</span> <span class="n">target</span><span class="p">)),</span> <span class="s1">&#39;ps&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normalise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;verbose&#39;</span> <span class="p">:</span> <span class="n">false</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;pid_estimator&#39;</span><span class="p">:</span> <span class="s1">&#39;SxPID&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;lags_pid&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pid_analysis</span> <span class="o">=</span> <span class="n">MultivariatePID</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">pid_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">settings</span><span class="o">=</span><span class="n">settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>Args: settings : dict parameters for estimator use and statistics:</p>
<blockquote>
<div><blockquote>
<div><ul class="simple">
<li><p>pid_estimator : str - estimator to be used for PID estimation
(for estimator settings see the documentation in the
estimators_pid modules)</p></li>
<li><p>lags_pid : list of ints [optional] - lags in samples between
sources and target (default=[1, 1, …, 1])</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target processes</p>
</dd>
<dt>sources<span class="classifier">list of ints</span></dt><dd><p>indices of the multiple source processes for the target</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns: ResultsMultivariatePID instance results of</dt><dd><p>network inference, see documentation of
ResultsPID()</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.active_information_storage">
<span id="idtxl-active-information-storage-module"></span><h2>idtxl.active_information_storage module<a class="headerlink" href="#module-idtxl.active_information_storage" title="Permalink to this headline">¶</a></h2>
<p>Analysis of AIS in a network of processes.</p>
<p>Analysis of active information storage (AIS) in individual processes of a
network. The algorithm uses non-uniform embedding as described in Faes (2011).</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Written for Python 3.4+</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.active_information_storage.ActiveInformationStorage">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.active_information_storage.</span></span><span class="sig-name descname"><span class="pre">ActiveInformationStorage</span></span><a class="reference internal" href="_modules/idtxl/active_information_storage.html#ActiveInformationStorage"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.active_information_storage.ActiveInformationStorage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.single_process_analysis.SingleProcessAnalysis" title="idtxl.single_process_analysis.SingleProcessAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.single_process_analysis.SingleProcessAnalysis</span></code></a></p>
<p>Estimate active information storage in individual processes.</p>
<p>Estimate active information storage (AIS) in individual processes of the
network. To perform AIS estimation call analyse_network() on the whole
network or a set of nodes or call analyse_single_process() to estimate
AIS for a single process. See docstrings of the two functions for more
information.</p>
<p>References:</p>
<ul class="simple">
<li><p>Lizier, J. T., Prokopenko, M., &amp; Zomaya, A. Y. (2012). Local measures of
information storage in complex distributed computation. Inform Sci, 208,
39–54. <a class="reference external" href="http://doi.org/10.1016/j.ins.2012.04.016">http://doi.org/10.1016/j.ins.2012.04.016</a></p></li>
<li><p>Wibral, M., Lizier, J. T., Vögler, S., Priesemann, V., &amp; Galuske, R.
(2014). Local active information storage as a tool to understand
distributed neural information processing. Front Neuroinf, 8, 1.
<a class="reference external" href="http://doi.org/10.3389/fninf.2014.00001">http://doi.org/10.3389/fninf.2014.00001</a></p></li>
<li><p>Faes, L., Nollo, G., &amp; Porta, A. (2011). Information-based detection
of nonlinear Granger causality in multivariate processes via a
nonuniform embedding technique. Phys Rev E, 83, 1–15.
<a class="reference external" href="http://doi.org/10.1103/PhysRevE.83.051112">http://doi.org/10.1103/PhysRevE.83.051112</a></p></li>
</ul>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>process_set<span class="classifier">list</span></dt><dd><p>list with indices of analyzed processes</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>analysis settings</p>
</dd>
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current value in AIS estimation, (idx process,
idx sample)</p>
</dd>
<dt>selected_vars_full<span class="classifier">list of tuples</span></dt><dd><p>samples in the past state, (idx process, idx sample)</p>
</dd>
<dt>ais<span class="classifier">float</span></dt><dd><p>raw AIS value</p>
</dd>
<dt>sign<span class="classifier">bool</span></dt><dd><p>true if AIS is significant</p>
</dd>
<dt>pvalue: float</dt><dd><p>p-value of AIS</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.active_information_storage.ActiveInformationStorage.analyse_network">
<span class="sig-name descname"><span class="pre">analyse_network</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/active_information_storage.html#ActiveInformationStorage.analyse_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.active_information_storage.ActiveInformationStorage.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate active information storage for multiple network processes.</p>
<p>Estimate active information storage for all or a subset of processes in
the network.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a detailed description of the algorithm and settings see
documentation of the analyse_single_process() method and
references in the class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span> <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;tau&#39;</span><span class="p">:</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">processes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">ActiveInformationStorage</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                           <span class="n">processes</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, settings
can further contain</p>
<ul class="simple">
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>fdr_correction : bool [optional] - correct results on the
network level, see documentation of stats.ais_fdr() for
details (default=True)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>processes<span class="classifier">list of int | ‘all’</span></dt><dd><p>index of processes (default=’all’);
if ‘all’, AIS is estimated for all processes;
if list of int, AIS is estimated for processes specified in the
list.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsSingleProcessAnalysis instance</dt><dd><p>results of network AIS estimation, see documentation of
ResultsSingleProcessAnalysis()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.active_information_storage.ActiveInformationStorage.analyse_single_process">
<span class="sig-name descname"><span class="pre">analyse_single_process</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/active_information_storage.html#ActiveInformationStorage.analyse_single_process"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.active_information_storage.ActiveInformationStorage.analyse_single_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate active information storage for a single process.</p>
<p>Estimate active information storage for one process in the network.
Uses non-uniform embedding found through information maximisation. This
is done in three steps (see Lizier and Faes for details):</p>
<ol class="arabic simple">
<li><p>Find all relevant samples in the processes’ own past, by
iteratively adding candidate samples that have significant
conditional mutual information (CMI) with the current value
(conditional on all samples that were added previously)</p></li>
<li><p>Prune the final conditional set by testing the CMI between each
sample in the final set and the current value, conditional on all
other samples in the final set</p></li>
<li><p>Calculate AIS using the final set of candidates as the past state
(calculate MI between samples in the past and the current value);
test for statistical significance using a permutation test</p></li>
</ol>
<dl class="simple">
<dt>Note:</dt><dd><p>For a further description of the algorithm see references in the
class docstring.</p>
</dd>
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimator use and statistics:</p>
<ul class="simple">
<li><p>cmi_estimator : str - estimator to be used for CMI and MI
calculation (for estimator settings see the documentation in
the estimators_* modules)</p></li>
<li><p>max_lag : int - maximum temporal search depth for candidates
in the processes’ past in samples</p></li>
<li><p>tau : int [optional] - spacing between candidates in the
sources’ past in samples (default=1)</p></li>
<li><p>n_perm_* : int [optional] - number of permutations, where *
can be ‘max_stat’, ‘min_stat’, ‘mi’ (default=500)</p></li>
<li><p>alpha_* : float [optional] - critical alpha level for
statistical significance, where * can be ‘max_stat’,
‘min_stat’, ‘mi’ (default=0.05)</p></li>
<li><p>add_conditionals : list of tuples | str [optional] - force
the estimator to add these conditionals when estimating TE;
can either be a list of variables, where each variable is
described as (idx process, lag wrt to current value) or can
be a string: ‘faes’ for Faes-Method (see references)</p></li>
<li><p>permute_in_time : bool [optional] - force surrogate creation
by shuffling realisations in time instead of shuffling
replications; see documentation of Data.permute_samples() for
further settings (default=False)</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>write_ckp : bool [optional] - enable checkpointing, writes
analysis state to disk every time a variable is selected;
resume crashed analysis using
network_analysis.resume_checkpoint() (default=False)</p></li>
<li><p>filename_ckp : str [optional] - checkpoint file name (without
extension) (default=’./idtxl_checkpoint’)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>process<span class="classifier">int</span></dt><dd><p>index of process</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsSingleProcessAnalysis instance</dt><dd><p>results of AIS estimation, see documentation of
ResultsSingleProcessAnalysis()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.embedding_optimization_ais_Rudelt">
<span id="idtxl-embedding-optimization-ais-rudelt-module"></span><h2>idtxl.embedding_optimization_ais_Rudelt module<a class="headerlink" href="#module-idtxl.embedding_optimization_ais_Rudelt" title="Permalink to this headline">¶</a></h2>
<p>Optimization of embedding parameters of spike times using the history dependence estimators</p>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.embedding_optimization_ais_Rudelt.</span></span><span class="sig-name descname"><span class="pre">OptimizationRudelt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Optimization of embedding parameters of spike times using the history dependence estimators</p>
<p>References:</p>
<blockquote>
<div><dl class="simple">
<dt>[1]: L. Rudelt, D. G. Marx, M. Wibral, V. Priesemann: Embedding</dt><dd><p>optimization reveals long-lasting history dependence in
neural spiking activity, 2021, PLOS Computational Biology, 17(6)</p>
</dd>
</dl>
<p>[2]: <a class="reference external" href="https://github.com/Priesemann-Group/hdestimator">https://github.com/Priesemann-Group/hdestimator</a></p>
</div></blockquote>
<p>implemented in idtxl by Michael Lindner, Göttingen 2021</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><ul class="simple">
<li><dl class="simple">
<dt>estimation_method<span class="classifier">string</span></dt><dd><p>The method to be used to estimate the history dependence ‘bbc’ or ‘shuffling’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>embedding_step_size<span class="classifier">float</span></dt><dd><p>Step size delta t (in seconds) with which the window is slid through the data.
(default: 0.005)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>embedding_number_of_bins_set<span class="classifier">list of integer values</span></dt><dd><p>Set of values for d, the number of bins in the embedding.
(default: [1, 2, 3, 4, 5])</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>embedding_past_range_set<span class="classifier">list of floating-point values</span></dt><dd><p>Set of values for T, the past range (in seconds) to be used for embeddings.
(default: [0.005, 0.00561, 0.00629, 0.00706, 0.00792, 0.00889,
0.00998, 0.01119, 0.01256, 0.01409, 0.01581, 0.01774, 0.01991,
0.02233, 0.02506, 0.02812, 0.03155, 0.0354, 0.03972, 0.04456,
0.05, 0.0561, 0.06295, 0.07063, 0.07924, 0.08891, 0.09976,
0.11194, 0.12559, 0.14092, 0.15811, 0.17741, 0.19905, 0.22334,
0.25059, 0.28117, 0.31548, 0.35397, 0.39716, 0.44563, 0.5,
0.56101, 0.62946, 0.70627, 0.79245, 0.88914, 0.99763, 1.11936,
1.25594, 1.40919, 1.58114, 1.77407, 1.99054, 2.23342, 2.50594,
2.81171, 3.15479, 3.53973, 3.97164, 4.45625, 5.0])</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>embedding_scaling_exponent_set<span class="classifier">dict</span></dt><dd><p>Set of values for kappa, the scaling exponent for the bins in the embedding.
Should be a python-dictionary with the three entries ‘number_of_scalings’, ‘min_first_bin_size’ and
‘min_step_for_scaling’.
defaults: {‘number_of_scalings’: 10, ‘min_first_bin_size’: 0.005, ‘min_step_for_scaling’: 0.01})</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>bbc_tolerance<span class="classifier">float</span></dt><dd><p>The tolerance for the Bayesian Bias Criterion. Influences which embeddings are
discarded from the analysis.
(default: 0.05)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>return_averaged_R<span class="classifier">bool</span></dt><dd><p>Return R_tot as the average over R(T) for T in [T_D, T_max], instead of R_tot = R(T_D).
If set to True, the setting for number_of_bootstraps_R_tot (see below) is ignored and set to 0
and CI bounds are not calculated.
(default: True)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>timescale_minimum_past_range<span class="classifier">float</span></dt><dd><p>Minimum past range T_0 (in seconds) to take into consideration for the estimation of the
information timescale tau_R.
(default: 0.01)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>number_of_bootstraps_R_max<span class="classifier">int</span></dt><dd><p>The number of bootstrap re-shuffles that should be used to determine the optimal
embedding. (Bootstrap the estimates of R_max to determine R_tot.)
These are computed during the ‘history-dependence’ task because they are essential
to obtain R_tot.
(default: 250)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>number_of_bootstraps_R_tot<span class="classifier">int</span></dt><dd><p>The number of bootstrap re-shuffles that should be used to estimate the confidence
interval of the optimal embedding. (Bootstrap the estimates of R_tot = R(T_D) to
obtain a confidence interval for R_tot.).
These are computed during the ‘confidence-intervals’ task.
The setting return_averaged_R (see above) needs to be set to False for this setting
to take effect.
(default: 250)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>number_of_bootstraps_nonessential<span class="classifier">int</span></dt><dd><p>The number of bootstrap re-shuffles that should be used to estimate the confidence
intervals for embeddings other than the optimal one. (Bootstrap the estimates of
R(T) for all other T.)
(These are not necessary for the main analysis and therefore default to 0.)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>symbol_block_length<span class="classifier">int</span></dt><dd><p>The number of symbols that should be drawn in each block for bootstrap resampling
If it is set to None (recommended), the length is automatically chosen, based
on heuristics
(default: None)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>bootstrap_CI_use_sd<span class="classifier">bool</span></dt><dd><p>Most of the time we observed normally-distributed bootstrap replications,
so it is sufficient (and more efficient) to compute confidence intervals
based on the standard deviation
(default: True)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>bootstrap_CI_percentile_lo<span class="classifier">float</span></dt><dd><p>The lower percentile for the confidence interval.
This has no effect if bootstrap_CI_use_sd is set to True
(default: 2.5)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>bootstrap_CI_percentile_hi<span class="classifier">float</span></dt><dd><p>The upper percentiles for the confidence interval.
This has no effect if bootstrap_CI_use_sd is set to True
(default: 97.5)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>analyse_auto_MI<span class="classifier">bool</span></dt><dd><p>perform calculation of auto mutual information of the spike train
(default: True)
If set to True:</p>
<ul>
<li><dl class="simple">
<dt>auto_MI_bin_size_set<span class="classifier">list of floating-point values</span></dt><dd><p>Set of values for the sizes of the bins (in seconds).
(default: [0.005, 0.01, 0.025, 0.05, 0.25, 0.5])</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>auto_MI_max_delay<span class="classifier">int</span></dt><dd><p>The maximum delay (in seconds) between the past bin and the response.
(default: 5)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>visualization<span class="classifier">bool</span></dt><dd><p>create .eps output image showing the optimization values and graphs for
the history dependence and the auto mutual information
(default: False)
if set to True:</p>
<ul>
<li><dl class="simple">
<dt>output_path<span class="classifier">String</span></dt><dd><p>Path where the .eps images should be saved</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output_prefix<span class="classifier">String</span></dt><dd><p>Prefix of the output images
e.g. &lt;output_prefix&gt;_process0.eps</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>debug: bool</dt><dd><p>show values while calculating
(default: False)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.analyse_auto_MI">
<span class="sig-name descname"><span class="pre">analyse_auto_MI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spike_times</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.analyse_auto_MI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.analyse_auto_MI" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the auto MI for the spike times.  If it is available from file, load
it, else compute it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.check_inputs">
<span class="sig-name descname"><span class="pre">check_inputs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.check_inputs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.check_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input settings for completeness</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.compute_CIs">
<span class="sig-name descname"><span class="pre">compute_CIs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'R_max'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol_block_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.compute_CIs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.compute_CIs" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute bootstrap replications of the history dependence estimate
which can be used to obtain confidence intervals.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">data_spiketime object</span></dt><dd><p>Input data</p>
</dd>
<dt>target_R<span class="classifier">String</span></dt><dd><p>One of ‘R_max’, ‘R_tot’ or ‘nonessential’.
If set to R_max, replications of R are produced for the T at which
R is maximised.
If set to R_tot, replications of R are produced for T = T_D (cf
get_temporal_depth_T_D).
If set to nonessential, replications of R are produced for each T
(one embedding per T, cf get_embeddings_that_maximise_R).  These
are not otherwise used in the analysis and are probably only useful
if the resulting plot is visually inspected, so in most cases it can
be set to zero.</p>
</dd>
<dt>symbol_block_length<span class="classifier">int</span></dt><dd><p>The number of symbols that should be drawn in each block for bootstrap resampling
If it is set to None (recommended), the length is automatically chosen, based
on heuristics</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_R_tot">
<span class="sig-name descname"><span class="pre">get_R_tot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_averaged_R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_R_tot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_R_tot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_auto_MI">
<span class="sig-name descname"><span class="pre">get_auto_MI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spike_times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_delays</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_auto_MI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_auto_MI" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the auto mutual information in the neuron’s activity, a
measure closely related to history dependence.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_bootstrap_history_dependence">
<span class="sig-name descname"><span class="pre">get_bootstrap_history_dependence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">embedding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bootstraps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol_block_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_bootstrap_history_dependence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_bootstrap_history_dependence" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given embedding, return bootstrap replications for R.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_embeddings">
<span class="sig-name descname"><span class="pre">get_embeddings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">embedding_past_range_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">embedding_number_of_bins_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">embedding_scaling_exponent_set</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_embeddings"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_embeddings" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all combinations of parameters T, d, k, based on the
sets of selected parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_embeddings_that_maximise_R">
<span class="sig-name descname"><span class="pre">get_embeddings_that_maximise_R</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bbc_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dependent_var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'T'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_as_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_embeddings_that_maximise_R"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_embeddings_that_maximise_R" title="Permalink to this definition">¶</a></dt>
<dd><p>For each T (or d), get the embedding for which R is maximised.</p>
<p>For the bbc estimator, here the bbc_tolerance is applied, ie
get the unbiased embeddings that maximise R.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_history_dependence">
<span class="sig-name descname"><span class="pre">get_history_dependence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_history_dependence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_history_dependence" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the history dependence for each embedding to all given processes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_information_timescale_tau_R">
<span class="sig-name descname"><span class="pre">get_information_timescale_tau_R</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_information_timescale_tau_R"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_information_timescale_tau_R" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the information timescale tau_R, a characteristic
timescale of history dependence similar to an autocorrelation
time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_past_range">
<span class="sig-name descname"><span class="pre">get_past_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_bin_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling_k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_past_range"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_past_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the past range T of the embedding, based on the parameters d, tau_1 and k.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_set_of_scalings">
<span class="sig-name descname"><span class="pre">get_set_of_scalings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">past_range_T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_scalings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_first_bin_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_step_for_scaling</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_set_of_scalings"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_set_of_scalings" title="Permalink to this definition">¶</a></dt>
<dd><p>Get scaling exponents such that the uniform embedding as well as
the embedding for which the first bin has a length of
min_first_bin_size (in seconds), as well as linearly spaced
scaling factors in between, such that in total
number_of_scalings scalings are obtained.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_temporal_depth_T_D">
<span class="sig-name descname"><span class="pre">get_temporal_depth_T_D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">get_R_thresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.get_temporal_depth_T_D"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.get_temporal_depth_T_D" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the temporal depth T_D, the past range for the
‘optimal’ embedding parameters.</p>
<p>Given the maximal history dependence R at each past range T,
(cf get_embeddings_that_maximise_R), first find the smallest T at
which R is maximised (cf get_max_R_T).  If bootstrap replications
for this R are available, get the smallest T at which this R minus
one standard deviation of the bootstrap estimates is attained.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.optimize">
<span class="sig-name descname"><span class="pre">optimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.optimize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize the embedding parameters of spike time data using the Rudelt history dependence estimator.</p>
<p>References:</p>
<blockquote>
<div><dl class="simple">
<dt>[1]: L. Rudelt, D. G. Marx, M. Wibral, V. Priesemann: Embedding</dt><dd><p>optimization reveals long-lasting history dependence in
neural spiking activity, 2021, PLOS Computational Biology, 17(6)</p>
</dd>
</dl>
<p>[2]: <a class="reference external" href="https://github.com/Priesemann-Group/hdestimator">https://github.com/Priesemann-Group/hdestimator</a></p>
</div></blockquote>
<p>implemented in idtxl by Michael Lindner, Göttingen 2021</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">Data_spiketime instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>processes<span class="classifier">list of int</span></dt><dd><p>index of processes;
spike times are optimized all processes specified in the list separately.</p>
</dd>
</dl>
</dd>
<dt>Returns: # ——————————————————————————————————– TODO</dt><dd><dl class="simple">
<dt>ResultsSingleProcessRudelt instance</dt><dd><p>results of Rudelt optimization, see documentation of
ResultsSingleProcessRudelt()</p>
</dd>
<dt>if visulization in settings was set True (see class OptimizationRudelt):</dt><dd><dl class="simple">
<dt>.eps images are created for each optimized process containing:</dt><dd><ul class="simple">
<li><p>optimized values for the process</p></li>
<li><p>graph for the history dependence</p></li>
<li><p>graph for auto mutual information (if calculated)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.optimize_single_run">
<span class="sig-name descname"><span class="pre">optimize_single_run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.optimize_single_run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.optimize_single_run" title="Permalink to this definition">¶</a></dt>
<dd><p>optimizes a single realisation of spike time data given the process number</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">Data_spiketime instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>process<span class="classifier">int</span></dt><dd><p>index of process;</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl>
<dt>DotDict</dt><dd><p>with the following keys</p>
<dl class="simple">
<dt>Process<span class="classifier">int</span></dt><dd><p>Process that was optimized</p>
</dd>
<dt>estimation_method<span class="classifier">String</span></dt><dd><p>Estimation method that was used for optimization</p>
</dd>
<dt>T_D<span class="classifier">float</span></dt><dd><p>Estimated optimal value for the temporal depth TD</p>
</dd>
<dt>tau_R :</dt><dd><p>Information timescale tau_R, a characteristic timescale of history
dependence similar to an autocorrelation time.</p>
</dd>
<dt>R_tot<span class="classifier">float</span></dt><dd><p>Estimated value for the total history dependence Rtot,</p>
</dd>
<dt>AIS_tot<span class="classifier">float</span></dt><dd><p>Estimated value for the total active information storage</p>
</dd>
<dt>opt_number_of_bins_d<span class="classifier">int</span></dt><dd><p>Number of bins d for the embedding that yields (R̂tot ,T̂D)</p>
</dd>
<dt>opt_scaling_k<span class="classifier">int</span></dt><dd><p>Scaling exponent κ for the embedding that yields (R̂tot , T̂D)</p>
</dd>
<dt>opt_first_bin_size<span class="classifier">int</span></dt><dd><p>Size of the first bin τ1 for the embedding that yields (R̂tot , T̂D ),</p>
</dd>
<dt>history_dependence<span class="classifier">array with floating-point values</span></dt><dd><p>Estimated history dependence for each embedding</p>
</dd>
<dt>firing_rate<span class="classifier">float</span></dt><dd><p>Firing rate of the neuron/ spike train</p>
</dd>
<dt>recording_length<span class="classifier">float</span></dt><dd><p>Length of the recording (in seconds)</p>
</dd>
<dt>H_spiking<span class="classifier">float</span></dt><dd><p>Entropy of the spike times</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>if analyse_auto_MI was set to True additionally:</dt><dd><dl class="simple">
<dt>auto_MI<span class="classifier">dict</span></dt><dd><p>numpy array of MI values for each delay</p>
</dd>
<dt>auto_MI_delays<span class="classifier">list of int</span></dt><dd><p>list of delays depending on the given auto_MI_bin_sizes and auto_MI_max_delay</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.remove_subresults_single_process">
<span class="sig-name descname"><span class="pre">remove_subresults_single_process</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/embedding_optimization_ais_Rudelt.html#OptimizationRudelt.remove_subresults_single_process"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.embedding_optimization_ais_Rudelt.OptimizationRudelt.remove_subresults_single_process" title="Permalink to this definition">¶</a></dt>
<dd><p>delete results from self from single process</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.estimators_Rudelt">
<span id="idtxl-estimators-rudelt-module"></span><h2>idtxl.estimators_Rudelt module<a class="headerlink" href="#module-idtxl.estimators_Rudelt" title="Permalink to this headline">¶</a></h2>
<p>Provide HDE estimators.</p>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractEstimator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_Rudelt.</span></span><span class="sig-name descname"><span class="pre">RudeltAbstractEstimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractEstimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimator.Estimator</span></code></p>
<p>Abstract class for implementation of nsb and plugin estimators from Rudelt.</p>
<p>Abstract class for implementation of nsb and plugin estimators, child classes
implement estimators for mutual information (MI) .</p>
<p>References:</p>
<blockquote>
<div><dl class="simple">
<dt>[1]: L. Rudelt, D. G. Marx, M. Wibral, V. Priesemann: Embedding</dt><dd><p>optimization reveals long-lasting history dependence in
neural spiking activity, 2021, PLOS Computational Biology, 17(6)</p>
</dd>
</dl>
<p>[2]: <a class="reference external" href="https://github.com/Priesemann-Group/hdestimator">https://github.com/Priesemann-Group/hdestimator</a></p>
</div></blockquote>
<p>implemented in idtxl by Michael Lindner, Göttingen 2021</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><ul class="simple">
<li><dl class="simple">
<dt>embedding_step_size<span class="classifier">float [optional]</span></dt><dd><p>Step size delta t (in seconds) with which the window is slid through the data
(default = 0.005).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>normalise<span class="classifier">bool [optional]</span></dt><dd><p>rebase spike times to zero
(default=True)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>return_averaged_R<span class="classifier">bool [optional]</span></dt><dd><p>If set to True, compute R̂tot as the average over R̂(T ) for T ∈ [T̂D, Tmax ] instead of
R̂tot = R(T̂D ). If set to True, the setting for number_of_bootstraps_R_tot is ignored and
set to 0
(default=True)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractEstimator.get_median_number_of_spikes_per_bin">
<span class="sig-name descname"><span class="pre">get_median_number_of_spikes_per_bin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw_symbols</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.get_median_number_of_spikes_per_bin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractEstimator.get_median_number_of_spikes_per_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Given raw symbols (in which the number of spikes per bin are counted,
ie not necessarily binary quantity), get the median number of spikes
for each bin, among all symbols obtained by the embedding.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractEstimator.get_multiplicities">
<span class="sig-name descname"><span class="pre">get_multiplicities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphabet_size</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.get_multiplicities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractEstimator.get_multiplicities" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the multiplicities of some given symbol counts.</p>
<p>To estimate the entropy of a system, it is only important how
often a symbol/ event occurs (the probability that it occurs), not
what it represents. Therefore, computations can be simplified by
summarizing symbols by their frequency, as represented by the
multiplicities.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractEstimator.get_past_range">
<span class="sig-name descname"><span class="pre">get_past_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_bin_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling_k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.get_past_range"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractEstimator.get_past_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the past range T of the embedding, based on the parameters d, tau_1 and k.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractEstimator.get_raw_symbols">
<span class="sig-name descname"><span class="pre">get_raw_symbols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spike_times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">embedding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_bin_size</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.get_raw_symbols"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractEstimator.get_raw_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the raw symbols (in which the number of spikes per bin are counted,
ie not necessarily binary quantity), as obtained by applying the
embedding.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractEstimator.get_symbol_counts">
<span class="sig-name descname"><span class="pre">get_symbol_counts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_array</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.get_symbol_counts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractEstimator.get_symbol_counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Count how often symbols occur</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractEstimator.get_window_delimiters">
<span class="sig-name descname"><span class="pre">get_window_delimiters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_bin_size</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.get_window_delimiters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractEstimator.get_window_delimiters" title="Permalink to this definition">¶</a></dt>
<dd><p>Get delimiters of the window, used to describe the embedding. The
window includes both the past embedding and the response.</p>
<p>The delimiters are times, relative to the first bin, that separate
two consequent bins.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractEstimator.is_analytic_null_estimator">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractEstimator.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractEstimator.is_parallel">
<span class="sig-name descname"><span class="pre">is_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractEstimator.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractEstimator.symbol_array_to_binary">
<span class="sig-name descname"><span class="pre">symbol_array_to_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spikes_in_window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.symbol_array_to_binary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractEstimator.symbol_array_to_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an array of 1s and 0s, representing spikes and the absence
thereof, read the array as a binary number to obtain a
(base 10) integer.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractEstimator.symbol_binary_to_array">
<span class="sig-name descname"><span class="pre">symbol_binary_to_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_binary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractEstimator.symbol_binary_to_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractEstimator.symbol_binary_to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a binary representation of a symbol (cf symbol_array_to_binary),
convert it back into its array-representation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_Rudelt.</span></span><span class="sig-name descname"><span class="pre">RudeltAbstractNSBEstimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_Rudelt.RudeltAbstractEstimator" title="idtxl.estimators_Rudelt.RudeltAbstractEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_Rudelt.RudeltAbstractEstimator</span></code></a></p>
<p>Abstract class for implementation of NSB estimators from Rudelt.</p>
<p>Abstract class for implementation of Nemenman-Shafee-Bialek (NSB)
estimators, child classes implement nsb estimators for mutual information
(MI).</p>
<p>implemented in idtxl by Michael Lindner, Göttingen 2021</p>
<p>References:</p>
<blockquote>
<div><dl class="simple">
<dt>[1]: L. Rudelt, D. G. Marx, M. Wibral, V. Priesemann: Embedding</dt><dd><p>optimization reveals long-lasting history dependence in
neural spiking activity, 2021, PLOS Computational Biology, 17(6)</p>
</dd>
<dt>[2]: I. Nemenman, F. Shafee, W. Bialek: Entropy and inference,</dt><dd><p>revisited. In T.G. Dietterich, S. Becker, and Z. Ghahramani,
editors, Advances in Neural Information Processing Systems 14,
Cambridge, MA, 2002. MIT Press.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><ul class="simple">
<li><dl class="simple">
<dt>embedding_step_size<span class="classifier">float [optional]</span></dt><dd><p>Step size delta t (in seconds) with which the window is slid through the data
(default = 0.005).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>normalise<span class="classifier">bool [optional]</span></dt><dd><p>rebase spike times to zero
(default=True)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>return_averaged_R<span class="classifier">bool [optional]</span></dt><dd><p>If set to True, compute R̂tot as the average over R̂(T ) for T ∈ [T̂D, Tmax ] instead of
R̂tot = R(T̂D ). If set to True, the setting for number_of_bootstraps_R_tot is ignored and
set to 0
(default=True)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.H1">
<span class="sig-name descname"><span class="pre">H1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.H1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.H1" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the first moment (expectation value) of the entropy H.</p>
<p>H is the entropy one obtains with a symmetric Dirichlet prior
with concentration parameter beta and a multinomial likelihood.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.alpha_ML">
<span class="sig-name descname"><span class="pre">alpha_ML</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.alpha_ML"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.alpha_ML" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute first guess for the beta_MAP (cf get_beta_MAP) parameter
via the posterior of a Dirichlet process.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.d2_log_rho">
<span class="sig-name descname"><span class="pre">d2_log_rho</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.d2_log_rho"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.d2_log_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Second derivate of the logarithm of the Dirichlet multinomial likelihood.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.d2_log_rho_xi">
<span class="sig-name descname"><span class="pre">d2_log_rho_xi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.d2_log_rho_xi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.d2_log_rho_xi" title="Permalink to this definition">¶</a></dt>
<dd><p>Second derivative of the logarithm of the nsb (unnormalized) posterior.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.d2_xi">
<span class="sig-name descname"><span class="pre">d2_xi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.d2_xi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.d2_xi" title="Permalink to this definition">¶</a></dt>
<dd><p>Second derivative of xi(beta) (cf d_xi).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.d3_xi">
<span class="sig-name descname"><span class="pre">d3_xi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.d3_xi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.d3_xi" title="Permalink to this definition">¶</a></dt>
<dd><p>Third derivative of xi(beta) (cf d_xi).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.d_log_rho">
<span class="sig-name descname"><span class="pre">d_log_rho</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.d_log_rho"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.d_log_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>First derivate of the logarithm of the Dirichlet multinomial likelihood.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.d_log_rho_xi">
<span class="sig-name descname"><span class="pre">d_log_rho_xi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.d_log_rho_xi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.d_log_rho_xi" title="Permalink to this definition">¶</a></dt>
<dd><p>First derivative of the logarithm of the nsb (unnormalized) posterior.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.d_xi">
<span class="sig-name descname"><span class="pre">d_xi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.d_xi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.d_xi" title="Permalink to this definition">¶</a></dt>
<dd><p>First derivative of xi(beta).</p>
<p>xi(beta) is the entropy of the system when no data has been observed.
d_xi is the prior for the nsb estimator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.get_beta_MAP">
<span class="sig-name descname"><span class="pre">get_beta_MAP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.get_beta_MAP"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.get_beta_MAP" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the maximum a posteriori (MAP) value for beta.</p>
<p>Provides the location of the peak, around which we integrate.</p>
<p>beta_MAP is the value for beta for which the posterior of the
NSB estimator is maximised (or, equivalently, of the logarithm
thereof, as computed here).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.get_integration_bounds">
<span class="sig-name descname"><span class="pre">get_integration_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.get_integration_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.get_integration_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the integration bounds for the estimator.</p>
<p>Typically it is a delta-like distribution so it is sufficient
to integrate around this peak. (If not this function is not
called.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.log_likelihood_DP_alpha">
<span class="sig-name descname"><span class="pre">log_likelihood_DP_alpha</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.log_likelihood_DP_alpha"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.log_likelihood_DP_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha-dependent terms of the log-likelihood of a Dirichlet Process.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.nsb_entropy">
<span class="sig-name descname"><span class="pre">nsb_entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.nsb_entropy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.nsb_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the entropy of a system using the NSB estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mk</strong> – multiplicities</p></li>
<li><p><strong>K</strong> – number of possible symbols/ state space of the system</p></li>
<li><p><strong>N</strong> – total number of observed symbols</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.rho">
<span class="sig-name descname"><span class="pre">rho</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.rho"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.rho" title="Permalink to this definition">¶</a></dt>
<dd><p>rho(beta, data) is the Dirichlet multinomial likelihood.</p>
<p>rho(beta, data) together with the d_xi(beta) make up
the posterior for the nsb estimator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.unnormalized_posterior">
<span class="sig-name descname"><span class="pre">unnormalized_posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltAbstractNSBEstimator.unnormalized_posterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator.unnormalized_posterior" title="Permalink to this definition">¶</a></dt>
<dd><p>The (unnormalized) posterior in the nsb estimator.</p>
<p>Product of the likelihood rho and the prior d_xi;
the normalizing factor is given by the marginal likelihood</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltBBCEstimator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_Rudelt.</span></span><span class="sig-name descname"><span class="pre">RudeltBBCEstimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltBBCEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltBBCEstimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_Rudelt.RudeltAbstractEstimator" title="idtxl.estimators_Rudelt.RudeltAbstractEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_Rudelt.RudeltAbstractEstimator</span></code></a></p>
<p>Bayesian bias criterion (BBC) Estimator using NSB and Plugin estimator</p>
<p>Calculate the mutual information (MI) of one variable depending on its past
using nsb and plugin estimator and check if bias criterion is passed.
See parent class for references.</p>
<p>implemented in idtxl by Michael Lindner, Göttingen 2021</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><ul class="simple">
<li><dl class="simple">
<dt>embedding_step_size<span class="classifier">float [optional]</span></dt><dd><p>Step size delta t (in seconds) with which the window is slid through the data
(default = 0.005).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>normalise<span class="classifier">bool [optional]</span></dt><dd><p>rebase spike times to zero
(default=True)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>return_averaged_R<span class="classifier">bool [optional]</span></dt><dd><p>If set to True, compute R̂tot as the average over R̂(T ) for T ∈ [T̂D, Tmax ] instead of
R̂tot = R(T̂D ). If set to True, the setting for number_of_bootstraps_R_tot is ignored and
set to 0
(default=True)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltBBCEstimator.bayesian_bias_criterion">
<span class="sig-name descname"><span class="pre">bayesian_bias_criterion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R_nsb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R_plugin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bbc_tolerance</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltBBCEstimator.bayesian_bias_criterion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltBBCEstimator.bayesian_bias_criterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Get whether the Bayesian bias criterion (bbc) is passed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R_nsb</strong> – history dependence computed with NSB estimator</p></li>
<li><p><strong>R_plugin</strong> – history dependence computed with plugin estimator</p></li>
<li><p><strong>bbc_tolerance</strong> – tolerance for the Bayesian bias criterion</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltBBCEstimator.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">past_symbol_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_symbol_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bbc_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltBBCEstimator.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltBBCEstimator.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the mutual information (MI) of one variable depending on its past
using nsb and plugin estimator and check if bias criterion is passed/</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>symbol_array<span class="classifier">1D numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
<dt>past_symbol_array<span class="classifier">numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
<dt>current_symbol_array<span class="classifier">numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>I (float)</dt><dd><p>MI (AIS)</p>
</dd>
<dt>R (float)</dt><dd><p>MI / H_uncond (History dependence)</p>
</dd>
<dt>bbc_term (float)</dt><dd><p>bbc tolerance-independent term of the Bayesian bias
criterion (bbc)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltBBCEstimator.get_bbc_term">
<span class="sig-name descname"><span class="pre">get_bbc_term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R_nsb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R_plugin</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltBBCEstimator.get_bbc_term"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltBBCEstimator.get_bbc_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bbc tolerance-independent term of the Bayesian bias
criterion (bbc).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R_nsb</strong> – history dependence computed with NSB estimator</p></li>
<li><p><strong>R_plugin</strong> – history dependence computed with plugin estimator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltNSBEstimatorSymbolsMI">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_Rudelt.</span></span><span class="sig-name descname"><span class="pre">RudeltNSBEstimatorSymbolsMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltNSBEstimatorSymbolsMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltNSBEstimatorSymbolsMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator" title="idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_Rudelt.RudeltAbstractNSBEstimator</span></code></a></p>
<p>History dependence NSB estimator</p>
<p>Calculate the mutual information (MI) of one variable depending on its past
using NSB estimator. See parent class for references.</p>
<p>implemented in idtxl by Michael Lindner, Göttingen 2021</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><ul class="simple">
<li><dl class="simple">
<dt>embedding_step_size<span class="classifier">float [optional]</span></dt><dd><p>Step size delta t (in seconds) with which the window is slid through the data
(default = 0.005).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>normalise<span class="classifier">bool [optional]</span></dt><dd><p>rebase spike times to zero
(default=True)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>return_averaged_R<span class="classifier">bool [optional]</span></dt><dd><p>If set to True, compute R̂tot as the average over R̂(T ) for T ∈ [T̂D, Tmax ] instead of
R̂tot = R(T̂D ). If set to True, the setting for number_of_bootstraps_R_tot is ignored and
set to 0
(default=True)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltNSBEstimatorSymbolsMI.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">past_symbol_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_symbol_array</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltNSBEstimatorSymbolsMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltNSBEstimatorSymbolsMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate mutual information using NSB estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>symbol_array<span class="classifier">1D numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
<dt>past_symbol_array<span class="classifier">numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
<dt>current_symbol_array<span class="classifier">numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>I (float)</dt><dd><p>MI (AIS)</p>
</dd>
<dt>R (float)</dt><dd><p>MI / H_uncond (History dependence)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltNSBEstimatorSymbolsMI.nsb_estimator">
<span class="sig-name descname"><span class="pre">nsb_estimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">past_symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphabet_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphabet_size_past</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H_uncond</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltNSBEstimatorSymbolsMI.nsb_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltNSBEstimatorSymbolsMI.nsb_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the entropy of a system using the NSB estimator.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltPluginEstimatorSymbolsMI">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_Rudelt.</span></span><span class="sig-name descname"><span class="pre">RudeltPluginEstimatorSymbolsMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltPluginEstimatorSymbolsMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltPluginEstimatorSymbolsMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_Rudelt.RudeltAbstractEstimator" title="idtxl.estimators_Rudelt.RudeltAbstractEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_Rudelt.RudeltAbstractEstimator</span></code></a></p>
<p>Plugin History dependence estimator</p>
<p>Calculate the mutual information (MI) of one variable depending on its past
using plugin estimator. See parent class for references.</p>
<p>implemented in idtxl by Michael Lindner, Göttingen 2021</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><ul class="simple">
<li><dl class="simple">
<dt>embedding_step_size<span class="classifier">float [optional] - Step size delta t (in seconds) with which the window is slid</span></dt><dd><p>through the data (default = 0.005).</p>
</dd>
</dl>
</li>
<li><p>normalise : bool [optional] - rebase spike times to zero (default=True)</p></li>
<li><p>return_averaged_R : bool [optional] - rebase spike times to zero (default=True)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltPluginEstimatorSymbolsMI.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">past_symbol_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_symbol_array</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltPluginEstimatorSymbolsMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltPluginEstimatorSymbolsMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate mutual information using plugin estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>symbol_array<span class="classifier">1D numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
<dt>past_symbol_array<span class="classifier">numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
<dt>current_symbol_array<span class="classifier">numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>I (float)</dt><dd><p>MI (AIS)</p>
</dd>
<dt>R (float)</dt><dd><p>MI / H_uncond (History dependence)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltPluginEstimatorSymbolsMI.plugin_entropy">
<span class="sig-name descname"><span class="pre">plugin_entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltPluginEstimatorSymbolsMI.plugin_entropy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltPluginEstimatorSymbolsMI.plugin_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the entropy of a system using the Plugin estimator.</p>
<p>(In principle this is the same function as utl.get_shannon_entropy,
only here it is a function of the multiplicities, not the probabilities.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mk</strong> – multiplicities</p></li>
<li><p><strong>N</strong> – total number of observed symbols</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltPluginEstimatorSymbolsMI.plugin_estimator">
<span class="sig-name descname"><span class="pre">plugin_estimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">past_symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphabet_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphabet_size_past</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H_uncond</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltPluginEstimatorSymbolsMI.plugin_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltPluginEstimatorSymbolsMI.plugin_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the entropy of a system using the BBC estimator.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltShufflingEstimator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_Rudelt.</span></span><span class="sig-name descname"><span class="pre">RudeltShufflingEstimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltShufflingEstimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_Rudelt.RudeltAbstractEstimator" title="idtxl.estimators_Rudelt.RudeltAbstractEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_Rudelt.RudeltAbstractEstimator</span></code></a></p>
<p>Estimate the history dependence in a spike train using the shuffling estimator.</p>
<p>See parent class for references.</p>
<p>implemented in idtxl by Michael Lindner, Göttingen 2021</p>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltShufflingEstimator.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_array</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltShufflingEstimator.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the history dependence in a spike train using the shuffling estimator.</p>
<blockquote>
<div><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>symbol_array<span class="classifier">1D numpy array</span></dt><dd><p>realisations of symbols based on current and past states.
(first output of get_realisations_symbol from data_spiketimes object)</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>I (float)</dt><dd><p>MI (AIS)</p>
</dd>
<dt>R (float)</dt><dd><p>MI / H_uncond (History dependence)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_H0_X_past_cond_X">
<span class="sig-name descname"><span class="pre">get_H0_X_past_cond_X</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">marginal_probabilities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P_X_uncond</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_H0_X_past_cond_X"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_H0_X_past_cond_X" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute H_0(X_past | X), the estimate of the entropy for the past
symbols given a response, under the assumption that activity in
the past contributes independently towards the response.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_H0_X_past_cond_X_eq_x">
<span class="sig-name descname"><span class="pre">get_H0_X_past_cond_X_eq_x</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">marginal_probabilities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_H0_X_past_cond_X_eq_x"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_H0_X_past_cond_X_eq_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute H_0(X_past | X = x), cf get_H0_X_past_cond_X.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_H_X_past_cond_X">
<span class="sig-name descname"><span class="pre">get_H_X_past_cond_X</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P_X_uncond</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P_X_past_cond_X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_H_X_past_cond_X"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_H_X_past_cond_X" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute H(X_past | X), the plug-in estimate of the conditional entropy for the past
symbols, conditioned on the response X,  given their probabilities.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_H_X_past_uncond">
<span class="sig-name descname"><span class="pre">get_H_X_past_uncond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P_X_past_uncond</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_H_X_past_uncond"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_H_X_past_uncond" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute H(X_past), the plug-in estimate of the entropy for the past symbols, given
their probabilities.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_P_X_past_cond_X">
<span class="sig-name descname"><span class="pre">get_P_X_past_cond_X</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">past_symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_symbols</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_P_X_past_cond_X"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_P_X_past_cond_X" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute P(X_past | X), the probability of the past activity conditioned
on the response X using the plug-in estimator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_P_X_past_uncond">
<span class="sig-name descname"><span class="pre">get_P_X_past_uncond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">past_symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_symbols</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_P_X_past_uncond"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_P_X_past_uncond" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute P(X_past), the probability of the past activity using
the plug-in estimator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_P_X_uncond">
<span class="sig-name descname"><span class="pre">get_P_X_uncond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_of_symbols</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_P_X_uncond"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_P_X_uncond" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute P(X), the probability of the current activity using
the plug-in estimator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_marginal_frequencies_of_spikes_in_bins">
<span class="sig-name descname"><span class="pre">get_marginal_frequencies_of_spikes_in_bins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_marginal_frequencies_of_spikes_in_bins"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_marginal_frequencies_of_spikes_in_bins" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute for each past bin 1…d the sum of spikes found in that bin across all
observed symbols.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_shuffled_symbol_counts">
<span class="sig-name descname"><span class="pre">get_shuffled_symbol_counts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">past_symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_symbols</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.get_shuffled_symbol_counts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltShufflingEstimator.get_shuffled_symbol_counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate new data by, for each past bin 1…d, permutating the activity
across all observed past_symbols (for a given response X). The marginal
probability of observing a spike given the response is thus preserved for
each past bin.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_Rudelt.RudeltShufflingEstimator.shuffling_MI">
<span class="sig-name descname"><span class="pre">shuffling_MI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol_counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_bins_d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_Rudelt.html#RudeltShufflingEstimator.shuffling_MI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_Rudelt.RudeltShufflingEstimator.shuffling_MI" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the mutual information between current and past activity
in a spike train using the shuffling estimator.</p>
<p>To obtain the shuffling estimate, compute the plug-in estimate and
a correction term to reduce its bias.</p>
<p>For the plug-in estimate:</p>
<ul class="simple">
<li><p>Extract the past_symbol_counts from the symbol_counts.</p></li>
<li><p>I_plugin = H(X_past) - H(X_past | X)</p></li>
</ul>
<p>Notation:</p>
<ul class="simple">
<li><p>X: current activity, aka response</p></li>
<li><p>X_past: past activity</p></li>
<li><p>P_X_uncond: P(X)</p></li>
<li><p>P_X_past_uncond: P(X_past)</p></li>
<li><p>P_X_past_cond_X: P(X_past | X)</p></li>
<li><p>H_X_past_uncond: H(X_past)</p></li>
<li><p>H_X_past_cond_X: H(X_past | X)</p></li>
<li><p>I_plugin: plugin estimate of I(X_past; X)</p></li>
</ul>
<p>For the correction term:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Simulate additional data under the assumption that activity</dt><dd><p>in the past contributes independently towards the current activity.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Compute the entropy under the assumptions of the model, which</dt><dd><p>due to its simplicity is easy to sample and the estimate unbiased</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Compute the entropy using the plug-in estimate, whose bias is</dt><dd><p>similar to that of the plug-in estimate on the original data</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Compute the correction term as the difference between the</dt><dd><p>unbiased and biased terms</p>
</dd>
</dl>
</li>
</ul>
<p>Notation:</p>
<ul class="simple">
<li><p>P0_sh_X_past_cond_X: P_0,sh(X_past | X), equiv. to P(X_past | X)
on the shuffled data</p></li>
<li><p>H0_X_past_cond_X: H_0(X_past | X), based on the model of independent
contributions</p></li>
<li><p>H0_sh_X_past_cond_X: H_0,sh(X_past | X), based on</p></li>
<li><p>P0_sh_X_past_cond_X, ie the plug-in estimate</p></li>
<li><p>I_corr: the correction term to reduce the bias of I_plugin</p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>symbol_counts<span class="classifier">iterable</span></dt><dd><p>the activity of a spike train is embedded into symbols,
whose occurrences are counted (cf emb.get_symbol_counts)</p>
</dd>
<dt>number_of_bins_d<span class="classifier">int</span></dt><dd><p>the number of bins of the embedding</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.estimators_jidt">
<span id="idtxl-estimators-jidt-module"></span><h2>idtxl.estimators_jidt module<a class="headerlink" href="#module-idtxl.estimators_jidt" title="Permalink to this headline">¶</a></h2>
<p>Provide JIDT estimators.</p>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtDiscrete">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtDiscrete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscrete"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscrete" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtEstimator" title="idtxl.estimators_jidt.JidtEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtEstimator</span></code></a></p>
<p>Abstract class for implementation of discrete JIDT-estimators.</p>
<p>Abstract class for implementation of plug-in JIDT-estimators for discrete
data. Child classes implement estimators for mutual information (MI),
conditional mutual information (CMI), actice information storage (AIS), and
transfer entropy (TE). See parent class for references.</p>
<p>Set common estimation parameters for discrete JIDT-estimators. For usage of
these estimators see documentation for the child classes.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>discretise_method : str [optional] - if and how to discretise
incoming continuous data, can be ‘max_ent’ for maximum entropy
binning, ‘equal’ for equal size bins, and ‘none’ if no binning is
required (default=’none’)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Discrete JIDT estimators require the data’s alphabet size for
instantiation. Hence, opposed to the Kraskov and Gaussian estimators,
the JAVA class is added to the object instance, while for Kraskov/
Gaussian estimators an instance of that class is added (because for the
latter, objects can be instantiated independent of data properties).</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtDiscrete.estimate_surrogates_analytic">
<span class="sig-name descname"><span class="pre">estimate_surrogates_analytic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_perm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscrete.estimate_surrogates_analytic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscrete.estimate_surrogates_analytic" title="Permalink to this definition">¶</a></dt>
<dd><p>Return estimate of the analytical surrogate distribution.</p>
<p>This method must be implemented because this class’
is_analytic_null_estimator() method returns true.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>n_perms<span class="classifier">int [optional]</span></dt><dd><p>number of permutations (default=200)</p>
</dd>
<dt>data<span class="classifier">numpy arrays</span></dt><dd><p>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for
CMI). Formatted as per the estimate method for this estimator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>n_perm surrogates of the average MI/CMI/TE over all samples
under the null hypothesis of no relationship between var1 and
var2 (in the context of conditional)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtDiscrete.get_analytic_distribution">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_analytic_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscrete.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscrete.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">numpy arrays</span></dt><dd><p>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for
CMI). Formatted as per the estimate method for this estimator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtDiscrete.is_analytic_null_estimator">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscrete.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscrete.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtDiscreteAIS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtDiscreteAIS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteAIS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteAIS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtDiscrete" title="idtxl.estimators_jidt.JidtDiscrete"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtDiscrete</span></code></a></p>
<p>Calculate AIS with JIDT’s discrete-variable implementation.</p>
<p>Calculate the active information storage (AIS) for one process. Call JIDT
via jpype and use the discrete estimator. See parent class for references.</p>
<p>Results are returned in bits.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>history : int - number of samples in the target’s past used as
embedding (&gt;= 0)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>discretise_method : str [optional] - if and how to discretise
incoming continuous data, can be ‘max_ent’ for maximum entropy
binning, ‘equal’ for equal size bins, and ‘none’ if no binning is
required (default=’none’)</p></li>
<li><p>n_discrete_bins : int [optional] - number of discrete bins/
levels or the base of each dimension of the discrete variables
(default=2). If set, this parameter overwrites/sets alph. (&gt;= 2)</p></li>
<li><p>alph : int [optional] - number of discrete bins/levels for var1
(default=2 , or the value set for n_discrete_bins). (&gt;= 2)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtDiscreteAIS.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_calc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteAIS.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteAIS.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate active information storage.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>process<span class="classifier">numpy array</span></dt><dd><p>realisations as either a 2D numpy array where array dimensions
represent [realisations x variable dimension] or a 1D array
representing [realisations], array type can be float (requires
discretisation) or int</p>
</dd>
<dt>return_calc<span class="classifier">boolean</span></dt><dd><p>return the calculator used here as well as the numeric
calculated value(s)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average AIS over all samples or local AIS for individual
samples if ‘local_values’=True</p>
</dd>
<dt>Java object</dt><dd><p>JIDT calculator that was used here. Only returned if
return_calc was set.</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.JidtOutOfMemoryError</dt><dd><p>Raised when JIDT object cannot be instantiated due to mem error</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtDiscreteAIS.get_analytic_distribution">
<span class="sig-name descname"><span class="pre">get_analytic_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteAIS.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteAIS.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>process<span class="classifier">numpy array</span></dt><dd><p>realisations as either a 2D numpy array where array dimensions
represent [realisations x variable dimension] or a 1D array
representing [realisations], array type can be float (requires
discretisation) or int</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtDiscreteCMI">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtDiscreteCMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteCMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteCMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtDiscrete" title="idtxl.estimators_jidt.JidtDiscrete"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtDiscrete</span></code></a></p>
<p>Calculate CMI with JIDT’s implementation for discrete variables.</p>
<p>Calculate the conditional mutual information between two variables given
the third. Call JIDT via jpype and use the discrete estimator. See parent
class for references.</p>
<p>Results are returned in bits.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>discretise_method : str [optional] - if and how to discretise
incoming continuous data, can be ‘max_ent’ for maximum entropy
binning, ‘equal’ for equal size bins, and ‘none’ if no binning is
required (default=’none’)</p></li>
<li><p>n_discrete_bins : int [optional] - number of discrete bins/
levels or the base of each dimension of the discrete variables
(default=2). If set, this parameter overwrites/sets alph1, alph2
and alphc</p></li>
<li><p>alph1 : int [optional] - number of discrete bins/levels for var1
(default=2, or the value set for n_discrete_bins)</p></li>
<li><p>alph2 : int [optional] - number of discrete bins/levels for var2
(default=2, or the value set for n_discrete_bins)</p></li>
<li><p>alphc : int [optional] - number of discrete bins/levels for
conditional (default=2, or the value set for n_discrete_bins)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtDiscreteCMI.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_calc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteCMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteCMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate conditional mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</p>
</dd>
<dt>return_calc<span class="classifier">boolean</span></dt><dd><p>return the calculator used here as well as the numeric
calculated value(s)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average CMI over all samples or local CMI for individual
samples if ‘local_values’=True</p>
</dd>
<dt>Java object</dt><dd><p>JIDT calculator that was used here. Only returned if
return_calc was set.</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.JidtOutOfMemoryError</dt><dd><p>Raised when JIDT object cannot be instantiated due to mem error</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtDiscreteCMI.get_analytic_distribution">
<span class="sig-name descname"><span class="pre">get_analytic_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteCMI.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteCMI.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtDiscreteMI">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtDiscreteMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtDiscrete" title="idtxl.estimators_jidt.JidtDiscrete"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtDiscrete</span></code></a></p>
<p>Calculate MI with JIDT’s discrete-variable implementation.</p>
<p>Calculate the mutual information (MI) between two variables. Call JIDT via
jpype and use the discrete estimator. See parent class for references.</p>
<p>Results are returned in bits.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>discretise_method : str [optional] - if and how to discretise
incoming continuous data, can be ‘max_ent’ for maximum entropy
binning, ‘equal’ for equal size bins, and ‘none’ if no binning is
required (default=’none’)</p></li>
<li><p>n_discrete_bins : int [optional] - number of discrete bins/
levels or the base of each dimension of the discrete variables
(default=2). If set, this parameter overwrites/sets alph1 and
alph2</p></li>
<li><p>alph1 : int [optional] - number of discrete bins/levels for var1
(default=2, or the value set for n_discrete_bins)</p></li>
<li><p>alph2 : int [optional] - number of discrete bins/levels for var2
(default=2, or the value set for n_discrete_bins)</p></li>
<li><p>lag_mi : int [optional] - time difference in samples to calculate
the lagged MI between processes (default=0)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtDiscreteMI.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_calc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>return_calc<span class="classifier">boolean</span></dt><dd><p>return the calculator used here as well as the numeric
calculated value(s)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average MI over all samples or local MI for individual
samples if ‘local_values’=True</p>
</dd>
<dt>Java object</dt><dd><p>JIDT calculator that was used here. Only returned if
return_calc was set.</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.JidtOutOfMemoryError</dt><dd><p>Raised when JIDT object cannot be instantiated due to mem error</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtDiscreteMI.get_analytic_distribution">
<span class="sig-name descname"><span class="pre">get_analytic_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteMI.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteMI.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtDiscreteTE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtDiscreteTE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtDiscrete" title="idtxl.estimators_jidt.JidtDiscrete"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtDiscrete</span></code></a></p>
<p>Calculate TE with JIDT’s implementation for discrete variables.</p>
<p>Calculate the transfer entropy between two time series processes.
Call JIDT via jpype and use the discrete estimator. Transfer entropy is
defined as the conditional mutual information between the source’s past
state and the target’s current value, conditional on the target’s past.
See parent class for references.</p>
<p>Results are returned in bits.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>history_target : int - number of samples in the target’s past
used as embedding. (&gt;= 0)</p></li>
<li><p>history_source  : int [optional] - number of samples in the
source’s past used as embedding (default=same as the target
history). (&gt;= 1)</p></li>
<li><p>tau_source : int [optional] - source’s embedding delay
(default=1). (&gt;= 1)</p></li>
<li><p>tau_target : int [optional] - target’s embedding delay
(default=1). (&gt;= 1)</p></li>
<li><p>source_target_delay : int [optional] - information transfer delay
between source and target (default=1) (&gt;= 0)</p></li>
<li><p>discretise_method : str [optional] - if and how to discretise
incoming continuous data, can be ‘max_ent’ for maximum entropy
binning, ‘equal’ for equal size bins, and ‘none’ if no binning is
required (default=’none’)</p></li>
<li><p>n_discrete_bins : int [optional] - number of discrete bins/
levels or the base of each dimension of the discrete variables
(default=2). If set, this parameter overwrites/sets alph1 and
alph2. (&gt;= 2)</p></li>
<li><p>alph1 : int [optional] - number of discrete bins/levels for
source (default=2, or the value set for n_discrete_bins). (&gt;= 2)</p></li>
<li><p>alph2 : int [optional] - number of discrete bins/levels for
target (default=2, or the value set for n_discrete_bins). (&gt;= 2)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtDiscreteTE.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_calc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteTE.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteTE.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate transfer entropy from a source to a target variable.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>source<span class="classifier">numpy array</span></dt><dd><p>realisations of source variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>target<span class="classifier">numpy array</span></dt><dd><p>realisations of target variable (similar to var1)</p>
</dd>
<dt>return_calc<span class="classifier">boolean</span></dt><dd><p>return the calculator used here as well as the numeric
calculated value(s)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average TE over all samples or local TE for individual
samples if ‘local_values’=True</p>
</dd>
<dt>Java object</dt><dd><p>JIDT calculator that was used here. Only returned if
return_calc was set.</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.JidtOutOfMemoryError</dt><dd><p>Raised when JIDT object cannot be instantiated due to mem error</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtDiscreteTE.get_analytic_distribution">
<span class="sig-name descname"><span class="pre">get_analytic_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteTE.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteTE.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>source<span class="classifier">numpy array</span></dt><dd><p>realisations of source variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>target<span class="classifier">numpy array</span></dt><dd><p>realisations of target variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtEstimator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtEstimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtEstimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimator.Estimator</span></code></p>
<p>Abstract class for implementation of JIDT estimators.</p>
<p>Abstract class for implementation of JIDT estimators, child classes
implement estimators for mutual information (MI), conditional mutual
information (CMI), active information storage (AIS), transfer entropy (TE)
using the Kraskov-Grassberger-Stoegbauer estimator for continuous data,
plug-in estimators for discrete data, and Gaussian estimators for
continuous Gaussian data.</p>
<p>References:</p>
<ul class="simple">
<li><p>Lizier, Joseph T. (2014). JIDT: an information-theoretic toolkit for
studying the dynamics of complex systems. Front Robot AI, 1(11).</p></li>
<li><p>Kraskov, A., Stoegbauer, H., &amp; Grassberger, P. (2004). Estimating mutual
information. Phys Rev E, 69(6), 066138.</p></li>
<li><p>Lizier, Joseph T., Mikhail Prokopenko, and Albert Y. Zomaya. (2012).
Local measures of information storage in complex distributed computation.
Inform Sci, 208, 39-54.</p></li>
<li><p>Schreiber, T. (2000). Measuring information transfer. Phys Rev Lett,
85(2), 461.</p></li>
</ul>
<p>Set common estimation parameters for JIDT estimators. For usage of these
estimators see documentation for the child classes.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtEstimator.is_parallel">
<span class="sig-name descname"><span class="pre">is_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtEstimator.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtEstimator.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtGaussian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtGaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">CalcClass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtEstimator" title="idtxl.estimators_jidt.JidtEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtEstimator</span></code></a></p>
<p>Abstract class for implementation of JIDT Gaussian-estimators.</p>
<p>Abstract class for implementation of JIDT Gaussian-estimators, child
classes implement estimators for mutual information (MI), conditional
mutual information (CMI), actice information storage (AIS), transfer
entropy (TE) using JIDT’s Gaussian estimator for continuous data. See
parent class for references.</p>
<p>Set common estimation parameters for JIDT Kraskov-estimators. For usage of
these estimators see documentation for the child classes.</p>
<p>Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>CalcClass<span class="classifier">JAVA class</span></dt><dd><p>JAVA class returned by jpype.JPackage</p>
</dd>
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtGaussian.estimate_surrogates_analytic">
<span class="sig-name descname"><span class="pre">estimate_surrogates_analytic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_perm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussian.estimate_surrogates_analytic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussian.estimate_surrogates_analytic" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the surrogate distribution analytically.
This method must be implemented because this class’
is_analytic_null_estimator() method returns true</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>n_perms<span class="classifier">int</span></dt><dd><p>number of permutations (default=200)</p>
</dd>
<dt>data<span class="classifier">numpy arrays</span></dt><dd><p>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for
CMI). Formatted as per estimate_parallel for this estimator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>n_perm surrogates of the average MI/CMI/TE over all samples
under the null hypothesis of no relationship between var1 and
var2 (in the context of conditional)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtGaussian.get_analytic_distribution">
<span class="sig-name descname"><span class="pre">get_analytic_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussian.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussian.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">numpy arrays</span></dt><dd><p>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for
CMI). Formatted as per the estimate method for this estimator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtGaussian.is_analytic_null_estimator">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussian.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussian.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtGaussianAIS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtGaussianAIS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianAIS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianAIS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtGaussian" title="idtxl.estimators_jidt.JidtGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtGaussian</span></code></a></p>
<p>Calculate active information storage with JIDT’s Gaussian implementation.</p>
<p>Calculate active information storage (AIS) for some process using JIDT’s
implementation of the Gaussian estimator. AIS is defined as the
mutual information between the processes’ past state and current value.</p>
<p>The past state needs to be defined in the settings dictionary, where a past
state is defined as a uniform embedding with parameters history and tau.
The history describes the number of samples taken from a processes’ past,
tau describes the embedding delay, i.e., the spacing between every two
samples from the processes’ past.</p>
<p>See parent class for references.Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>history : int - number of samples in the processes’ past used as
embedding</p></li>
<li><p>tau : int [optional] - the processes’ embedding delay (default=1)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the AIS estimator to save
computation time. The Theiler window ignores trial boundaries. The
AIS estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtGaussianAIS.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianAIS.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianAIS.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate active information storage.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>process<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average AIS over all samples or local AIS for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtGaussianCMI">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtGaussianCMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianCMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianCMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtGaussian" title="idtxl.estimators_jidt.JidtGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtGaussian</span></code></a></p>
<p>Calculate conditional mutual infor with JIDT’s Gaussian implementation.</p>
<p>Computes the differential conditional mutual information of two
multivariate sets of observations, conditioned on another, assuming that
the probability distribution function for these observations is a
multivariate Gaussian distribution.
Call JIDT via jpype and use
ConditionalMutualInfoCalculatorMultiVariateGaussian estimator.
If no conditional is given (is None), the function returns the mutual
information between var1 and var2.</p>
<p>See parent class for references. Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI estimator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtGaussianCMI.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianCMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianCMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate conditional mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average CMI over all samples or local CMI for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtGaussianCMI.get_analytic_distribution">
<span class="sig-name descname"><span class="pre">get_analytic_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianCMI.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianCMI.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtGaussianMI">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtGaussianMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtGaussian" title="idtxl.estimators_jidt.JidtGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtGaussian</span></code></a></p>
<p>Calculate mutual information with JIDT’s Gaussian implementation.</p>
<p>Calculate the mutual information between two variables. Call JIDT via jpype
and use the Gaussian estimator. See parent class for references.</p>
<p>Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>lag_mi : int [optional] - time difference in samples to calculate
the lagged MI between processes (default=0)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the MI estimator to save
computation time. The Theiler window ignores trial boundaries. The
MI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtGaussianMI.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average MI over all samples or local MI for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtGaussianTE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtGaussianTE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtGaussian" title="idtxl.estimators_jidt.JidtGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtGaussian</span></code></a></p>
<p>Calculate transfer entropy with JIDT’s Gaussian implementation.</p>
<p>Calculate transfer entropy between a source and a target variable using
JIDT’s implementation of the Gaussian estimator. Transfer entropy is
defined as the conditional mutual information between the source’s past
state and the target’s current value, conditional on the target’s past.</p>
<p>Past states need to be defined in the settings dictionary, where a past
state is defined as a uniform embedding with parameters history and tau.
The history describes the number of samples taken from a variable’s past,
tau descrices the embedding delay, i.e., the spacing between every two
samples from the processes’ past.</p>
<p>See parent class for references. Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>history_target : int - number of samples in the target’s past
used as embedding</p></li>
<li><p>history_source  : int [optional] - number of samples in the
source’s past used as embedding (default=same as the target
history)</p></li>
<li><p>tau_source : int [optional] - source’s embedding delay
(default=1)</p></li>
<li><p>tau_target : int [optional] - target’s embedding delay
(default=1)</p></li>
<li><p>source_target_delay : int [optional] - information transfer delay
between source and target (default=1)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI estimator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtGaussianTE.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianTE.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianTE.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate transfer entropy from a source to a target variable.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>source<span class="classifier">numpy array</span></dt><dd><p>realisations of source variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of target variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average TE over all samples or local TE for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtKraskov">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtKraskov</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">CalcClass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskov"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskov" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtEstimator" title="idtxl.estimators_jidt.JidtEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtEstimator</span></code></a></p>
<p>Abstract class for implementation of JIDT Kraskov-estimators.</p>
<p>Abstract class for implementation of JIDT Kraskov-estimators, child classes
implement estimators for mutual information (MI), conditional mutual
information (CMI), actice information storage (AIS), transfer entropy (TE)
using the Kraskov-Grassberger-Stoegbauer estimator for continuous data.
See parent class for references.</p>
<p>Set common estimation parameters for JIDT Kraskov-estimators. For usage of
these estimators see documentation for the child classes.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>CalcClass<span class="classifier">JAVA class</span></dt><dd><p>JAVA class returned by jpype.JPackage</p>
</dd>
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>num_threads : int | str [optional] - number of threads used for
estimation (default=’USE_ALL’, note that this uses <em>all</em>
available threads on the current machine)</p></li>
<li><p>algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)
to use (default=1). Only applied at this method for TE and AIS
(is already applied for MI/CMI). Note that default algorithm of 1
here is different to the default ALG_NUM argument for the JIDT
AIS KSG estimator.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtKraskov.is_analytic_null_estimator">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskov.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskov.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtKraskovAIS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtKraskovAIS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovAIS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovAIS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtKraskov" title="idtxl.estimators_jidt.JidtKraskov"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtKraskov</span></code></a></p>
<p>Calculate active information storage with JIDT’s Kraskov implementation.</p>
<p>Calculate active information storage (AIS) for some process using JIDT’s
implementation of the Kraskov type 1 estimator. AIS is defined as the
mutual information between the processes’ past state and current value.</p>
<p>The past state needs to be defined in the settings dictionary, where a past
state is defined as a uniform embedding with parameters history and tau.
The history describes the number of samples taken from a processes’ past,
tau describes the embedding delay, i.e., the spacing between every two
samples from the processes’ past.</p>
<p>See parent class for references. Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>history : int - number of samples in the processes’ past used as
embedding</p></li>
<li><p>tau : int [optional] - the processes’ embedding delay (default=1)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>num_threads : int | str [optional] - number of threads used for
estimation (default=’USE_ALL’, note that this uses <em>all</em>
available threads on the current machine)</p></li>
<li><p>algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)
to use (default=1)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the AIS estimator to save
computation time. The Theiler window ignores trial boundaries. The
AIS estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtKraskovAIS.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovAIS.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovAIS.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate active information storage.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>process<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average AIS over all samples or local AIS for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtKraskovCMI">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtKraskovCMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovCMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovCMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtKraskov" title="idtxl.estimators_jidt.JidtKraskov"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtKraskov</span></code></a></p>
<p>Calculate conditional mutual inform with JIDT’s Kraskov implementation.</p>
<p>Calculate the conditional mutual information (CMI) between three variables.
Call JIDT via jpype and use the Kraskov 1 estimator. If no conditional is
given (is None), the function returns the mutual information between var1
and var2. See parent class for references.</p>
<blockquote>
<div><p>Results are returned in nats.</p>
</div></blockquote>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>num_threads : int | str [optional] - number of threads used for
estimation (default=’USE_ALL’, note that this uses <em>all</em>
available threads on the current machine)</p></li>
<li><p>algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)
to use (default=1)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI estimator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtKraskovCMI.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovCMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovCMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate conditional mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average CMI over all samples or local CMI for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtKraskovMI">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtKraskovMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtKraskov" title="idtxl.estimators_jidt.JidtKraskov"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtKraskov</span></code></a></p>
<p>Calculate mutual information with JIDT’s Kraskov implementation.</p>
<p>Calculate the mutual information between two variables. Call JIDT via jpype
and use the Kraskov 1 estimator. See parent class for references.</p>
<p>Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>num_threads : int | str [optional] - number of threads used for
estimation (default=’USE_ALL’, note that this uses <em>all</em>
available threads on the current machine)</p></li>
<li><p>algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)
to use (default=1)</p></li>
<li><p>lag_mi : int [optional] - time difference in samples to calculate
the lagged MI between processes (default=0)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the MI estimator to save
computation time. The Theiler window ignores trial boundaries. The
MI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtKraskovMI.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average MI over all samples or local MI for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtKraskovTE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">JidtKraskovTE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtKraskov" title="idtxl.estimators_jidt.JidtKraskov"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtKraskov</span></code></a></p>
<p>Calculate transfer entropy with JIDT’s Kraskov implementation.</p>
<p>Calculate transfer entropy between a source and a target variable using
JIDT’s implementation of the Kraskov type 1 estimator. Transfer entropy is
defined as the conditional mutual information between the source’s past
state and the target’s current value, conditional on the target’s past.</p>
<p>Past states need to be defined in the settings dictionary, where a past
state is defined as a uniform embedding with parameters history and tau.
The history describes the number of samples taken from a variable’s past,
tau descrices the embedding delay, i.e., the spacing between every two
samples from the processes’ past.</p>
<p>See parent class for references. Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>history_target : int - number of samples in the target’s past
used as embedding</p></li>
<li><p>history_source  : int [optional] - number of samples in the
source’s past used as embedding (default=same as the target
history)</p></li>
<li><p>tau_source : int [optional] - source’s embedding delay
(default=1)</p></li>
<li><p>tau_target : int [optional] - target’s embedding delay
(default=1)</p></li>
<li><p>source_target_delay : int [optional] - information transfer delay
between source and target (default=1)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)
to use (default=1)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI estimator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.JidtKraskovTE.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovTE.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovTE.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate transfer entropy from a source to a target variable.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>source<span class="classifier">numpy array</span></dt><dd><p>realisations of source variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of target variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average TE over all samples or local TE for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.estimators_jidt.common_estimate_surrogates_analytic">
<span class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></span><span class="sig-name descname"><span class="pre">common_estimate_surrogates_analytic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_perm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#common_estimate_surrogates_analytic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.common_estimate_surrogates_analytic" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the surrogate distribution analytically for JidtEstimator.</p>
<p>Estimate the surrogate distribution analytically for a JidtEstimator
which is_analytic_null_estimator(), by sampling estimates at random
p-values in the analytic distribution.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>estimator<span class="classifier">a JidtEstimator object, which returns True to a call to</span></dt><dd><p>its is_analytic_null_estimator() method</p>
</dd>
<dt>n_perms<span class="classifier">int</span></dt><dd><p>number of permutations (default=200)</p>
</dd>
<dt>data<span class="classifier">numpy arrays</span></dt><dd><p>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for CMI)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>n_perm surrogates of the average MI/CMI/TE over all samples
under the null hypothesis of no relationship between var1 and
var2 (in the context of conditional)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-idtxl.estimators_opencl">
<span id="idtxl-estimators-opencl-module"></span><h2>idtxl.estimators_opencl module<a class="headerlink" href="#module-idtxl.estimators_opencl" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_opencl.OpenCLKraskov">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_opencl.</span></span><span class="sig-name descname"><span class="pre">OpenCLKraskov</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskov"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskov" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimator.Estimator</span></code></p>
<p>Abstract class for implementation of OpenCL estimators.</p>
<p>Abstract class for implementation of OpenCL estimators, child classes
implement estimators for mutual information (MI) and conditional mutual
information (CMI) using the Kraskov-Grassberger-Stoegbauer estimator for
continuous data.</p>
<p>References:</p>
<ul class="simple">
<li><p>Kraskov, A., Stoegbauer, H., &amp; Grassberger, P. (2004). Estimating mutual
information. Phys Rev E, 69(6), 066138.</p></li>
<li><p>Lizier, Joseph T., Mikhail Prokopenko, and Albert Y. Zomaya. (2012).
Local measures of information storage in complex distributed computation.
Inform Sci, 208, 39-54.</p></li>
<li><p>Schreiber, T. (2000). Measuring information transfer. Phys Rev Lett,
85(2), 461.</p></li>
</ul>
<p>Estimators can be used to perform multiple, independent searches in
parallel. Each of these parallel searches is called a ‘chunk’. To search
multiple chunks, provide point sets as 2D arrays, where the first
dimension represents samples or points, and the second dimension
represents the points’ dimensions. Concatenate chunk data in the first
dimension and pass the number of chunks to the estimators. Chunks must be
of equal size.</p>
<p>Set common estimation parameters for OpenCL estimators. For usage of these
estimators see documentation for the child classes.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>gpuid : int [optional] - device ID used for estimation (if more
than one device is available on the current platform) (default=0)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>padding : bool [optional] - pad data to a length that is a
multiple of 1024, workaround for a</p></li>
<li><p>debug : bool [optional] - calculate intermediate results, i.e.
neighbour counts from range searches and KNN distances, print
debug output to console (default=False)</p></li>
<li><p>return_counts : bool [optional] - return intermediate results,
i.e. neighbour counts from range searches and KNN distances
(default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_opencl.OpenCLKraskov.is_analytic_null_estimator">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskov.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskov.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_opencl.OpenCLKraskov.is_parallel">
<span class="sig-name descname"><span class="pre">is_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskov.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskov.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_opencl.OpenCLKraskovCMI">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_opencl.</span></span><span class="sig-name descname"><span class="pre">OpenCLKraskovCMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskovCMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskovCMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_opencl.OpenCLKraskov" title="idtxl.estimators_opencl.OpenCLKraskov"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_opencl.OpenCLKraskov</span></code></a></p>
<p>Calculate conditional mutual inform with OpenCL Kraskov implementation.</p>
<p>Calculate the conditional mutual information (CMI) between three variables
using OpenCL GPU-code. If no conditional is given (is None), the function
returns the mutual information between var1 and var2. See parent class for
references.</p>
<p>Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>gpuid : int [optional] - device ID used for estimation (if more
than one device is available on the current platform) (default=0)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>debug : bool [optional] - return intermediate results, i.e.
neighbour counts from range searches and KNN distances
(default=False)</p></li>
<li><p>return_counts : bool [optional] - return intermediate results,
i.e. neighbour counts from range searches and KNN distances
(default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_opencl.OpenCLKraskovCMI.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_chunks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskovCMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskovCMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate conditional mutual information.</p>
<p>If conditional is None, the mutual information between var1 and var2 is
calculated.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [(realisations * n_chunks) x
variable dimension] or a 1D array representing [realisations],
array type should be int32</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array</span></dt><dd><p>realisations of conditioning variable (similar to var1)</p>
</dd>
<dt>n_chunks<span class="classifier">int</span></dt><dd><p>number of data chunks, no. data points has to be the same for
each chunk</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average CMI over all samples or local CMI for individual
samples if ‘local_values’=True</p>
</dd>
<dt>numpy arrays</dt><dd><p>distances and neighborhood counts for var1 and var2 if
debug=True and return_counts=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_opencl.OpenCLKraskovMI">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_opencl.</span></span><span class="sig-name descname"><span class="pre">OpenCLKraskovMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskovMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskovMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_opencl.OpenCLKraskov" title="idtxl.estimators_opencl.OpenCLKraskov"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_opencl.OpenCLKraskov</span></code></a></p>
<p>Calculate mutual information with OpenCL Kraskov implementation.</p>
<p>Calculate the mutual information (MI) between two variables using OpenCL
GPU-code. See parent class for references.</p>
<p>Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>gpuid : int [optional] - device ID used for estimation (if more
than one device is available on the current platform) (default=0)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>debug : bool [optional] - return intermediate results, i.e.
neighbour counts from range searches and KNN distances
(default=False)</p></li>
<li><p>return_counts : bool [optional] - return intermediate results,
i.e. neighbour counts from range searches and KNN distances
(default=False)</p></li>
<li><p>lag_mi : int [optional] - time difference in samples to calculate
the lagged MI between processes (default=0)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_opencl.OpenCLKraskovMI.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_chunks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskovMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskovMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [(realisations * n_chunks) x
variable dimension] or a 1D array representing [realisations],
array type should be int32</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>n_chunks<span class="classifier">int</span></dt><dd><p>number of data chunks, no. data points has to be the same for
each chunk</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average MI over all samples or local MI for individual
samples if ‘local_values’=True</p>
</dd>
<dt>numpy arrays</dt><dd><p>distances and neighborhood counts for var1 and var2 if
debug=True and return_counts=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.estimators_mpi">
<span id="idtxl-estimators-mpi-module"></span><h2>idtxl.estimators_mpi module<a class="headerlink" href="#module-idtxl.estimators_mpi" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_mpi.MPIEstimator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_mpi.</span></span><span class="sig-name descname"><span class="pre">MPIEstimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">est</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_mpi.html#MPIEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_mpi.MPIEstimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimator.Estimator</span></code></p>
<p>MPI Wrapper for arbitrary Estimator implementations</p>
<p>Make sure to have an “if __name__==’__main__’:” guard in your main script
to avoid infinite recursion!</p>
<p>To use MPI, add MPI=True to the Estimator settings dictionary and
optionally provide max_workers</p>
<dl>
<dt>Call using mpiexec:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mpiexec</span> <span class="o">-</span><span class="n">n</span> <span class="mi">1</span> <span class="o">-</span><span class="n">usize</span> <span class="o">&lt;</span><span class="nb">max</span> <span class="n">workers</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">python</span> <span class="o">&lt;</span><span class="n">python</span> <span class="n">script</span><span class="o">&gt;</span>
</pre></div>
</div>
</dd>
<dt>or, if MPI does not support spawning new workers (i.e. MPI version &lt; 2)</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mpiexec</span> <span class="o">-</span><span class="n">n</span> <span class="o">&lt;</span><span class="nb">max</span> <span class="n">workers</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">mpi4py</span><span class="o">.</span><span class="n">futures</span> <span class="o">&lt;</span><span class="n">python</span> <span class="n">script</span><span class="o">&gt;</span>
</pre></div>
</div>
</dd>
<dt>Call using slurm:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; srun -n $SLURM_NTASKS --mpi=pmi2 python -m mpi4py.futures &lt;python script&gt;
</pre></div>
</div>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_mpi.MPIEstimator.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_chunks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_mpi.html#MPIEstimator.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_mpi.MPIEstimator.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Distributes the given chunks of a task to Estimators on worker ranks using MPI.</p>
<p>Needs to be called with kwargs only.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>n_chunks<span class="classifier">int  [optional]</span></dt><dd><p>Number of chunks to split the data into, default=1.</p>
</dd>
<dt>data<span class="classifier">dict[str, Sequence]</span></dt><dd><p>Dictionary of random variable realizations</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>Estimates of information-theoretic quantities as np.double
values</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_mpi.MPIEstimator.estimate_surrogates_analytic">
<span class="sig-name descname"><span class="pre">estimate_surrogates_analytic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_mpi.html#MPIEstimator.estimate_surrogates_analytic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_mpi.MPIEstimator.estimate_surrogates_analytic" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward analytic estimation to the base Estimator.</p>
<p>Analytic estimation is assumed to have shorter runtime and is thus
performed on rank 0 alone for now.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_mpi.MPIEstimator.is_analytic_null_estimator">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_mpi.html#MPIEstimator.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_mpi.MPIEstimator.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the base Estimator is an analytic null estimator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_mpi.MPIEstimator.is_parallel">
<span class="sig-name descname"><span class="pre">is_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_mpi.html#MPIEstimator.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_mpi.MPIEstimator.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.estimators_python">
<span id="idtxl-estimators-python-module"></span><h2>idtxl.estimators_python module<a class="headerlink" href="#module-idtxl.estimators_python" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_python.PythonKraskovCMI">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_python.</span></span><span class="sig-name descname"><span class="pre">PythonKraskovCMI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_python.html#PythonKraskovCMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_python.PythonKraskovCMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimator.Estimator</span></code></p>
<p>Estimate conditional mutual information using Kraskov’s first estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>base : float - base of returned values (default=np=e)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>rng_seed : int | None [optional] - random seed if noise level &gt; 0</p></li>
<li><p>num_threads : int | str [optional] - number of threads used for
estimation (default=’USE_ALL’, note that this uses <em>all</em>
available threads on the current machine)</p></li>
<li><p>knn_finder : str [optional] - knn algorithm to use, can be
‘scipy_kdtree’ (default), ‘sklearn_kdtree’, or ‘sklearn_balltree’</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_python.PythonKraskovCMI.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_python.html#PythonKraskovCMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_python.PythonKraskovCMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate conditional mutual information between var1 and var2, given
conditional.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_python.PythonKraskovCMI.is_analytic_null_estimator">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_python.html#PythonKraskovCMI.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_python.PythonKraskovCMI.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_python.PythonKraskovCMI.is_parallel">
<span class="sig-name descname"><span class="pre">is_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_python.html#PythonKraskovCMI.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_python.PythonKraskovCMI.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.estimators_multivariate_pid">
<span id="idtxl-estimators-multivariate-pid-module"></span><h2>idtxl.estimators_multivariate_pid module<a class="headerlink" href="#module-idtxl.estimators_multivariate_pid" title="Permalink to this headline">¶</a></h2>
<p>Multivariate Partical information decomposition for discrete random variables.</p>
<p>This module provides an estimator for multivariate partial information
decomposition as proposed in</p>
<ul class="simple">
<li><p>Makkeh, A. &amp; Gutknecht, A. &amp; Wibral, M. (2020). A Differentiable measure
for shared information. 1- 27 Retrieved from
<a class="reference external" href="http://arxiv.org/abs/2002.03356">http://arxiv.org/abs/2002.03356</a></p></li>
</ul>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_multivariate_pid.SxPID">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_multivariate_pid.</span></span><span class="sig-name descname"><span class="pre">SxPID</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_multivariate_pid.html#SxPID"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_multivariate_pid.SxPID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimator.Estimator</span></code></p>
<p>Estimate partial information decomposition for multiple inputs.</p>
<p>Implementation of the multivariate partial information decomposition (PID)
estimator for discrete data with (up to 4 inputs) and one output. The
estimator finds shared information, unique information and synergistic
information between the multiple inputs s1, s2, …, sn with respect to the
output t for each realization (t, s1, …, sn) and then average them
according to their distribution weights p(t, s1, …, sn). Both the
pointwise (on the realization level) PID and the averaged PID are returned
(see the ‘return’ of ‘estimate()’).</p>
<p>The algorithm uses recursion to compute the partial information
decomposition.</p>
<p>References:</p>
<ul class="simple">
<li><p>Makkeh, A. &amp; Wibral, M. (2020). A differentiable pointwise partial
Information Decomposition estimator. <a class="reference external" href="https://github.com/Abzinger/SxPID">https://github.com/Abzinger/SxPID</a>.</p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>estimation parameters (with default parameters)</p>
<ul class="simple">
<li><p>verbose : bool [optional] - print output to console
(default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_multivariate_pid.SxPID.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_multivariate_pid.html#SxPID.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_multivariate_pid.SxPID.estimate" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>s<span class="classifier">list of numpy arrays</span></dt><dd><p>1D arrays containing realizations of a discrete random variable</p>
</dd>
<dt>t<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl>
<dt>dict of dict</dt><dd><dl>
<dt>{</dt><dd><p>‘ptw’ -&gt; { realization -&gt; {alpha -&gt; [float, float, float]} }</p>
<p>‘avg’ -&gt; {alpha -&gt; [float, float, float]}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>where the list of floats is ordered
[informative, misinformative, informative - misinformative]
ptw stands for pointwise decomposition
avg stands for average decomposition</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_multivariate_pid.SxPID.is_analytic_null_estimator">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_multivariate_pid.html#SxPID.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_multivariate_pid.SxPID.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_multivariate_pid.SxPID.is_parallel">
<span class="sig-name descname"><span class="pre">is_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_multivariate_pid.html#SxPID.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_multivariate_pid.SxPID.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.estimators_pid">
<span id="idtxl-estimators-pid-module"></span><h2>idtxl.estimators_pid module<a class="headerlink" href="#module-idtxl.estimators_pid" title="Permalink to this headline">¶</a></h2>
<p>Partical information decomposition for discrete random variables.</p>
<p>This module provides an estimator for partial information decomposition
as proposed in</p>
<p>Bertschinger, N., Rauh, J., Olbrich, E., Jost, J., &amp; Ay, N. (2014). Quantifying
Unique Information. Entropy, 16(4), 2161–2183. <a class="reference external" href="http://doi.org/10.3390/e16042161">http://doi.org/10.3390/e16042161</a></p>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_pid.SydneyPID">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_pid.</span></span><span class="sig-name descname"><span class="pre">SydneyPID</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#SydneyPID"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_pid.SydneyPID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimator.Estimator</span></code></p>
<p>Estimate partial information decomposition of discrete variables.</p>
<p>Fast implementation of the BROJA partial information decomposition (PID)
estimator for discrete data (Bertschinger, 2014). The estimator does not
require JAVA or GPU modules to run.</p>
<p>The estimator finds shared information, unique information and
synergistic information between the two inputs s1 and s2 with respect to
the output t.</p>
<p>Improved version with larger initial swaps and checking for convergence of
both the unique information from sources 1 and 2. The function counts the
empirical observations, calculates probabilities and the initial CMI, then
does the vitrualised swaps until it has converged, and finally calculates
the PID. The virtualised swaps stage contains two loops. An inner loop
which actually does the virtualised swapping, keeping the changes if the
CMI decreases; and an outer loop which decreases the size of the
probability mass increment the virtualised swapping utilises.</p>
<p>References</p>
<ul class="simple">
<li><p>Bertschinger, N., Rauh, J., Olbrich, E., Jost, J., &amp; Ay, N. (2014).
Quantifying unique information. Entropy, 16(4), 2161–2183.
<a class="reference external" href="http://doi.org/10.3390/e16042161">http://doi.org/10.3390/e16042161</a></p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>estimation parameters</p>
<ul class="simple">
<li><p>alph_s1 : int - alphabet size of s1</p></li>
<li><p>alph_s2 : int - alphabet size of s2</p></li>
<li><p>alph_t : int - alphabet size of t</p></li>
<li><p>max_unsuc_swaps_row_parm : int - soft limit for virtualised swaps
based on the number of unsuccessful swaps attempted in a row.
If there are too many unsuccessful swaps in a row, then it
will break the inner swap loop; the outer loop decrements the
size of the probability mass increment and then attemps
virtualised swaps again with the smaller probability increment.
The exact number of unsuccessful swaps allowed before breaking
is the total number of possible swaps (given our alphabet
sizes) times the control parameter max_unsuc_swaps_row_parm,
e.g., if the parameter is set to 3, this gives a high degree of
confidence that nearly (if not) all of the possible swaps have
been attempted before this soft limit breaks the swap loop.</p></li>
<li><p>num_reps : int -  number of times the outer loop will halve the
size of the probability increment used for the virtualised
swaps. This is in direct correspondence with the number of times
the empirical data was replicated in your original
implementation.</p></li>
<li><p>max_iters : int - provides a hard upper bound on the number of
times it will attempt to perform virtualised swaps in the inner
loop. However, this hard limit is (practically) never used as it
should always hit the soft limit defined above (parameter may be
removed in the future).</p></li>
<li><p>verbose : bool [optional] - print output to console
(default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_pid.SydneyPID.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#SydneyPID.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_pid.SydneyPID.estimate" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>s1<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
<dt>s2<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
<dt>t<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>estimated decomposition, contains the joint distribution,
unique, shared, and synergistic information</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_pid.SydneyPID.is_analytic_null_estimator">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#SydneyPID.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_pid.SydneyPID.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_pid.SydneyPID.is_parallel">
<span class="sig-name descname"><span class="pre">is_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#SydneyPID.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_pid.SydneyPID.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.estimators_pid.TartuPID">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.estimators_pid.</span></span><span class="sig-name descname"><span class="pre">TartuPID</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#TartuPID"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_pid.TartuPID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimator.Estimator</span></code></p>
<p>Estimate partial information decomposition for two inputs and one output</p>
<p>Implementation of the partial information decomposition (PID) estimator for
discrete data. The estimator finds shared information, unique information
and synergistic information between the two inputs s1 and s2 with respect
to the output t.</p>
<p>The algorithm uses exponential cone programming and requires the Python
package for ECOS: Embedded Cone Solver (<a class="reference external" href="https://pypi.python.org/pypi/ecos">https://pypi.python.org/pypi/ecos</a>).</p>
<p>References:</p>
<ul class="simple">
<li><p>Makkeh, A., Theis, D.O., &amp; Vicente, R. (2017). Bivariate Partial
Information Decomposition: The Optimization Perspective. Entropy, 19(10),
530.</p></li>
<li><p>Makkeh, A., Theis, D.O., &amp; Vicente, R. (2018). BROJA-2PID: A cone
programming based Partial Information Decomposition estimator. Entropy,
20(271), <a class="reference external" href="https://github.com/Abzinger/BROJA_2PID">https://github.com/Abzinger/BROJA_2PID</a>.</p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>estimation parameters (with default parameters)</p>
<ul class="simple">
<li><p>verbose : bool [optional] - print output to console
(default=False)</p></li>
<li><p>cone_solver : str [optional] - which cone solver to use
(default=’ECOS’)</p></li>
<li><p>solver_args : dict [optional] - solver arguments (default={})</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_pid.TartuPID.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#TartuPID.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_pid.TartuPID.estimate" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>s1<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
<dt>s2<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
<dt>t<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>estimated decomposition, solver used, numerical error</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_pid.TartuPID.is_analytic_null_estimator">
<span class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#TartuPID.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_pid.TartuPID.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.estimators_pid.TartuPID.is_parallel">
<span class="sig-name descname"><span class="pre">is_parallel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#TartuPID.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_pid.TartuPID.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.idtxl_exceptions">
<span id="idtxl-idtxl-exceptions-module"></span><h2>idtxl.idtxl_exceptions module<a class="headerlink" href="#module-idtxl.idtxl_exceptions" title="Permalink to this headline">¶</a></h2>
<p>Provide error handling and warnings.</p>
<dl class="py exception">
<dt class="sig sig-object py" id="idtxl.idtxl_exceptions.AlgorithmExhaustedError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_exceptions.</span></span><span class="sig-name descname"><span class="pre">AlgorithmExhaustedError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_exceptions.html#AlgorithmExhaustedError"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_exceptions.AlgorithmExhaustedError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Exception raised to signal that the estimators can no longer be used
for this particular target (e.g. because of memory errors in high
dimensions) but that the estimation could continue for others.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>message – explanation of the error</p>
</dd>
</dl>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="idtxl.idtxl_exceptions.BROJA_2PID_Exception">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_exceptions.</span></span><span class="sig-name descname"><span class="pre">BROJA_2PID_Exception</span></span><a class="reference internal" href="_modules/idtxl/idtxl_exceptions.html#BROJA_2PID_Exception"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_exceptions.BROJA_2PID_Exception" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="idtxl.idtxl_exceptions.JidtOutOfMemoryError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_exceptions.</span></span><span class="sig-name descname"><span class="pre">JidtOutOfMemoryError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_exceptions.html#JidtOutOfMemoryError"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_exceptions.JidtOutOfMemoryError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.idtxl_exceptions.AlgorithmExhaustedError" title="idtxl.idtxl_exceptions.AlgorithmExhaustedError"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.idtxl_exceptions.AlgorithmExhaustedError</span></code></a></p>
<dl class="simple">
<dt>Exception raised to signal a Java OutOfMemoryException.</dt><dd><p>It is a child class of AlgorithmExhaustedError.</p>
</dd>
<dt>Attributes:</dt><dd><p>message – explanation of the error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_exceptions.package_missing">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_exceptions.</span></span><span class="sig-name descname"><span class="pre">package_missing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">err</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_exceptions.html#package_missing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_exceptions.package_missing" title="Permalink to this definition">¶</a></dt>
<dd><p>Report a missing optional package upon import.</p>
</dd></dl>

</section>
<section id="module-idtxl.idtxl_io">
<span id="idtxl-idtxl-io-module"></span><h2>idtxl.idtxl_io module<a class="headerlink" href="#module-idtxl.idtxl_io" title="Permalink to this headline">¶</a></h2>
<p>Provide I/O functionality.</p>
<p>Provide functions to load and save IDTxl data, provide import functions (e.g.,
mat-files, FieldTrip) and export functions (e.g., networkx, BrainNet Viewer).</p>
<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_io.export_brain_net_viewer">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></span><span class="sig-name descname"><span class="pre">export_brain_net_viewer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adjacency_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mni_coord</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#export_brain_net_viewer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.export_brain_net_viewer" title="Permalink to this definition">¶</a></dt>
<dd><p>Export network to BrainNet Viewer.</p>
<p>Export networks to BrainNet Viewer (project home page:
<a class="reference external" href="http://www.nitrc.org/projects/bnv/">http://www.nitrc.org/projects/bnv/</a>). BrainNet Viewer is a MATLAB
toolbox offering brain network visualisation (e.g., ‘glass’ brains).
The function creates text files [file_name].node and [file_name].edge,
containing information on node location (in MNI coordinates), directed
edges, node color and size.</p>
<p>References:</p>
<ul class="simple">
<li><p>Xia, M., Wang, J., &amp; He, Y. (2013). BrainNet Viewer: A Network
Visualization Tool for Human Brain Connectomics. PLoS ONE 8(7):e68910.
<a class="reference external" href="https://doi.org/10.1371/journal.pone.0068910">https://doi.org/10.1371/journal.pone.0068910</a></p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>adjacency_matrix<span class="classifier">AdjacencyMatrix instance</span></dt><dd><p>adjacency matrix to be exported, returned by get_adjacency_matrix()
method of Results() class</p>
</dd>
<dt>mni_coord<span class="classifier">numpy array</span></dt><dd><p>MNI coordinates (x,y,z) of the sources, array with size [n 3],
where n is the number of nodes</p>
</dd>
<dt>file_name<span class="classifier">str</span></dt><dd><p>file name for output files including the file path</p>
</dd>
<dt>labels<span class="classifier">array type of str [optional]</span></dt><dd><p>list of node labels of length n, description or label for each
node. Note that labels can’t contain spaces (causes BrainNet to
crash), the function will remove any spaces from labels
(default=no labels)</p>
</dd>
<dt>node_color<span class="classifier">array type of colors [optional]</span></dt><dd><p>BrainNet gives you the option to color nodes according to the
values in this vector (length n), see BrainNet Manual</p>
</dd>
<dt>node_size<span class="classifier">array type of int [optional]</span></dt><dd><p>BrainNet gives you the option to size nodes according to the
values in this array (length n), see BrainNet Manual</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_io.export_networkx_graph">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></span><span class="sig-name descname"><span class="pre">export_networkx_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adjacency_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#export_networkx_graph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.export_networkx_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Export networkx graph object for an inferred network.</p>
<p>Export a weighted, directed graph object from the network of inferred
(multivariate) interactions (e.g., multivariate TE), using the networkx
class for directed graphs (DiGraph). Multiple options for the weight are
available (see documentation of method get_adjacency_matrix for details).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>adjacency_matrix<span class="classifier">AdjacencyMatrix instances</span></dt><dd><p>adjacency matrix to be exported, returned by get_adjacency_matrix()
method of Results() class</p>
</dd>
<dt>weights<span class="classifier">str</span></dt><dd><p>weights for the adjacency matrix (see documentation of method
get_adjacency_matrix for details)</p>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>return FDR-corrected results (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns: DiGraph instance</dt><dd><p>directed graph of networkx package’s DiGraph() class</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_io.export_networkx_source_graph">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></span><span class="sig-name descname"><span class="pre">export_networkx_source_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign_sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#export_networkx_source_graph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.export_networkx_source_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Export graph object of source variables for a single target.</p>
<p>Export graph object from the network of (multivariate) interactions (e.g.,
multivariate TE) between single source variables and a target process using
the networkx class for directed graphs (DiGraph). The graph shows the
information transfer between individual source variables and the target.
Each node is a tuple with the following format:
(process index, sample index).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>results<span class="classifier">Results() instance</span></dt><dd><p>network analysis results</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>target index</p>
</dd>
<dt>sign_sources<span class="classifier">bool [optional]</span></dt><dd><p>add sources with significant information contribution only
(default=True)</p>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>return FDR-corrected results (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>DiGraph instance</dt><dd><p>directed graph of networkx package’s DiGraph() class</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_io.import_fieldtrip">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></span><span class="sig-name descname"><span class="pre">import_fieldtrip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ft_struct_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_version</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#import_fieldtrip"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.import_fieldtrip" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert FieldTrip-style MATLAB-file into an IDTxl Data object.</p>
<p>Import a MATLAB structure with fields  “trial” (data), “label” (channel
labels), “time” (time stamps for data samples), and “fsample” (sampling
rate). This structure is the standard file format in the MATLAB toolbox
FieldTrip and commonly use to represent neurophysiological data (see also
<a class="reference external" href="http://www.fieldtriptoolbox.org/reference/ft_datatype_raw">http://www.fieldtriptoolbox.org/reference/ft_datatype_raw</a>). The data is
returned as a IDTxl Data() object.</p>
<p>The structure is assumed to be saved as a matlab hdf5 file (“-v7.3’ or
higher, .mat) with a SINGLE FieldTrip data structure inside.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>file_name<span class="classifier">string</span></dt><dd><p>full (matlab) file_name on disk</p>
</dd>
<dt>ft_struct_name<span class="classifier">string</span></dt><dd><p>variable name of the MATLAB structure that is in FieldTrip format
(autodetect will hopefully be possible later …)</p>
</dd>
<dt>file_version<span class="classifier">string</span></dt><dd><p>version of the file, e.g. ‘v7.3’ for MATLAB’s 7.3 format</p>
</dd>
<dt>normalise<span class="classifier">bool [optional]</span></dt><dd><p>normalise data after import (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Data() instance</dt><dd><p>instance of IDTxl Data object, containing data from the ‘trial’
field</p>
</dd>
<dt>list of strings</dt><dd><p>list of channel labels, corresponding to the ‘label’ field</p>
</dd>
<dt>numpy array</dt><dd><p>time stamps for samples, corresponding to one entry in the ‘time’
field</p>
</dd>
<dt>int</dt><dd><p>sampling rate, corresponding to the ‘fsample’ field</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_io.import_matarray">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></span><span class="sig-name descname"><span class="pre">import_matarray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_version</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#import_matarray"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.import_matarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Read Matlab hdf5 file into IDTxl.</p>
<p>reads a matlab hdf5 file (“-v7.3’ or higher, .mat) or non-hdf5 files with a
SINGLE array inside and returns an IDTxl Data() object.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>The import function squeezes the loaded mat-file, i.e., any singleton
dimension will be removed. Hence do not enter singleton dimension into
the ‘dim_order’, e.g., don’t pass dim_order=’ps’ but dim_order=’s’ if
you want to load a 1D-array where entries represent samples recorded
from a single channel.</p>
</dd>
<dt>Args:</dt><dd><dl class="simple">
<dt>file_name<span class="classifier">string</span></dt><dd><p>full (matlab) file_name on disk</p>
</dd>
<dt>array_name<span class="classifier">string</span></dt><dd><p>variable name of the MATLAB structure to be read</p>
</dd>
<dt>file_version<span class="classifier">string</span></dt><dd><p>version of the file, e.g. ‘v7.3’ for MATLAB’s 7.3 format, currently
versions ‘v4’, ‘v6’, ‘v7’, and ‘v7’ are supported</p>
</dd>
<dt>dim_order<span class="classifier">string</span></dt><dd><p>order of dimensions, accepts any combination of the characters
‘p’, ‘s’, and ‘r’ for processes, samples, and replications; must
have the same length as the data dimensionality, e.g., ‘ps’ for a
two-dimensional array of data from several processes over time</p>
</dd>
<dt>normalise<span class="classifier">bool [optional]</span></dt><dd><p>normalise data after import (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Data() instance</dt><dd><p>instance of IDTxl Data object, containing data from the ‘trial’
field</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_io.load_json">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></span><span class="sig-name descname"><span class="pre">load_json</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#load_json"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.load_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Load dictionary saved as JSON file from disk.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>file_path<span class="classifier">str</span></dt><dd><p>path to file (including extension)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>dict</p>
</dd>
</dl>
<p>Note: JSON does not recognize numpy data structures and types. Numpy arrays
and data types (float, int) are thus converted to Python types and lists.
The loaded dictionary may thus contain different data types than the saved
one.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_io.load_pickle">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></span><span class="sig-name descname"><span class="pre">load_pickle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#load_pickle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.load_pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Load objects that have been saved using Python’s pickle module.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_io.save_json">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></span><span class="sig-name descname"><span class="pre">save_json</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#save_json"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.save_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Save dictionary to disk as JSON file.</p>
<p>Writes dictionary to disk at the specified file path.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>d<span class="classifier">dict</span></dt><dd><p>dictionary to be written to disk</p>
</dd>
<dt>file_path<span class="classifier">str</span></dt><dd><p>path to file (including extension)</p>
</dd>
</dl>
</dd>
</dl>
<p>Note: JSON does not recognize numpy data types, those are converted to
basic Python data types first.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_io.save_pickle">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></span><span class="sig-name descname"><span class="pre">save_pickle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#save_pickle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.save_pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Save objects using Python’s pickle module.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>pickle.HIGHEST_PROTOCOL is a binary format, which may be inconvenient,
but is good for performance. Protocol 0 is a text format.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-idtxl.idtxl_utils">
<span id="idtxl-idtxl-utils-module"></span><h2>idtxl.idtxl_utils module<a class="headerlink" href="#module-idtxl.idtxl_utils" title="Permalink to this headline">¶</a></h2>
<p>Provide IDTxl utility functions.</p>
<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_utils.argsort_descending">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></span><span class="sig-name descname"><span class="pre">argsort_descending</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#argsort_descending"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.argsort_descending" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort array in descending order and return sortind indices.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_utils.autocorrelation">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></span><span class="sig-name descname"><span class="pre">autocorrelation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#autocorrelation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.autocorrelation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate autocorrelation of a vector.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_utils.calculate_mi">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></span><span class="sig-name descname"><span class="pre">calculate_mi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">corr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#calculate_mi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.calculate_mi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate mutual information from correlation coefficient.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_utils.combine_discrete_dimensions">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></span><span class="sig-name descname"><span class="pre">combine_discrete_dimensions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numBins</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#combine_discrete_dimensions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.combine_discrete_dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine multi-dimensional discrete variable into a single dimension.</p>
<p>Combine all dimensions for a discrete variable down into a single
dimensional value for each sample. This is done basically by multiplying
each dimension by a different power of the base (numBins).</p>
<p>Adapted from infodynamics.utils.MatrixUtils.computeCombinedValues() from
JIDT by J.Lizier.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>a<span class="classifier">numpy array</span></dt><dd><p>data to be combined across all variable dimensions. Dimensions are
realisations (samples) x variable dimension</p>
</dd>
<dt>numBins<span class="classifier">int</span></dt><dd><p>number of discrete levels or bins for each variable dimension</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>a univariate array – one entry now for each sample,
with all dimensions of the data now combined for that sample</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_utils.conflicting_entries">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></span><span class="sig-name descname"><span class="pre">conflicting_entries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dict_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dict_2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#conflicting_entries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.conflicting_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>Test two dictionaries for unequal entries.</p>
<p>Note that only keys that are present in both dicts are compared. If one
dictionary contains an entry not present in the other dictionary, the
test passes.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_utils.discretise">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></span><span class="sig-name descname"><span class="pre">discretise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numBins</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#discretise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.discretise" title="Permalink to this definition">¶</a></dt>
<dd><p>Discretise continuous data.</p>
<p>Discretise continuous data into discrete values (with 0 as lowest) by
evenly partitioning the range of the data, one dimension at a time.
Adapted from infodynamics.utils.MatrixUtils.discretise() from JIDT by
J. Lizier.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>a<span class="classifier">numpy array</span></dt><dd><p>data to be discretised. Dimensions are
realisations x variable dimension</p>
</dd>
<dt>numBins<span class="classifier">int</span></dt><dd><p>number of discrete levels or bins to partition the data into</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>discretised data</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_utils.discretise_max_ent">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></span><span class="sig-name descname"><span class="pre">discretise_max_ent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numBins</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#discretise_max_ent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.discretise_max_ent" title="Permalink to this definition">¶</a></dt>
<dd><p>Discretise continuous data using maximum entropy partitioning.</p>
<p>Discretise continuous data into discrete values (with 0 as lowest) by
making a maximum entropy partitioning, one dimension at a time. Adapted
from infodynamics.utils.MatrixUtils.discretiseMaxEntropy() from JIDT by
J. Lizier.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>a<span class="classifier">numpy array</span></dt><dd><p>data to be discretised. Dimensions are
realisations x variable dimension</p>
</dd>
<dt>numBins<span class="classifier">int</span></dt><dd><p>number of discrete levels or bins to partition the data into</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>discretised data</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_utils.equal_dicts">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></span><span class="sig-name descname"><span class="pre">equal_dicts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dict_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dict_2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#equal_dicts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.equal_dicts" title="Permalink to this definition">¶</a></dt>
<dd><p>Test two dictionaries for equality.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_utils.print_dict">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></span><span class="sig-name descname"><span class="pre">print_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#print_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.print_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Python’s pretty printer to print dictionaries to the console.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_utils.remove_column">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></span><span class="sig-name descname"><span class="pre">remove_column</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#remove_column"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.remove_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a column from a numpy array.</p>
<p>This is faster than logical indexing (‘25 times faster’), because it does
not make copies, see
<a class="reference external" href="http://scipy.github.io/old-wiki/pages/PerformanceTips">http://scipy.github.io/old-wiki/pages/PerformanceTips</a></p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>a<span class="classifier">numpy array</span></dt><dd><p>2-dimensional numpy array</p>
</dd>
<dt>i<span class="classifier">int</span></dt><dd><p>column index to be removed</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_utils.remove_row">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></span><span class="sig-name descname"><span class="pre">remove_row</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#remove_row"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.remove_row" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a row from a numpy array.</p>
<p>This is faster than logical indexing (‘25 times faster’), because it does
not make copies, see
<a class="reference external" href="http://scipy.github.io/old-wiki/pages/PerformanceTips">http://scipy.github.io/old-wiki/pages/PerformanceTips</a></p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>a<span class="classifier">numpy array</span></dt><dd><p>2-dimensional numpy array</p>
</dd>
<dt>i<span class="classifier">int</span></dt><dd><p>row index to be removed</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_utils.separate_arrays">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></span><span class="sig-name descname"><span class="pre">separate_arrays</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx_all</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_single</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#separate_arrays"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.separate_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Separate a single column from all other columns in a 2D-array.</p>
<p>Return the separated single column and the remaining columns of a 2D-
array.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>idx_all<span class="classifier">list&lt;Object&gt;</span></dt><dd><p>list of variables indicating the full set</p>
</dd>
<dt>idx_single<span class="classifier">&lt;Object&gt;</span></dt><dd><p>single variable indicating the column to be separated, variable
must be contained in idx_all</p>
</dd>
<dt>a<span class="classifier">numpy array</span></dt><dd><p>2D-array with the same length along axis 1 as idx_all
(.shape[1] == len(idx_all))</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>remaining columns in full array</p>
</dd>
<dt>numpy array</dt><dd><p>column at single index</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_utils.sort_descending">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></span><span class="sig-name descname"><span class="pre">sort_descending</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#sort_descending"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.sort_descending" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort array in descending order.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_utils.standardise">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></span><span class="sig-name descname"><span class="pre">standardise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#standardise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.standardise" title="Permalink to this definition">¶</a></dt>
<dd><p>Z-standardise a numpy array along a given dimension.</p>
<p>Standardise array along the axis defined in dimension using the denominator
(N - df) for the calculation of the standard deviation.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>a<span class="classifier">numpy array</span></dt><dd><p>data to be standardised</p>
</dd>
<dt>dimension<span class="classifier">int [optional]</span></dt><dd><p>dimension along which array should be standardised</p>
</dd>
<dt>df<span class="classifier">int [optional]</span></dt><dd><p>degrees of freedom for the denominator of the standard derivation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>standardised data</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.idtxl_utils.swap_chars">
<span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></span><span class="sig-name descname"><span class="pre">swap_chars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#swap_chars"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.swap_chars" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap to characters in a string.</p>
<dl>
<dt>Example:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">swap_chars</span><span class="p">(</span><span class="s1">&#39;heLlotHere&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="go">&#39;heHlotLere&#39;</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.idtxl_utils.timeout">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></span><span class="sig-name descname"><span class="pre">timeout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timeout_duration</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exception_message</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Timeout'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#timeout"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Context manager for a timeout using threading module.
args:</p>
<blockquote>
<div><p>timeout_duration: float, number of seconds to wait before timeout is triggered
exception_message: string, message to put in the exception</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.idtxl_utils.timeout.timeout_handler">
<span class="sig-name descname"><span class="pre">timeout_handler</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#timeout.timeout_handler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.timeout.timeout_handler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.network_analysis">
<span id="idtxl-network-analysis-module"></span><h2>idtxl.network_analysis module<a class="headerlink" href="#module-idtxl.network_analysis" title="Permalink to this headline">¶</a></h2>
<p>Parent class for network inference and network comparison.</p>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.network_analysis.NetworkAnalysis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.network_analysis.</span></span><span class="sig-name descname"><span class="pre">NetworkAnalysis</span></span><a class="reference internal" href="_modules/idtxl/network_analysis.html#NetworkAnalysis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_analysis.NetworkAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Provide an analysis setup for network inference or comparison.</p>
<p>The class provides routines to check user input and set defaults.</p>
<dl class="py property">
<dt class="sig sig-object py" id="idtxl.network_analysis.NetworkAnalysis.current_value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">current_value</span></span><a class="headerlink" href="#idtxl.network_analysis.NetworkAnalysis.current_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Get index of the current_value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.network_analysis.NetworkAnalysis.resume_checkpoint">
<span class="sig-name descname"><span class="pre">resume_checkpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/network_analysis.html#NetworkAnalysis.resume_checkpoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_analysis.NetworkAnalysis.resume_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume analysis from a checkpoint saved to disk.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>file_path<span class="classifier">str</span></dt><dd><p>path to checkpoint file (excluding extension: <a href="#id1"><span class="problematic" id="id2">*</span></a>.ckp)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="idtxl.network_analysis.NetworkAnalysis.selected_vars_full">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">selected_vars_full</span></span><a class="headerlink" href="#idtxl.network_analysis.NetworkAnalysis.selected_vars_full" title="Permalink to this definition">¶</a></dt>
<dd><p>List of indices of the full conditional set.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="idtxl.network_analysis.NetworkAnalysis.selected_vars_sources">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">selected_vars_sources</span></span><a class="headerlink" href="#idtxl.network_analysis.NetworkAnalysis.selected_vars_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>List of indices of source samples in the conditional set.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="idtxl.network_analysis.NetworkAnalysis.selected_vars_target">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">selected_vars_target</span></span><a class="headerlink" href="#idtxl.network_analysis.NetworkAnalysis.selected_vars_target" title="Permalink to this definition">¶</a></dt>
<dd><p>List of indices of target samples in the conditional set.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.network_inference">
<span id="idtxl-network-inference-module"></span><h2>idtxl.network_inference module<a class="headerlink" href="#module-idtxl.network_inference" title="Permalink to this headline">¶</a></h2>
<p>Parent class for all network inference.</p>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.network_inference.NetworkInference">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.network_inference.</span></span><span class="sig-name descname"><span class="pre">NetworkInference</span></span><a class="reference internal" href="_modules/idtxl/network_inference.html#NetworkInference"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_inference.NetworkInference" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_analysis.NetworkAnalysis" title="idtxl.network_analysis.NetworkAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_analysis.NetworkAnalysis</span></code></a></p>
<p>Parent class for network inference algorithms.</p>
<p>Hold variables that are relevant for network inference using for example
bivariate and multivariate transfer entropy.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>settings for estimation of information theoretic measures and
statistical testing, see child classes for documentation</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>target process of analysis</p>
</dd>
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current value</p>
</dd>
<dt>selected_vars_full<span class="classifier">list of tuples</span></dt><dd><p>indices of the full set of random variables to be conditioned on</p>
</dd>
<dt>selected_vars_target<span class="classifier">list of tuples</span></dt><dd><p>indices of the set of conditionals coming from the target process</p>
</dd>
<dt>selected_vars_sources<span class="classifier">list of tuples</span></dt><dd><p>indices of the set of conditionals coming from source processes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.network_inference.NetworkInferenceBivariate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.network_inference.</span></span><span class="sig-name descname"><span class="pre">NetworkInferenceBivariate</span></span><a class="reference internal" href="_modules/idtxl/network_inference.html#NetworkInferenceBivariate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_inference.NetworkInferenceBivariate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInference" title="idtxl.network_inference.NetworkInference"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInference</span></code></a></p>
<p>Parent class for bivariate network inference algorithms.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.network_inference.NetworkInferenceMI">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.network_inference.</span></span><span class="sig-name descname"><span class="pre">NetworkInferenceMI</span></span><a class="reference internal" href="_modules/idtxl/network_inference.html#NetworkInferenceMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_inference.NetworkInferenceMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInference" title="idtxl.network_inference.NetworkInference"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInference</span></code></a></p>
<p>Parent class for mutual information network inference algorithms.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.network_inference.NetworkInferenceMultivariate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.network_inference.</span></span><span class="sig-name descname"><span class="pre">NetworkInferenceMultivariate</span></span><a class="reference internal" href="_modules/idtxl/network_inference.html#NetworkInferenceMultivariate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_inference.NetworkInferenceMultivariate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInference" title="idtxl.network_inference.NetworkInference"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInference</span></code></a></p>
<p>Parent class for multivariate network inference algorithms.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.network_inference.NetworkInferenceTE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.network_inference.</span></span><span class="sig-name descname"><span class="pre">NetworkInferenceTE</span></span><a class="reference internal" href="_modules/idtxl/network_inference.html#NetworkInferenceTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_inference.NetworkInferenceTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInference" title="idtxl.network_inference.NetworkInference"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInference</span></code></a></p>
<p>Parent class for transfer entropy network inference algorithms.</p>
</dd></dl>

</section>
<section id="module-idtxl.single_process_analysis">
<span id="idtxl-single-process-analysis-module"></span><h2>idtxl.single_process_analysis module<a class="headerlink" href="#module-idtxl.single_process_analysis" title="Permalink to this headline">¶</a></h2>
<p>Parent class for analysis of single processes in the network.</p>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.single_process_analysis.SingleProcessAnalysis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.single_process_analysis.</span></span><span class="sig-name descname"><span class="pre">SingleProcessAnalysis</span></span><a class="reference internal" href="_modules/idtxl/single_process_analysis.html#SingleProcessAnalysis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.single_process_analysis.SingleProcessAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_analysis.NetworkAnalysis" title="idtxl.network_analysis.NetworkAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_analysis.NetworkAnalysis</span></code></a></p>
</dd></dl>

</section>
<section id="module-idtxl.network_comparison">
<span id="idtxl-network-comparison-module"></span><h2>idtxl.network_comparison module<a class="headerlink" href="#module-idtxl.network_comparison" title="Permalink to this headline">¶</a></h2>
<p>Perform inference statistics on groups of data.</p>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.network_comparison.NetworkComparison">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.network_comparison.</span></span><span class="sig-name descname"><span class="pre">NetworkComparison</span></span><a class="reference internal" href="_modules/idtxl/network_comparison.html#NetworkComparison"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_comparison.NetworkComparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_analysis.NetworkAnalysis" title="idtxl.network_analysis.NetworkAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_analysis.NetworkAnalysis</span></code></a></p>
<p>Set up network comparison between two experimental conditions.</p>
<p>The class provides methods for the comparison of networks inferred from
data recorded under two experimental conditions A and B. Four statistical
tests are implemented:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 17%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>units of observation/
comparison type</p></th>
<th class="head"><p>stats_type</p></th>
<th class="head"><p>example</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td rowspan="2"><p>replications/
<strong>within</strong> a subject</p></td>
<td><p>dependent</p></td>
<td><p>base line (A) vs. task (B)</p></td>
</tr>
<tr class="row-odd"><td><p>independent</p></td>
<td><p>detect house (A) vs. face (B)</p></td>
</tr>
<tr class="row-even"><td rowspan="2"><p>sets of data/
<strong>between</strong> subjects</p></td>
<td><p>dependent</p></td>
<td><p>patients (A) vs. matched controls (B)</p></td>
</tr>
<tr class="row-odd"><td><p>independent</p></td>
<td><p>male (A) vs. female (B) participants</p></td>
</tr>
</tbody>
</table>
<p>Depending on the units of observations, one of two statistics methods can
be used: compare_within() and compare_between(). The stats_type is passed
as an analysis setting, see the documentation of the two methods for
details.</p>
<p>Note that for network inference methods that use an embedding, i.e., a
collection of variables in the source, the joint information in all
variables about the target is used as a test statistic.</p>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.network_comparison.NetworkComparison.calculate_link_te">
<span class="sig-name descname"><span class="pre">calculate_link_te</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/network_comparison.html#NetworkComparison.calculate_link_te"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_comparison.NetworkComparison.calculate_link_te" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the information transfer for whole links into a target.</p>
<p>Calculate the information transfer for whole links as the joint
information transfer from all variables selected for a single source
process into the target. The information transfer is calculated
conditional on the target’s past and, for multivariate TE, conditional
on selected variables from further sources in the network.</p>
<p>If sources is set to ‘all’, a list of information transfer values is
returned. If sources is set to a single source index, the information
transfer from this source to the target is returned.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sources<span class="classifier">list of ints | ‘all’ [optional]</span></dt><dd><p>return estimates for links from selected or all sources into
the target (default=’all’)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>information transfer estimate for each link</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.network_comparison.NetworkComparison.compare_between">
<span class="sig-name descname"><span class="pre">compare_between</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">network_set_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">network_set_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_set_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_set_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/network_comparison.html#NetworkComparison.compare_between"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_comparison.NetworkComparison.compare_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare networks inferred under two conditions between subjects.</p>
<p>Compare two sets of networks inferred from two sets of data recorded
under different experimental conditions within multiple subjects, i.e.,
data have been recorded from subjects assigned to one of two
experimental conditions (units of observations are subjects).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of compare_within() for details</p>
</dd>
<dt>network_set_a<span class="classifier">numpy array of dicts</span></dt><dd><p>results from network inference for multiple subjects observed
under condition a</p>
</dd>
<dt>network_set_b<span class="classifier">numpy array of dicts</span></dt><dd><p>results from network inference for multiple subjects observed
under condition b</p>
</dd>
<dt>data_a<span class="classifier">numpy array of Data objects</span></dt><dd><p>set of data from which network_set_a was inferred</p>
</dd>
<dt>data_b<span class="classifier">numpy array of Data objects</span></dt><dd><p>set of data from which network_set_b was inferred</p>
</dd>
</dl>
</dd>
<dt>Returns</dt><dd><dl class="simple">
<dt>ResultsNetworkComparison object</dt><dd><p>results of network inference, see documentation of
ResultsNetworkComparison()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.network_comparison.NetworkComparison.compare_links_within">
<span class="sig-name descname"><span class="pre">compare_links_within</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">link_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">link_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">network</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/network_comparison.html#NetworkComparison.compare_links_within"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_comparison.NetworkComparison.compare_links_within" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two links within the same network.</p>
<p>Compare two links within the same network. Check if information
transfer is different from information transfer in a second link.</p>
<p>Note that both links have to be part of the inferred network, i.e.,
there has to be significant effective connectivity for both links.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing</p>
<ul class="simple">
<li><p>stats_type : str - ‘dependent’ or ‘independent’ for
dependent or independent units of observation</p></li>
<li><p>cmi_estimator : str - estimator to be used for CMI
calculation (for estimator settings see the documentation in
the estimators_* modules)</p></li>
<li><p>tail_comp : str [optional] - test tail, ‘one’ for one-sided
test A &gt; B, ‘two’ for two-sided test (default=’two’)</p></li>
<li><p>n_perm_comp : int [optional] - number of permutations
(default=500)</p></li>
<li><p>alpha_comp : float - critical alpha level for statistical
significance (default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - if True, create
surrogates by shuffling data over time. See
Data.permute_samples() for settings for further options for
surrogate creation</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
</ul>
</dd>
<dt>link_a<span class="classifier">array type</span></dt><dd><p>first link, array type with two entries [source target]</p>
</dd>
<dt>link_b<span class="classifier">array type</span></dt><dd><p>second link, array type with two entries [source target]</p>
</dd>
<dt>network<span class="classifier">dict</span></dt><dd><p>results from network inference</p>
</dd>
<dt>data<span class="classifier">Data object</span></dt><dd><p>data from which network was inferred</p>
</dd>
</dl>
</dd>
<dt>Returns</dt><dd><dl class="simple">
<dt>ResultsNetworkComparison object</dt><dd><p>results of network inference, see documentation of
ResultsNetworkComparison()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.network_comparison.NetworkComparison.compare_within">
<span class="sig-name descname"><span class="pre">compare_within</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">network_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">network_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/network_comparison.html#NetworkComparison.compare_within"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_comparison.NetworkComparison.compare_within" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare networks inferred under two conditions within one subject.</p>
<p>Compare two networks inferred from data recorded under two different
experimental conditions within one subject (units of observations are
replications of one experimental condition within one subject).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing</p>
<ul class="simple">
<li><p>stats_type : str - ‘dependent’ or ‘independent’ for
dependent or independent units of observation</p></li>
<li><p>cmi_estimator : str - estimator to be used for CMI
calculation (for estimator settings see the documentation in
the estimators_* modules)</p></li>
<li><p>tail_comp : str [optional] - test tail, ‘one’ for one-sided
test A &gt; B, ‘two’ for two-sided test (default=’two’)</p></li>
<li><p>n_perm_comp : int [optional] - number of permutations
(default=500)</p></li>
<li><p>alpha_comp : float - critical alpha level for statistical
significance (default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - if True, create
surrogates by shuffling data over time. See
Data.permute_samples() for settings for further options for
surrogate creation</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
</ul>
</dd>
<dt>network_a<span class="classifier">dict</span></dt><dd><p>results from network inference, condition a</p>
</dd>
<dt>network_b<span class="classifier">dict</span></dt><dd><p>results from network inference, condition b</p>
</dd>
<dt>data_a<span class="classifier">Data object</span></dt><dd><p>data from which network_a was inferred</p>
</dd>
<dt>data_b<span class="classifier">Data object</span></dt><dd><p>data from which network_b was inferred</p>
</dd>
</dl>
</dd>
<dt>Returns</dt><dd><dl class="simple">
<dt>ResultsNetworkComparison object</dt><dd><p>results of network inference, see documentation of
ResultsNetworkComparison()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.results">
<span id="idtxl-results-module"></span><h2>idtxl.results module<a class="headerlink" href="#module-idtxl.results" title="Permalink to this headline">¶</a></h2>
<p>Provide results class for IDTxl network analysis.</p>
<dl class="py class">
<dt class="sig sig-object py" id="idtxl.results.AdjacencyMatrix">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.results.</span></span><span class="sig-name descname"><span class="pre">AdjacencyMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_type</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#AdjacencyMatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.AdjacencyMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Adjacency matrix representing inferred networks.</p>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.AdjacencyMatrix.add_edge">
<span class="sig-name descname"><span class="pre">add_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#AdjacencyMatrix.add_edge"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.AdjacencyMatrix.add_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Add weighted edge (i, j) to adjacency matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.AdjacencyMatrix.add_edge_list">
<span class="sig-name descname"><span class="pre">add_edge_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#AdjacencyMatrix.add_edge_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.AdjacencyMatrix.add_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Add multiple weighted edges (i, j) to adjacency matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.AdjacencyMatrix.get_edge_list">
<span class="sig-name descname"><span class="pre">get_edge_list</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#AdjacencyMatrix.get_edge_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.AdjacencyMatrix.get_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of weighted edges.</p>
<dl class="simple">
<dt>Returns</dt><dd><dl class="simple">
<dt>list of tuples</dt><dd><p>each entry represents one edge in the graph: (i, j, weight)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.AdjacencyMatrix.n_edges">
<span class="sig-name descname"><span class="pre">n_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#AdjacencyMatrix.n_edges"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.AdjacencyMatrix.n_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.AdjacencyMatrix.n_nodes">
<span class="sig-name descname"><span class="pre">n_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#AdjacencyMatrix.n_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.AdjacencyMatrix.n_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of nodes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.AdjacencyMatrix.print_matrix">
<span class="sig-name descname"><span class="pre">print_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#AdjacencyMatrix.print_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.AdjacencyMatrix.print_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Print weight and edge matrix.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.results.DotDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.results.</span></span><span class="sig-name descname"><span class="pre">DotDict</span></span><a class="reference internal" href="_modules/idtxl/results.html#DotDict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.DotDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
<p>Dictionary with dot-notation access to values.</p>
<p>Provides the same functionality as a regular dict, but also allows
accessing values using dot-notation.</p>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">idtxl.results</span> <span class="kn">import</span> <span class="n">DotDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">DotDict</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Out: 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Out: 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.results.Results">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.results.</span></span><span class="sig-name descname"><span class="pre">Results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_realisations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalised</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#Results"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.Results" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Parent class for results of network analysis algorithms.</p>
<p>Provide a container for results of network analysis algorithms, e.g.,
MultivariateTE or ActiveInformationStorage.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>settings<span class="classifier">dict</span></dt><dd><p>settings used for estimation of information theoretic measures and
statistical testing</p>
</dd>
<dt>data_properties<span class="classifier">dict</span></dt><dd><p>data properties, contains</p>
<blockquote>
<div><ul class="simple">
<li><p>n_nodes : int - total number of nodes in the network</p></li>
<li><p>n_realisations : int - number of samples available for
analysis given the settings (e.g., a high maximum lag used in
network inference, results in fewer data points available for
estimation)</p></li>
<li><p>normalised : bool - indicates if data were z-standardised
before the estimation</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.Results.combine_results">
<span class="sig-name descname"><span class="pre">combine_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">results</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#Results.combine_results"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.Results.combine_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine multiple (partial) results objects.</p>
<p>Combine a list of partial network analysis results into a single
results object (e.g., results from analysis parallelized over
processes). Raise an error if duplicate processes occur in partial
results, or if analysis settings are not equal.</p>
<p>Note that only conflicting settings cause an error (i.e., settings with
equal keys but different values). If additional settings are included
in partial results (i.e., settings with different keys) these settings
are added to the common settings dictionary.</p>
<p>Remove FDR-corrections from partial results before combining them. FDR-
correction performed on the basis of parts of the network is not valid
for the combined network.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>results<span class="classifier">list of Results objects</span></dt><dd><p>single process analysis results from .analyse_network or
.analyse_single_process methods, where each object contains
partial results for one or multiple processes</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>combined results object</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.results.ResultsMultivariatePID">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.results.</span></span><span class="sig-name descname"><span class="pre">ResultsMultivariatePID</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_realisations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalised</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsMultivariatePID"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsMultivariatePID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.results.ResultsNetworkAnalysis" title="idtxl.results.ResultsNetworkAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.results.ResultsNetworkAnalysis</span></code></a></p>
<p>Store results of Multivariate Partial Information Decomposition (PID)
analysis.</p>
<blockquote>
<div><p>Provide a container for results of Multivariate Partial Information
Decomposition (PID) algorithms.</p>
<p>Note that for convenience all dictionaries in this class can additionally
be accessed using dot-notation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_pid</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">source_1</span>
</pre></div>
</div>
<p>or</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_pid</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="p">[</span><span class="s1">&#39;source_1&#39;</span><span class="p">]</span><span class="o">.</span>
</pre></div>
</div>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>settings<span class="classifier">dict</span></dt><dd><p>settings used for estimation of information theoretic measures and
statistical testing</p>
</dd>
<dt>data_properties<span class="classifier">dict</span></dt><dd><p>data properties, contains</p>
<blockquote>
<div><ul class="simple">
<li><p>n_nodes : int - total number of nodes in the network</p></li>
<li><p>n_realisations : int - number of samples available for
analysis given the settings (e.g., a high maximum lag used in
network inference, results in fewer data points available for
estimation)</p></li>
<li><p>normalised : bool - indicates if data were z-standardised
before the estimation</p></li>
</ul>
</div></blockquote>
</dd>
<dt>targets_analysed<span class="classifier">list</span></dt><dd><p>list of analysed targets</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.ResultsMultivariatePID.get_single_target">
<span class="sig-name descname"><span class="pre">get_single_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsMultivariatePID.get_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsMultivariatePID.get_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Return results for a single target in the network.</p>
<p>Results for single targets include for each target</p>
<ul class="simple">
<li><p>source_i : tuple - source variable i</p></li>
<li><p>selected_vars_sources : list of tuples - source variables used in PID
estimation</p></li>
<li><p>avg : dict - avg pid {alpha -&gt; float} where alpha is a redundancy
lattice node</p></li>
<li><p>ptw : dict of dicts - ptw pid {rlz -&gt; {alpha -&gt; float} } where rlz is
a single realisation of the random variables and alpha is a redundancy
lattice node</p></li>
<li><p>current_value : tuple - current value used for analysis, described by
target and sample index in the data</p></li>
<li><p>[estimator-specific settings]</p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>target id</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>Results for single target. Note that for convenience
dictionary entries can either be accessed via keywords
(result[‘selected_vars_sources’]) or via dot-notation
(result.selected_vars_sources).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.results.ResultsNetworkAnalysis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.results.</span></span><span class="sig-name descname"><span class="pre">ResultsNetworkAnalysis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_realisations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalised</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkAnalysis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.results.Results" title="idtxl.results.Results"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.results.Results</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.ResultsNetworkAnalysis.get_single_target">
<span class="sig-name descname"><span class="pre">get_single_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkAnalysis.get_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkAnalysis.get_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Return results for a single target in the network.</p>
<p>Return results for individual processes, contains for each process</p>
<p>Results for single targets include for each target</p>
<ul class="simple">
<li><p>omnibus_te : float - TE-value for joint information transfer from all
sources into the target</p></li>
<li><p>omnibus_pval : float - p-value of omnibus information transfer into
the target</p></li>
<li><p>omnibus_sign : bool - significance of omnibus information transfer
wrt. to the alpha_omnibus specified in the settings</p></li>
<li><p>selected_vars_sources : list of tuples - source variables with
significant information about the current value</p></li>
<li><p>selected_vars_target : list of tuples - target variables with
significant information about the current value</p></li>
<li><p>selected_sources_pval : array of floats - p-value for each selected
variable</p></li>
<li><p>selected_sources_te : array of floats - TE-value for each selected
variable</p></li>
<li><p>sources_tested : list of int - list of sources tested for the current
target</p></li>
<li><p>current_value : tuple - current value used for analysis, described by
target and sample index in the data</p></li>
</ul>
<p>Setting fdr to True returns FDR-corrected results (Benjamini, 1995).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>target id</p>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>return FDR-corrected results, see documentation of network
inference algorithms and stats.network_fdr (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>Results for single target. Note that for convenience
dictionary entries can either be accessed via keywords
(result[‘selected_vars_sources’]) or via dot-notation
(result.selected_vars_sources).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.ResultsNetworkAnalysis.get_target_sources">
<span class="sig-name descname"><span class="pre">get_target_sources</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkAnalysis.get_target_sources"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkAnalysis.get_target_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of sources (parents) for given target.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>target index</p>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>if True, sources are returned for FDR-corrected results
(default=True)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="idtxl.results.ResultsNetworkAnalysis.targets_analysed">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">targets_analysed</span></span><a class="headerlink" href="#idtxl.results.ResultsNetworkAnalysis.targets_analysed" title="Permalink to this definition">¶</a></dt>
<dd><p>Get index of the current_value.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.results.ResultsNetworkComparison">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.results.</span></span><span class="sig-name descname"><span class="pre">ResultsNetworkComparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_realisations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalised</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkComparison"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkComparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.results.ResultsNetworkAnalysis" title="idtxl.results.ResultsNetworkAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.results.ResultsNetworkAnalysis</span></code></a></p>
<p>Store results of network comparison.</p>
<p>Provide a container for results of network comparison algorithms.</p>
<p>Note that for convenience all dictionaries in this class can additionally
be accessed using dot-notation: res_network.settings.cmi_estimator
or res_network.settings[‘cmi_estimator’].</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>settings<span class="classifier">dict</span></dt><dd><p>settings used for estimation of information theoretic measures and
statistical testing</p>
</dd>
<dt>data_properties<span class="classifier">dict</span></dt><dd><p>data properties, contains</p>
<blockquote>
<div><ul class="simple">
<li><p>n_nodes : int - total number of nodes in the network</p></li>
<li><p>n_realisations : int - number of samples available for
analysis given the settings (e.g., a high maximum lag used in
network inference, results in fewer data points available for
estimation)</p></li>
<li><p>normalised : bool - indicates if data were z-standardised
before the estimation</p></li>
</ul>
</div></blockquote>
</dd>
<dt>surrogate_distribution<span class="classifier">dict</span></dt><dd><p>for each target, surrogate distributions used for testing of each
link into the target</p>
</dd>
<dt>targets_analysed<span class="classifier">list</span></dt><dd><p>list of analysed targets</p>
</dd>
<dt>ab<span class="classifier">dict</span></dt><dd><p>for each target, list of comparison results for all links into the
target; True if link in condition A &gt; link in condition B</p>
</dd>
<dt>pval<span class="classifier">dict</span></dt><dd><p>for each target, list of p-values for all compared links</p>
</dd>
<dt>cmi_diff_abs<span class="classifier">dict</span></dt><dd><p>for each target, list of absolute difference in interaction measure
for all compared links</p>
</dd>
<dt>data_properties<span class="classifier">dict</span></dt><dd><p>information regarding the data used for analysis</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>settings used for comparison</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.ResultsNetworkComparison.get_adjacency_matrix">
<span class="sig-name descname"><span class="pre">get_adjacency_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'comparison'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkComparison.get_adjacency_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkComparison.get_adjacency_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return adjacency matrix.</p>
<p>Return adjacency matrix resulting from network inference.
Multiple options for the weights are available.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>weights<span class="classifier">str [optional]</span></dt><dd><p>can either be</p>
<ul class="simple">
<li><p>‘union’: all links in the union network, i.e., all
links that were tested for a difference</p></li>
</ul>
<p>or return information for links with a significant difference</p>
<ul class="simple">
<li><dl class="simple">
<dt>‘comparison’: True for links with a significant difference in</dt><dd><p>inferred effective connectivity (default)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘pvalue’: absolute differences in inferred effective</dt><dd><p>connectivity for significant links</p>
</dd>
</dl>
</li>
<li><p>‘diff_abs’: absolute difference</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>AdjacencyMatrix instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.ResultsNetworkComparison.get_single_target">
<span class="sig-name descname"><span class="pre">get_single_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkComparison.get_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkComparison.get_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Return results for a single target in the network.</p>
<p>Results for single targets include for each target</p>
<ul class="simple">
<li><p>sources : list of ints - list of sources inferred for the current
target (union of sources from both data sets entering the comparison)</p></li>
<li><p>selected_vars_sources : list of tuples - source variables with
significant information about the current value (union of both
conditions)</p></li>
<li><p>selected_vars_target : list of tuples - target variables with
significant information about the current value (union of both
conditions)</p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>target id</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>Results for single target. Note that for convenience
dictionary entries can either be accessed via keywords
(result[‘selected_vars_sources’]) or via dot-notation
(result.selected_vars_sources).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.ResultsNetworkComparison.get_target_sources">
<span class="sig-name descname"><span class="pre">get_target_sources</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkComparison.get_target_sources"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkComparison.get_target_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of sources (parents) for given target.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>target index</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.ResultsNetworkComparison.print_edge_list">
<span class="sig-name descname"><span class="pre">print_edge_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'comparison'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkComparison.print_edge_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkComparison.print_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Print results of network comparison to console.</p>
<p>Print results of network comparison to console. Output looks like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">diff_abs</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">diff_abs</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">diff_abs</span> <span class="o">=</span> <span class="mf">0.7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">diff_abs</span> <span class="o">=</span> <span class="mf">1.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">diff_abs</span> <span class="o">=</span> <span class="mf">0.4</span>
</pre></div>
</div>
<p>indicating differences in the network inference measure for a link
source -&gt; target.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>weights<span class="classifier">str [optional]</span></dt><dd><p>weights for the adjacency matrix (see documentation of method
get_adjacency_matrix for details)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.results.ResultsNetworkInference">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.results.</span></span><span class="sig-name descname"><span class="pre">ResultsNetworkInference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_realisations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalised</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkInference"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkInference" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.results.ResultsNetworkAnalysis" title="idtxl.results.ResultsNetworkAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.results.ResultsNetworkAnalysis</span></code></a></p>
<p>Store results of network inference.</p>
<p>Provide a container for results of network inference algorithms, e.g.,
MultivariateTE or Bivariate TE.</p>
<p>Note that for convenience all dictionaries in this class can additionally
be accessed using dot-notation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_network</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">cmi_estimator</span>
</pre></div>
</div>
<p>or</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_network</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;cmi_estimator&#39;</span><span class="p">]</span><span class="o">.</span>
</pre></div>
</div>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>settings<span class="classifier">dict</span></dt><dd><p>settings used for estimation of information theoretic measures and
statistical testing</p>
</dd>
<dt>data_properties<span class="classifier">dict</span></dt><dd><p>data properties, contains</p>
<blockquote>
<div><ul class="simple">
<li><p>n_nodes : int - total number of nodes in the network</p></li>
<li><p>n_realisations : int - number of samples available for
analysis given the settings (e.g., a high maximum lag used in
network inference, results in fewer data points available for
estimation)</p></li>
<li><p>normalised : bool - indicates if data were z-standardised
before estimation</p></li>
</ul>
</div></blockquote>
</dd>
<dt>targets_analysed<span class="classifier">list</span></dt><dd><p>list of analysed targets</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.ResultsNetworkInference.get_adjacency_matrix">
<span class="sig-name descname"><span class="pre">get_adjacency_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkInference.get_adjacency_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkInference.get_adjacency_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return adjacency matrix.</p>
<p>Return adjacency matrix resulting from network inference. The adjacency
matrix can either be generated from FDR-corrected results or
uncorrected results. Multiple options for the weight are available.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>weights<span class="classifier">str</span></dt><dd><p>can either be</p>
<ul class="simple">
<li><dl class="simple">
<dt>‘max_te_lag’: the weights represent the source -&gt; target</dt><dd><p>lag corresponding to the maximum tranfer entropy value
(see documentation for method get_target_delays for details)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘max_p_lag’: the weights represent the source -&gt; target</dt><dd><p>lag corresponding to the maximum p-value
(see documentation for method get_target_delays for details)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘vars_count’: the weights represent the number of</dt><dd><p>statistically-significant source -&gt; target lags</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘binary’: return unweighted adjacency matrix with binary</dt><dd><p>entries</p>
<ul>
<li><p>1 = significant information transfer;</p></li>
<li><p>0 = no significant information transfer.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>return FDR-corrected results (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>AdjacencyMatrix instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.ResultsNetworkInference.get_source_variables">
<span class="sig-name descname"><span class="pre">get_source_variables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkInference.get_source_variables"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkInference.get_source_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of inferred past source variables for all targets.</p>
<p>Return a list of dictionaries, where each dictionary holds the selected
past source variables for one analysed target. The list may be used as
and input to significant subgraph mining in the postprocessing module.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>return FDR-corrected results (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>list of dicts</dt><dd><p>selected past source variables for each target</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.ResultsNetworkInference.get_target_delays">
<span class="sig-name descname"><span class="pre">get_target_delays</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'max_te'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkInference.get_target_delays"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkInference.get_target_delays" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of information-transfer delays for a given target.</p>
<p>Return a list of information-transfer delays for a given target.
Information-transfer delays are determined by the lag of the variable
in a source past that has the highest information transfer into the
target process. There are two ways of identifying the variable with
maximum information transfer:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>use the variable with the highest absolute TE value (highest
information transfer),</p></li>
<li><p>use the variable with the smallest p-value (highest statistical
significance).</p></li>
</ol>
</div></blockquote>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>target index</p>
</dd>
<dt>criterion<span class="classifier">str [optional]</span></dt><dd><p>use maximum TE value (‘max_te’) or p-value (‘max_p’) to
determine the source-target delay (default=’max_te’)</p>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>return FDR-corrected results (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>information-transfer delays for each source</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.ResultsNetworkInference.print_edge_list">
<span class="sig-name descname"><span class="pre">print_edge_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkInference.print_edge_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkInference.print_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Print results of network inference to console.</p>
<p>Print edge list resulting from network inference to console.
Output may look like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_te_lag</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_te_lag</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">max_te_lag</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">max_te_lag</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">max_te_lag</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The edge list can either be generated from FDR-corrected results
or uncorrected results. Multiple options for the weight
are available (see documentation of method get_adjacency_matrix for
details).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>weights<span class="classifier">str</span></dt><dd><p>link weights (see documentation of method get_adjacency_matrix
for details)</p>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>return FDR-corrected results (default=True)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.results.ResultsPID">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.results.</span></span><span class="sig-name descname"><span class="pre">ResultsPID</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_realisations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalised</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsPID"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsPID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.results.ResultsNetworkAnalysis" title="idtxl.results.ResultsNetworkAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.results.ResultsNetworkAnalysis</span></code></a></p>
<p>Store results of Partial Information Decomposition (PID) analysis.</p>
<p>Provide a container for results of Partial Information Decomposition (PID)
algorithms.</p>
<p>Note that for convenience all dictionaries in this class can additionally
be accessed using dot-notation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_pid</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">source_1</span>
</pre></div>
</div>
<p>or</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_pid</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="p">[</span><span class="s1">&#39;source_1&#39;</span><span class="p">]</span><span class="o">.</span>
</pre></div>
</div>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>settings<span class="classifier">dict</span></dt><dd><p>settings used for estimation of information theoretic measures and
statistical testing</p>
</dd>
<dt>data_properties<span class="classifier">dict</span></dt><dd><p>data properties, contains</p>
<blockquote>
<div><ul class="simple">
<li><p>n_nodes : int - total number of nodes in the network</p></li>
<li><p>n_realisations : int - number of samples available for
analysis given the settings (e.g., a high maximum lag used in
network inference, results in fewer data points available for
estimation)</p></li>
<li><p>normalised : bool - indicates if data were z-standardised
before the estimation</p></li>
</ul>
</div></blockquote>
</dd>
<dt>targets_analysed<span class="classifier">list</span></dt><dd><p>list of analysed targets</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.ResultsPID.get_single_target">
<span class="sig-name descname"><span class="pre">get_single_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsPID.get_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsPID.get_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Return results for a single target in the network.</p>
<p>Results for single targets include for each target</p>
<ul class="simple">
<li><p>source_1 : tuple - source variable 1</p></li>
<li><p>source_2 : tuple - source variable 2</p></li>
<li><p>selected_vars_sources : list of tuples - source variables used in PID
estimation</p></li>
<li><p>s1_unq : float - unique information in source 1</p></li>
<li><p>s2_unq : float - unique information in source 2</p></li>
<li><p>syn_s1_s2 : float - synergistic information in sources 1 and 2</p></li>
<li><p>shd_s1_s2 : float - shared information in sources 1 and 2</p></li>
<li><p>current_value : tuple - current value used for analysis, described by
target and sample index in the data</p></li>
<li><p>[estimator-specific settings]</p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>target id</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>Results for single target. Note that for convenience
dictionary entries can either be accessed via keywords
(result[‘selected_vars_sources’]) or via dot-notation
(result.selected_vars_sources).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.results.ResultsSingleProcessAnalysis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.results.</span></span><span class="sig-name descname"><span class="pre">ResultsSingleProcessAnalysis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_realisations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalised</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsSingleProcessAnalysis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsSingleProcessAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.results.Results" title="idtxl.results.Results"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.results.Results</span></code></a></p>
<p>Store results of single process analysis.</p>
<p>Provide a container for the results of algorithms for the analysis of
individual processes (nodes) in a multivariate stochastic process,
e.g., estimation of active information storage.</p>
<p>Note that for convenience all dictionaries in this class can additionally
be accessed using dot-notation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_network</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">cmi_estimator</span>
</pre></div>
</div>
<p>or</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_network</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;cmi_estimator&#39;</span><span class="p">]</span><span class="o">.</span>
</pre></div>
</div>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>settings<span class="classifier">dict</span></dt><dd><p>settings used for estimation of information theoretic measures and
statistical testing</p>
</dd>
<dt>data_properties<span class="classifier">dict</span></dt><dd><p>data properties, contains</p>
<blockquote>
<div><ul class="simple">
<li><p>n_nodes : int - total number of nodes in the network</p></li>
<li><p>n_realisations : int - number of samples available for
analysis given the settings (e.g., a high maximum lag used in
network inference, results in fewer data points available for
estimation)</p></li>
<li><p>normalised : bool - indicates if data were z-standardised
before estimation</p></li>
</ul>
</div></blockquote>
</dd>
<dt>processes_analysed<span class="classifier">list</span></dt><dd><p>list of analysed processes</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.ResultsSingleProcessAnalysis.get_significant_processes">
<span class="sig-name descname"><span class="pre">get_significant_processes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsSingleProcessAnalysis.get_significant_processes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsSingleProcessAnalysis.get_significant_processes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return statistically-significant processes.</p>
<p>Indicates for each process whether AIS is statistically significant
(equivalent to the adjacency matrix returned for network inference)</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>return FDR-corrected results, see documentation of network
inference algorithms and stats.network_fdr (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>Statistical significance for each process</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.ResultsSingleProcessAnalysis.get_single_process">
<span class="sig-name descname"><span class="pre">get_single_process</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsSingleProcessAnalysis.get_single_process"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsSingleProcessAnalysis.get_single_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Return results for a single process in the network.</p>
<p>Return results for individual processes, contains for each process</p>
<blockquote>
<div><ul class="simple">
<li><p>ais : float - AIS-value for current process</p></li>
<li><p>ais_pval : float - p-value of AIS estimate</p></li>
<li><dl class="simple">
<dt>ais_sign<span class="classifier">bool - significance of AIS estimate wrt. to the</span></dt><dd><p>alpha_mi specified in the settings</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>selected_var<span class="classifier">list of tuples - variables with significant</span></dt><dd><p>information about the current value of the process that have
been added to the processes past state, a variable is
described by the index of the process in the data and its lag
in samples</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>current_value<span class="classifier">tuple - current value used for analysis,</span></dt><dd><p>described by target and sample index in the data</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Setting fdr to True returns FDR-corrected results (Benjamini, 1995).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>process<span class="classifier">int</span></dt><dd><p>process id</p>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>return FDR-corrected results, see documentation of network
inference algorithms and stats.network_fdr (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>results for single process. Note that for convenience
dictionary entries can either be accessed via keywords
(result[‘selected_vars’]) or via dot-notation
(result.selected_vars).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="idtxl.results.ResultsSingleProcessAnalysis.processes_analysed">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">processes_analysed</span></span><a class="headerlink" href="#idtxl.results.ResultsSingleProcessAnalysis.processes_analysed" title="Permalink to this definition">¶</a></dt>
<dd><p>Get index of the current_value.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="idtxl.results.ResultsSingleProcessRudelt">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">idtxl.results.</span></span><span class="sig-name descname"><span class="pre">ResultsSingleProcessRudelt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">processes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsSingleProcessRudelt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsSingleProcessRudelt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Store results of single process analysis.</p>
<p>Provides a container for the results Rudelt optimization algorithm. To
obtain results for individual processes, call the .get_single_process()
method (see docstring for details).</p>
<p>Note that for convenience all dictionaries in this class can additionally
be accessed using dot-notation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_network</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">estimation_method</span>
</pre></div>
</div>
<p>or</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_network</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;estimation_method&#39;</span><span class="p">]</span><span class="o">.</span>
</pre></div>
</div>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>settings used for estimation of information theoretic measures</p>
</dd>
<dt>data_properties<span class="classifier">dict</span></dt><dd><dl class="simple">
<dt>data properties, contains</dt><dd><ul class="simple">
<li><p>n_processes : int - total number of processes analysed</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>processes_analysed<span class="classifier">list</span></dt><dd><p>list of analysed processes</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="idtxl.results.ResultsSingleProcessRudelt.get_single_process">
<span class="sig-name descname"><span class="pre">get_single_process</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsSingleProcessRudelt.get_single_process"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsSingleProcessRudelt.get_single_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Return results for a single process.</p>
<p>Return results for individual processes, contains for each process</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>process<span class="classifier">int</span></dt><dd><p>process id</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl>
<dt>dict</dt><dd><p>results for single process. Note that for convenience
dictionary entries can either be accessed via keywords
(result[‘selected_vars’]) or via dot-notation
(result.selected_vars). Contains keys</p>
<dl class="simple">
<dt>Process<span class="classifier">int</span></dt><dd><p>Process that was optimized</p>
</dd>
<dt>estimation_method<span class="classifier">String</span></dt><dd><p>Estimation method that was used for optimization</p>
</dd>
<dt>T_D<span class="classifier">float</span></dt><dd><p>Estimated optimal value for the temporal depth TD</p>
</dd>
<dt>tau_R :</dt><dd><p>Information timescale tau_R, a characteristic timescale of history
dependence similar to an autocorrelation time.</p>
</dd>
<dt>R_tot<span class="classifier">float</span></dt><dd><p>Estimated value for the total history dependence Rtot,</p>
</dd>
<dt>AIS_tot<span class="classifier">float</span></dt><dd><p>Estimated value for the total active information storage</p>
</dd>
<dt>opt_number_of_bins_d<span class="classifier">int</span></dt><dd><p>Number of bins d for the embedding that yields (R̂tot ,T̂D)</p>
</dd>
<dt>opt_scaling_k<span class="classifier">int</span></dt><dd><p>Scaling exponent κ for the embedding that yields (R̂tot , T̂D)</p>
</dd>
<dt>opt_first_bin_size<span class="classifier">int</span></dt><dd><p>Size of the first bin τ1 for the embedding that yields (R̂tot , T̂D ),</p>
</dd>
<dt>history_dependence<span class="classifier">array with floating-point values</span></dt><dd><p>Estimated history dependence for each embedding</p>
</dd>
<dt>firing_rate<span class="classifier">float</span></dt><dd><p>Firing rate of the neuron/ spike train</p>
</dd>
<dt>recording_length<span class="classifier">float</span></dt><dd><p>Length of the recording (in seconds)</p>
</dd>
<dt>H_spiking<span class="classifier">float</span></dt><dd><p>Entropy of the spike times</p>
</dd>
</dl>
<p>if analyse_auto_MI was set to True additionally:
auto_MI : dict</p>
<blockquote>
<div><p>numpy array of MI values for each delay</p>
</div></blockquote>
<dl class="simple">
<dt>auto_MI_delays<span class="classifier">list of int</span></dt><dd><p>list of delays depending on the given auto_MI_bin_sizes and auto_MI_max_delay</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="idtxl.results.ResultsSingleProcessRudelt.processes_analysed">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">processes_analysed</span></span><a class="headerlink" href="#idtxl.results.ResultsSingleProcessRudelt.processes_analysed" title="Permalink to this definition">¶</a></dt>
<dd><p>Get index of the current_value.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-idtxl.stats">
<span id="idtxl-stats-module"></span><h2>idtxl.stats module<a class="headerlink" href="#module-idtxl.stats" title="Permalink to this headline">¶</a></h2>
<p>Provide statistics functions.</p>
<dl class="py function">
<dt class="sig sig-object py" id="idtxl.stats.ais_fdr">
<span class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></span><span class="sig-name descname"><span class="pre">ais_fdr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">results</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#ais_fdr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.ais_fdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform FDR-correction on results of network AIS estimation.</p>
<p>Perform correction of the false discovery rate (FDR) after estimation of
active information storage (AIS) for all processes in the network. FDR
correction is applied by correcting the AIS estimate’s omnibus p-values for
individual processes/nodes in the network.</p>
<p>Input can be a list of partial results to combine results from parallel
analysis.</p>
<p>References:</p>
<ul class="simple">
<li><p>Genovese, C.R., Lazar, N.A., &amp; Nichols, T. (2002). Thresholding of
statistical maps in functional neuroimaging using the false discovery
rate. Neuroimage, 15(4), 870-878.</p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>parameters for statistical testing with entries:</p>
<ul class="simple">
<li><p>alpha_fdr : float [optional] - critical alpha level
(default=0.05)</p></li>
<li><p>fdr_constant : int [optional] - choose one of two constants used
for calculating the FDR-thresholds according to Genovese (2002):
1 will divide alpha by 1, 2 will divide alpha by the sum_i(1/i);
see the paper for details on the assumptions (default=2)</p></li>
</ul>
</dd>
<dt>results<span class="classifier">instances of ResultsSingleProcessAnalysis</span></dt><dd><p>results of network AIS estimation, see documentation of
ResultsSingleProcessAnalysis()</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsSingleProcessAnalysis instance</dt><dd><p>input results objects pruned of non-significant estimates</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.stats.check_n_perm">
<span class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></span><span class="sig-name descname"><span class="pre">check_n_perm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_perm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#check_n_perm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.check_n_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if no. permutations is big enough to obtain the requested alpha.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>The no. permutations must be big enough to theoretically allow for the
detection of a p-value that is smaller than the critical alpha level.
Otherwise the permutation test is pointless. The smalles possible
p-value is 1/n_perm.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.stats.max_statistic">
<span class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></span><span class="sig-name descname"><span class="pre">max_statistic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analysis_setup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">candidate_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">te_max_candidate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#max_statistic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.max_statistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform maximum statistics for one candidate source.</p>
<p>Test if a transfer entropy value is significantly bigger than the maximum
values obtained from surrogates of all remanining candidates.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>analysis_setup<span class="classifier">MultivariateTE instance</span></dt><dd><p>information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="simple">
<li><p>n_perm_max_stat : int [optional] - number of permutations
(default=200)</p></li>
<li><p>alpha_max_stat : float [optional] - critical alpha level
(default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data</p>
</dd>
<dt>candidate_set<span class="classifier">list of tuples</span></dt><dd><p>list of indices of remaning candidates</p>
</dd>
<dt>te_max_candidate<span class="classifier">float</span></dt><dd><p>transfer entropy value to be tested</p>
</dd>
<dt>conditional<span class="classifier">numpy array</span></dt><dd><p>realisations of conditional, 2D numpy array where array dimensions
represent [realisations x variable dimension]</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>bool</dt><dd><p>statistical significance</p>
</dd>
<dt>float</dt><dd><p>the test’s p-value</p>
</dd>
<dt>numpy array</dt><dd><p>surrogate table</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.AlgorithmExhaustedError</dt><dd><p>Raised from _create_surrogate_table() when calculation cannot be
made</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.stats.max_statistic_sequential">
<span class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></span><span class="sig-name descname"><span class="pre">max_statistic_sequential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analysis_setup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#max_statistic_sequential"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.max_statistic_sequential" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform sequential maximum statistics for a set of candidate sources.</p>
<p>Test multivariate/bivariate MI/TE values against surrogates. Test highest
TE/MI value against distribution of highest surrogate values, second
highest against distribution of second highest, and so forth. Surrogates
are created from each candidate in the candidate set, including the
candidate that is currently tested. Surrogates are then sorted over
candidates. This is repeated n_perm_max_seq times. Stop comparison if a
TE/MI value is not significant compared to the distribution of surrogate
values of the same rank. All smaller values are considered non-significant
as well.</p>
<p>The conditional for estimation of MI/TE is taken from the current set of
conditional variables in the analysis setup. For multivariate MI or TE
surrogate creation, the full set of conditional variables is used. For
bivariate MI or TE surrogate creation, the conditioning set has to be
restricted to a subset of the current set of conditional variables: for
bivariate MI no conditioning set is required, for bivariate TE only the
past variables from the target are required (not the variables selected
from other relevant sources).</p>
<p>This function will re-use the surrogate table created in the last min-stats
round if that table is in the analysis_setup. This saves the complete
calculation of surrogates for this statistic.</p>
<p>Args:</p>
<blockquote>
<div><dl class="simple">
<dt>analysis_setup<span class="classifier">MultivariateTE instance</span></dt><dd><p>information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="simple">
<li><p>n_perm_max_seq : int [optional] - number of permutations
(default=’n_perm_min_stat’<a href="#id3"><span class="problematic" id="id4">|</span></a>500)</p></li>
<li><p>alpha_max_seq : float [optional] - critical alpha level
(default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array, bool</dt><dd><p>statistical significance of each source</p>
</dd>
<dt>numpy array, float</dt><dd><p>the test’s p-values for each source</p>
</dd>
<dt>numpy array, float</dt><dd><p>TE values for individual sources</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.stats.max_statistic_sequential_bivariate">
<span class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></span><span class="sig-name descname"><span class="pre">max_statistic_sequential_bivariate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analysis_setup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#max_statistic_sequential_bivariate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.max_statistic_sequential_bivariate" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform sequential maximum statistics for a set of candidate sources.</p>
<p>Test multivariate/bivariate MI/TE values against surrogates. Test highest
TE/MI value against distribution of highest surrogate values, second
highest against distribution of second highest, and so forth. Surrogates
are created from each candidate in the candidate set, including the
candidate that is currently tested. Surrogates are then sorted over
candidates. This is repeated n_perm_max_seq times. Stop comparison if a
TE/MI value is not significant compared to the distribution of surrogate
values of the same rank. All smaller values are considered non-significant
as well.</p>
<p>The conditional for estimation of MI/TE is taken from the current set of
conditional variables in the analysis setup. For multivariate MI or TE
surrogate creation, the full set of conditional variables is used. For
bivariate MI or TE surrogate creation, the conditioning set has to be
restricted to a subset of the current set of conditional variables: for
bivariate MI no conditioning set is required, for bivariate TE only the
past variables from the target are required (not the variables selected
from other relevant sources).</p>
<p>This function will re-use the surrogate table created in the last min-stats
round if that table is in the analysis_setup. This saves the complete
calculation of surrogates for this statistic.</p>
<p>Args:</p>
<blockquote>
<div><dl class="simple">
<dt>analysis_setup<span class="classifier">MultivariateTE instance</span></dt><dd><p>information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="simple">
<li><p>n_perm_max_seq : int [optional] - number of permutations
(default=’n_perm_min_stat’<a href="#id5"><span class="problematic" id="id6">|</span></a>500)</p></li>
<li><p>alpha_max_seq : float [optional] - critical alpha level
(default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array, bool</dt><dd><p>statistical significance of each source</p>
</dd>
<dt>numpy array, float</dt><dd><p>the test’s p-values for each source</p>
</dd>
<dt>numpy array, float</dt><dd><p>TE values for individual sources</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.stats.mi_against_surrogates">
<span class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></span><span class="sig-name descname"><span class="pre">mi_against_surrogates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analysis_setup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#mi_against_surrogates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.mi_against_surrogates" title="Permalink to this definition">¶</a></dt>
<dd><p>Test estimated mutual information for significance against surrogate data.</p>
<p>Shuffle realisations of the current value (point to be predicted) and re-
calculate mutual information (MI) for shuffled data. The actual estimated
MI is then compared against this distribution of MI values from surrogate
data.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>analysis_setup<span class="classifier">MultivariateTE instance</span></dt><dd><p>information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="simple">
<li><p>n_perm_mi : int [optional] - number of permutations
(default=500)</p></li>
<li><p>alpha_mi : float [optional] - critical alpha level
(default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float</dt><dd><p>estimated MI value</p>
</dd>
<dt>bool</dt><dd><p>statistical significance</p>
</dd>
<dt>float</dt><dd><p>p_value for estimated MI value</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.AlgorithmExhaustedError</dt><dd><p>Raised from estimate() methods when calculation cannot be made</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.stats.min_statistic">
<span class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></span><span class="sig-name descname"><span class="pre">min_statistic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analysis_setup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">candidate_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">te_min_candidate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#min_statistic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.min_statistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform minimum statistics for one candidate source.</p>
<p>Test if a transfer entropy value is significantly bigger than the minimum
values obtained from surrogates of all remanining candidates.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>analysis_setup<span class="classifier">MultivariateTE instance</span></dt><dd><p>information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="simple">
<li><p>n_perm_min_stat : int [optional] - number of permutations
(default=500)</p></li>
<li><p>alpha_min_stat : float [optional] - critical alpha level
(default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data</p>
</dd>
<dt>candidate_set<span class="classifier">list of tuples</span></dt><dd><p>list of indices of remaning candidates</p>
</dd>
<dt>te_min_candidate<span class="classifier">float</span></dt><dd><p>transfer entropy value to be tested</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of conditional, 2D numpy array where array dimensions
represent [realisations x variable dimension] (default=None, no
conditioning performed)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>bool</dt><dd><p>statistical significance</p>
</dd>
<dt>float</dt><dd><p>the test’s p-value</p>
</dd>
<dt>numpy array</dt><dd><p>surrogate table</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.AlgorithmExhaustedError</dt><dd><p>Raised from _create_surrogate_table() when calculation cannot be
made</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.stats.network_fdr">
<span class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></span><span class="sig-name descname"><span class="pre">network_fdr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">results</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#network_fdr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.network_fdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform FDR-correction on results of network inference.</p>
<p>Perform correction of the false discovery rate (FDR) after network
analysis. FDR correction can either be applied at the target level
(by correcting omnibus p-values) or at the single-link level (by correcting
p-values of individual links between single samples and the target).</p>
<p>Input can be a list of partial results to combine results from parallel
analysis.</p>
<p>References:</p>
<ul class="simple">
<li><p>Genovese, C.R., Lazar, N.A., &amp; Nichols, T. (2002). Thresholding of
statistical maps in functional neuroimaging using the false discovery
rate. Neuroimage, 15(4), 870-878.</p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>parameters for statistical testing with entries:</p>
<ul class="simple">
<li><p>alpha_fdr : float [optional] - critical alpha level
(default=0.05)</p></li>
<li><p>correct_by_target : bool [optional] - if true correct p-values on
on the target level (omnibus test p-values), otherwise correct
p_values for individual variables (sequential max stats p-values)
(default=True)</p></li>
<li><p>fdr_constant : int [optional] - choose one of two constants used
for calculating the FDR-thresholds according to Genovese (2002):
1 will divide alpha by 1, 2 will divide alpha by the sum_i(1/i);
see the paper for details on the assumptions (default=2)</p></li>
</ul>
</dd>
<dt>results<span class="classifier">instances of ResultsNetworkInference</span></dt><dd><p>results of network inference, see documentation of
ResultsNetworkInference()</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsNetworkInference instance</dt><dd><p>input object pruned of non-significant links</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.stats.omnibus_test">
<span class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></span><span class="sig-name descname"><span class="pre">omnibus_test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analysis_setup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#omnibus_test"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.omnibus_test" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an omnibus test on identified conditional variables.</p>
<p>Test the joint information transfer from all identified sources to the
current value conditional on candidates in the target’s past. To test for
significance, this is repeated for shuffled realisations of the sources.
The distribution of values from shuffled data is then used as test
distribution.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>analysis_setup<span class="classifier">MultivariateTE instance</span></dt><dd><p>information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="simple">
<li><p>n_perm_omnibus : int [optional] - number of permutations
(default=500)</p></li>
<li><p>alpha_omnibus : float [optional] - critical alpha level
(default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>bool</dt><dd><p>statistical significance</p>
</dd>
<dt>float</dt><dd><p>the test’s p-value</p>
</dd>
<dt>float</dt><dd><p>the estimated test statisic, i.e., the information transfer from
all sources into the target</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.AlgorithmExhaustedError</dt><dd><p>Raised from estimate() calls when calculation cannot be made</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.stats.syn_shd_against_surrogates">
<span class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></span><span class="sig-name descname"><span class="pre">syn_shd_against_surrogates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analysis_setup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#syn_shd_against_surrogates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.syn_shd_against_surrogates" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the shared/synergistic information in the PID estimate.</p>
<p>Shuffle realisations of the target and re-calculate PID, in particular the
synergistic and shared information from shuffled data. The original
shared and synergistic information are then compared against the
distribution of values calculated from surrogate data.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>analysis_setup<span class="classifier">Partial_information_decomposition instance</span></dt><dd><p>information on the current analysis, should have an Attribute
‘settings’, a dict with optional fields</p>
<ul class="simple">
<li><p>n_perm : int [optional] - number of permutations (default=500)</p></li>
<li><p>alpha : float [optional] - critical alpha level (default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>PID estimate from original data</p>
</dd>
<dt>bool</dt><dd><p>statistical significance of the shared information</p>
</dd>
<dt>float</dt><dd><p>p-value of the shared information</p>
</dd>
<dt>bool</dt><dd><p>statistical significance of the synergistic information</p>
</dd>
<dt>float</dt><dd><p>p-value of the synergistic information</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.stats.unq_against_surrogates">
<span class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></span><span class="sig-name descname"><span class="pre">unq_against_surrogates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analysis_setup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#unq_against_surrogates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.unq_against_surrogates" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the unique information in the PID estimate against surrogate data.</p>
<p>Shuffle realisations of both sources individually and re-calculate PID,
in particular the unique information from shuffled data. The original
unique information is then compared against the distribution of values
calculated from surrogate data.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>analysis_setup<span class="classifier">Partial_information_decomposition instance</span></dt><dd><p>information on the current analysis, should have an Attribute
‘settings’, a dict with optional fields</p>
<ul class="simple">
<li><p>n_perm : int [optional] - number of permutations (default=500)</p></li>
<li><p>alpha : float [optional] - critical alpha level (default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>PID estimate from original data</p>
</dd>
<dt>bool</dt><dd><p>statistical significance of the unique information in source 1</p>
</dd>
<dt>float</dt><dd><p>p-value of the unique information in source 1</p>
</dd>
<dt>bool</dt><dd><p>statistical significance of the unique information in source 2</p>
</dd>
<dt>float</dt><dd><p>p-value of the unique information in source 2</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-idtxl.visualise_graph">
<span id="idtxl-visualise-graph-module"></span><h2>idtxl.visualise_graph module<a class="headerlink" href="#module-idtxl.visualise_graph" title="Permalink to this headline">¶</a></h2>
<p>Plot results of network inference.</p>
<dl class="py function">
<dt class="sig sig-object py" id="idtxl.visualise_graph.plot_mute_graph">
<span class="sig-prename descclassname"><span class="pre">idtxl.visualise_graph.</span></span><span class="sig-name descname"><span class="pre">plot_mute_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/visualise_graph.html#plot_mute_graph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.visualise_graph.plot_mute_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot MuTE example network.</p>
<p>Network of 5 AR-processes, which is used as an example the paper
on the MuTE toolbox (Montalto, PLOS ONE, 2014, eq. 14). The
network consists of five autoregressive (AR) processes with model
orders 2 and les and the following (non-linear) couplings:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">(</span><span class="n">non</span><span class="o">-</span><span class="n">linear</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>Figure handle</dt><dd><p>Figure object from the matplotlib package</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.visualise_graph.plot_network">
<span class="sig-prename descclassname"><span class="pre">idtxl.visualise_graph.</span></span><span class="sig-name descname"><span class="pre">plot_network</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/visualise_graph.html#plot_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.visualise_graph.plot_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot network of multivariate TE between processes.</p>
<p>Plot graph of the network of (multivariate) interactions between processes
(e.g., multivariate TE). The function uses the networkx class for directed
graphs (DiGraph) internally. Plots a network and adjacency matrix.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>results<span class="classifier">ResultsNetworkInference() instance</span></dt><dd><p>output of an network inference algorithm</p>
</dd>
<dt>weights<span class="classifier">str</span></dt><dd><p>for single network inference, it can either be</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>‘max_te_lag’: the weights represent the source -&gt; target</dt><dd><p>lag corresponding to the maximum transfer entropy value
(see documentation for method get_target_delays for details)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘max_p_lag’: the weights represent the source -&gt; target</dt><dd><p>lag corresponding to the maximum p-value
(see documentation for method get_target_delays for details)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘vars_count’: the weights represent the number of</dt><dd><p>statistically-significant source -&gt; target lags</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘binary’: return unweighted adjacency matrix with binary</dt><dd><p>entries</p>
<ul>
<li><p>1 = significant information transfer;</p></li>
<li><p>0 = no significant information transfer.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>for network comparison, it can either be</p>
<blockquote>
<div><ul class="simple">
<li><p>‘union’: all links in the union network, i.e., all
links that were tested for a difference</p></li>
<li><dl class="simple">
<dt>‘comparison’: True for links with a significant difference in</dt><dd><p>inferred effective connectivity (default)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘pvalue’: absolute differences in inferred effective</dt><dd><p>connectivity for significant links</p>
</dd>
</dl>
</li>
<li><p>‘diff_abs’: absolute difference</p></li>
</ul>
</div></blockquote>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>print FDR-corrected results (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>DiGraph</dt><dd><p>instance of a directed graph class from the networkx package</p>
</dd>
<dt>Figure</dt><dd><p>figure handle, Figure object from the matplotlib package</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.visualise_graph.plot_network_comparison">
<span class="sig-prename descclassname"><span class="pre">idtxl.visualise_graph.</span></span><span class="sig-name descname"><span class="pre">plot_network_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/visualise_graph.html#plot_network_comparison"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.visualise_graph.plot_network_comparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot results of network comparison.</p>
<p>Plot results of network comparison. Produces a figure with five subplots,
where the first plot shows the network graph of the union network, the
second plot shows the adjacency matrix of the union network, the third
plot shows the qualitative results of the comparison of each link, the
fourth plot shows the absolute differences in CMI per link, and the fifth
plot shows p-values for each link.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>results<span class="classifier">ResultsNetworkComparison() instance</span></dt><dd><p>network comparison results</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>DiGraph</dt><dd><p>instance of a directed graph class from the networkx package</p>
</dd>
<dt>Figure</dt><dd><p>figure handle, Figure object from the matplotlib package</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="idtxl.visualise_graph.plot_selected_vars">
<span class="sig-prename descclassname"><span class="pre">idtxl.visualise_graph.</span></span><span class="sig-name descname"><span class="pre">plot_selected_vars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign_sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">display_edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/visualise_graph.html#plot_selected_vars"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.visualise_graph.plot_selected_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot network of a target process and single variables.</p>
<p>Plot graph of the network of (multivariate) interactions between source
variables and the target. The function uses the networkx class for directed
graphs (DiGraph) internally. Plots a network and reduced adjacency matrix.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>results<span class="classifier">ResultsNetworkInference() instance</span></dt><dd><p>output of an network inference algorithm</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sign_sources<span class="classifier">bool [optional]</span></dt><dd><p>plot sources with significant information contribution only
(default=True)</p>
</dd>
<dt>display_edge_labels<span class="classifier">bool [optional]</span></dt><dd><p>display TE value on edge lables (default=False)</p>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>print FDR-corrected results (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>DiGraph</dt><dd><p>instance of a directed graph class from the networkx package</p>
</dd>
<dt>Figure</dt><dd><p>figure handle, Figure object from the matplotlib package</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-idtxl">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-idtxl" title="Permalink to this headline">¶</a></h2>
<p>IDTxl: Information Dynamics Toolkit xl.</p>
<p>IDTxl is a comprehensive software package for efficient inference of networks
and their node dynamics from multivariate time series data using information
theory. IDTxl provides functionality to estimate the following measures:</p>
<ol class="arabic">
<li><p>For network inference:</p>
<blockquote>
<div><ul class="simple">
<li><p>multivariate transfer entropy (TE)/Granger causality (GC)</p></li>
<li><p>multivariate mutual information (MI)</p></li>
<li><p>bivariate TE/GC</p></li>
<li><p>bivariate MI</p></li>
</ul>
</div></blockquote>
</li>
</ol>
<ol class="arabic" start="3">
<li><p>For analysis of node dynamics:</p>
<blockquote>
<div><ul class="simple">
<li><p>active information storage (AIS)</p></li>
<li><p>partial information decomposition (PID)</p></li>
</ul>
</div></blockquote>
</li>
</ol>
<p>IDTxl implements estimators for discrete and continuous data with parallel
computing engines for both GPU and CPU platforms. Written for Python3.4.3+.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">idtxl package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-idtxl.data">idtxl.data module</a></li>
<li><a class="reference internal" href="#module-idtxl.bivariate_te">idtxl.bivariate_te module</a></li>
<li><a class="reference internal" href="#module-idtxl.bivariate_mi">idtxl.bivariate_mi module</a></li>
<li><a class="reference internal" href="#module-idtxl.bivariate_pid">idtxl.bivariate_pid module</a></li>
<li><a class="reference internal" href="#module-idtxl.multivariate_te">idtxl.multivariate_te module</a></li>
<li><a class="reference internal" href="#module-idtxl.multivariate_mi">idtxl.multivariate_mi module</a></li>
<li><a class="reference internal" href="#module-idtxl.multivariate_pid">idtxl.multivariate_pid module</a></li>
<li><a class="reference internal" href="#module-idtxl.active_information_storage">idtxl.active_information_storage module</a></li>
<li><a class="reference internal" href="#module-idtxl.embedding_optimization_ais_Rudelt">idtxl.embedding_optimization_ais_Rudelt module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_Rudelt">idtxl.estimators_Rudelt module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_jidt">idtxl.estimators_jidt module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_opencl">idtxl.estimators_opencl module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_mpi">idtxl.estimators_mpi module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_python">idtxl.estimators_python module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_multivariate_pid">idtxl.estimators_multivariate_pid module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_pid">idtxl.estimators_pid module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_exceptions">idtxl.idtxl_exceptions module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_io">idtxl.idtxl_io module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_utils">idtxl.idtxl_utils module</a></li>
<li><a class="reference internal" href="#module-idtxl.network_analysis">idtxl.network_analysis module</a></li>
<li><a class="reference internal" href="#module-idtxl.network_inference">idtxl.network_inference module</a></li>
<li><a class="reference internal" href="#module-idtxl.single_process_analysis">idtxl.single_process_analysis module</a></li>
<li><a class="reference internal" href="#module-idtxl.network_comparison">idtxl.network_comparison module</a></li>
<li><a class="reference internal" href="#module-idtxl.results">idtxl.results module</a></li>
<li><a class="reference internal" href="#module-idtxl.stats">idtxl.stats module</a></li>
<li><a class="reference internal" href="#module-idtxl.visualise_graph">idtxl.visualise_graph module</a></li>
<li><a class="reference internal" href="#module-idtxl">Module contents</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="idtxl_helper.html"
                          title="previous chapter">Helper functions</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/idtxl.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="idtxl_helper.html" title="Helper functions"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">IDTxl 1.5.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">idtxl package</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Patricia Wollstadt, Joseph T. Lizier, Raul Vicente, Conor Finn, Mario Martinez-Zarzuela, Pedro Mediano, Leonardo Novelli, Michael Wibral.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>